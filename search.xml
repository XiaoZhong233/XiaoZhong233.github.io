<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux常见命令-用户管理命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[useradd功能描述：添加新用户 执行权限：root 命令所在路径：/usr/sbin/useradd 1useradd xxx #用户名 passwd如果需要给用户密码好让该用户访问系统，则需要用到该命令 功能描述：设置用户密码 执行权限：所有用户 命令所在路径：/usr/bin/passwd 1passwd xxx #用户名 如果不加参数，则更改当前用户的密码 1passwd who功能描述：查看登录用户信息 执行权限：所有用户 命令所在路径：/usr/bin/who 123[root@ecs-s2-medium-2-linux-20190722215607 /]# whoroot tty1 2019-08-07 11:17root pts/4 2019-08-16 22:08 (183.39.158.131) 第一个部分是登录的用户名，第二个是登录终端（tty1是本地登录，pts表示远程登录），第三个是登录的时间，最后的是登录的主机ip（缺省为本地登录） w功能描述：查看登录用户详细信息 执行权限：所有用户 命令所在路径： /usr/bin/w 12345[root@ecs-s2-medium-2-linux-20190722215607 /]# w 23:17:56 up 25 days, 2 min, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 07Aug19 9days 0.01s 0.01s -bashroot pts/4 183.39.158.131 22:08 4.00s 0.02s 0.00s w load average: 0.00, 0.01, 0.05表示1分钟，5分钟，10分钟内负载百分比 IDLE表示该用户空闲了多久，PCPU表示CPU时间 ，JCPU表示总共占用的CPU实际 WHAT表示用户当前执行的命令]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令-帮助命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[man命令man可以查看命令的帮组和配置文件的帮助 man查看命令信息例如想要查看ls的帮助信息 1man ls 查看ls命令的帮助信息 按空格翻页 按q离开 NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息，输入/xxx即可 man查看配置文件信息例如查看 locale.conf配置，注意不需要加绝对路径，直接名字即可 1man locale.conf NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息 往后翻，可以查看到使用的方法 1234567OPTIONS The following locale settings may be set using /etc/locale.conf: LANG=, LANGUAGE=, LC_CTYPE=, LC_NUMERIC=, LC_TIME=, LC_COLLATE=, LC_MONETARY=, LC_MESSAGES=, LC_PAPER=, LC_NAME=, LC_ADDRESS=, LC_TELEPHONE=, LC_MEASUREMENT=, LC_IDENTIFICATION=. Note that LC_ALL may not be configured in this file. For details about the meaning and semantics of these settings, refer to locale(7).EXAMPLE Example 1. German locale with English messages 特殊情况如果碰到一个即是命令又是配置文件的该怎么办？ 例如passwd命令 用whereis查看passwd 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whereis passwdpasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.5.gz 可以看到查出来既有命令又有配置文件，第一个是命令的位置，第二个是配置文件的位置，第三个是命令帮助文件的位置，第四个是配置文件帮助命令的位置 1是命令的帮助 5是配置文件的帮助。优先显示命令的帮组 1man 5 passwd 即可查看该配置文件的信息 whatis命令如果只是想简单的看下该命令是做什么的可以用此命令 1what is 该命令会直接显示NAME的信息，这样就不用看一大片的英文了。 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whatis lsls (1) - list directory contents apropos 命令如果想简单的查看配置文件的信息，用该命令即可 例如 12[root@ecs-s2-medium-2-linux-20190722215607 /]# apropos locale.conflocale.conf (5) - Configuration file for locale settings –help 选项利用--help会把常见的选项信息列出 123456789101112131415161718192021222324[root@ecs-s2-medium-2-linux-20190722215607 /]# ls --helpUsage: ls [OPTION]... [FILE]...List information about the FILEs (the current directory by default).Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be 'never', 'auto', or 'always' (the default); more info below -d, --directory list directories themselves, not their contents -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -ls --color help 命令该命令可以查看Shell内置命令的帮助信息 什么是内置命令？在shell中默认设置的命令就是内置命令。shell的作用就是向内核解释代码。 例如cd命令 12[root@ecs-s2-medium-2-linux-20190722215607 /]# type cdcd is a shell builtin 使用help命令查看cd命令 12345678910111213141516171819202122232425262728[root@ecs-s2-medium-2-linux-20190722215607 /]# help cdcd: cd [-L|[-P [-e]]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars' is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed -P use the physical directory structure without following symbolic links -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status The default is to follow symbolic links, as if `-L' were specified. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. 总结 man 查看命令或配置文件帮助 whatis 获得命令简短的信息 apropos 获得配置文件的简短信息 help 查看shell查看shell内置命令信息]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署云服务器的全过程]]></title>
    <url>%2F2019%2F08%2F16%2Fhexo%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言由于不想部署在github上，因为Github的访问速度在国内比较慢，所以有了此文。 部署之前先了解一下hexo利于git更新的流程，部署在Github上和部署在云服务器上没有特别大的本质区别。 整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。再利于nginx托管这些静态资源，就可以实现快速的访问。 环境本地环境 Windows10(64bit) 已经装好了git,nodejs,hexo 已经在本地调试好了hexo静态网站 服务器环境 华为云ECS（1M1核2G，centos7） 已经装好了git，nodejs，以及编译好了Nginx 本地机器配置配置密钥在本地机器（Windows环境）中进入 使用git bash生成ssh公钥12# 本地 windows gitBashssh-keygen -t rsa 一路回车，直至如下图，即可。 在本地服务器中配置好了公钥，接下来我们需要把这个公钥交给服务器，相当于本地机器有了一把能访问服务器的“钥匙”，所以接下来需要配置服务器。 服务器配置安装Git,nodejs,Nginx等linux下安装这些非常简单，直接百度即可。 创建git新用户及配置创建git新用户1234adduser git #加入git用户passwd git #配置你的密码chmod 740 /etc/sudoers #修改权限 r=4 w=2 x=1 rwx=7 r__=4 ___=0,也就是说git的sudo使用权为只读vim /etc/sudoers 打开suduers，找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在他的下面加入以下内容 1git ALL=(ALL) ALL wq保存后，需要将权限修改回来 1chmod 400 /etc/sudoers 将公钥配置到服务器上首先你得在你的本地机器上找到你的公钥，一般在用户的家目录下，windows是Administrator目录，linux是~/.ssh下 我的本地机器是windows，所以在Administrator目录下。 将该文件的内容复制。 在服务器端，切换至刚刚创建好的git用户下，创建.ssh文件和authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 修改权限 123cd ~chmod 600 .ssh/authorzied_keys # 将文件设置为可读可写chmod 700 .ssh #将该文件夹设置为可读可写可执行，注意文件夹的可执行是指能访问 测试git连接切换到本地机器上，在本地机器上测试是否能连接到你的远程git用户 1ssh -v git@SERVER_IP 测试成功 如果你的测试不成功，请查看具体的输出信息，通常是公钥没配置好，可以把原来生成的公钥删了，重新配置一遍。 创建网站的根目录创建网站的根目录的目的是为了让nginx托管这些静态文件。 创建一个目录用于作为网站的根目录。切换成root用户 12su rootmkdir /home/hexo # 此目录为网站的根目录 变更该目录的所有者 1chown git:git -R /home/hexo 安装以及配置Nginx安装过程略，具体可百度。编译好nginx后，进入其配置文件 1vim conf/nginx.conf 在http端下配置你的虚拟主机 12345678910111213141516171819server&#123; listen 8081; #监听8081端口 server_name 139.159.245.212; #你的服务器名，通常是域名，如果是域名，你就需要监听80端口 root /home/hexo; #网站的根目录 location / &#123; &#125;#access_log logs/access.log mylog;error_page 404 /404.html; #配置40x页面 location = /40x.html &#123;&#125;error_page 500 502 503 504 /50x.html; #配置50x页面 location = /50x.html &#123;&#125;&#125; 注意使用 nginx -t 命令检查配置文件的语法是否出错。然后使用 systemctl restart nginx.service 或者 在编译好的nginx目录下使用sbin/nginx -s reload命令重启服务即可。 实现自动化部署建立git裸库该裸库什么版本信息和数据都不保存，单纯是为了共享而存在。 在root 用户下 123su rootcd /home/git # 在 git 用户目录下创建git init --bare hexo.git 这时，git 用户的 ~ 目录下就存在一个 hexo.git 文件夹，可使用 ls 命令查看。再修改 hexo.git 的所有者。 1chown git:git -R hexo.git 使用 git-hooks 同步网站根目录在这使用的是 post-receive 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 blog.git 裸库的 hooks 文件夹中，新建 post-receive 文件。 1vim hexo.git/hooks/post-receive 填入以下内容，其中 /home/hexo 为网站目录，根据自己的填入,保存退出。 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/hexo.git checkout -f 该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下 -f这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了 保存后，要赋予这个文件可执行权限。 1chmod +x /home/git/hexo.git/hooks/post-receive 这样就完成了git自动部署的配置 本地机器中部署至服务器在本地中，和部署到 github 服务一样，需要先 hexo g 命令生成静态文件，通过 hexo s 命令能够正常进行本地访问，并且确保已经安装了 hexo-deployer-git。 配置hexohexo 根目录下的 _config.yml 文件，找到 deploy。 1234deploy: type: git repo: git@SERVER:/home/git/hexo.git # 填写你的服务器地址 将SERVER替换掉 branch: master # 分支 之后按照正常的流程部署 1hexo c &amp;&amp; hexo g &amp;&amp; hexo d 测试自动化部署 部署成功，访问测试]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬取CSDN博客列表]]></title>
    <url>%2F2019%2F08%2F16%2FScrapy%E7%88%AC%E5%8F%96CSDN%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 其可以应用在数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。 具体可查看文档 scrapy中文文档 新建Scrapy爬虫项目如果你还没有安装Scrapy，可以通过下面这个命令安装 1pip install scrapy 新建一个项目安装好之后就可以创建项目了 1scrapy startproject 你的项目名 创建好之后的目录如上图所示 每个文件的具体作用可以参照Scrapy的官方文档，这里就不再赘述。 新建一个爬虫通过命令 1scrapy genspider 你的爬虫名 设置配置文件如果你不需要存入数据库或者做进一步的反爬处理，则可以跳过这一步，打开setting.py进行以下修改 设置浏览器名把BOT_NAME设置为你的浏览器名，如果使用默认，别人一看就知道是爬虫 1BOT_NAME = 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11' 设置日志级别这样就不需要打印太多日志信息，干扰视线 1LOG_LEVEL='WARN' 设置模式将机器人模式设为FALSE 1ROBOTSTXT_OBEY = False 设置你要抓取的博客页数12#博客页数CsdnPage = 2; 设置你的数据库为了方便将数据自动导入数据库，需要设置数据库配置信息，我使用的是mysql 1234567#数据库设置MYSQL_HOST = '你的主机名'MYSQL_PORT = 3306 #端口MYSQL_DBNAME = 'DBNAME' # 数据库名MYSQL_TABLE = 'TABLE_NAME' #表名MYSQL_USER = '你的用户名' MYSQL_PASSWD='你的密码' 新建数据项数据项的作用是方便scrapy以结构化的数据插入到数据库中。 打开 items.py，复制一下代码即可，或者你如果要爬新的数据，请记得加入新的字段 12345678import scrapyclass CsdnItem(scrapy.Item): # define the fields for your item here like: title = scrapy.Field() url = scrapy.Field() #date = scrapy.Field() tag = scrapy.Field() pass 编写爬虫文件123456789101112131415161718192021222324252627282930313233import scrapyfrom ..items import CsdnItemfrom ..settings import CsdnPageclass CsdnSpiderSpider(scrapy.Spider): name = &apos;csdn_spider&apos; allowed_domains = [&apos;blog.csdn.net&apos;] start_urls = [&apos;https://blog.csdn.net/weixin_41154636/article/list/1&apos;] def parse(self, response): try: for div in response.xpath(&apos;//div[contains(@class,&quot;article-item-box&quot;)]&apos;): item = CsdnItem() item[&apos;title&apos;] = div.xpath(&apos;./h4/a/text()&apos;)[1].extract().strip() item[&apos;url&apos;] = div.xpath(&apos;./h4/a/@href&apos;)[0].extract().strip() item[&apos;tag&apos;] = item[&apos;url&apos;].split(&apos;/&apos;)[-1] # 爬取时间戳，方便按时间排序 # item[&apos;date&apos;] = div.xpath(&apos;//span[@class=&quot;date&quot;]/text()&apos;)[1].extract().strip() # 我也不知道为什么抓出来会有这个- -，所以特殊处理一下 if item[&apos;title&apos;] == &apos;帝都的凛冬&apos;: continue # 控制台输出 print(item[&apos;title&apos;] + &quot; &quot; + item[&apos;url&apos;] + &quot; &quot; + item[&apos;tag&apos;]) # 封装成bean，装入数据库 yield item # 实现翻页的功能 for page in range(2, CsdnPage + 1): url = &quot;https://blog.csdn.net/weixin_41154636/article/list/%s&quot; % page yield scrapy.Request(url, callback=self.parse) except BaseException: print(BaseException.__cause__) pass 具体代码的说明注释已经写得很清楚了。 另外，需要注意的是，因为CSDN的翻页是通过ajax请求实现的，所以需要自己构造请求。 如果发现跑不起来，很可能是因为CSDN的HTML结构发生了改变，你可以了解一下XPATH的写法，然后修改即可。 先看下运行结果吧： 进入到spiders目录中运行 1scrapy crawl csdn_spider #你的爬虫名，在上面的代码最开始定义的 DONE！信息已经爬下来了，接下来就是把数据保存至数据库中。 保存数据至数据库在setting.py中，把pipeline注释去掉 123ITEM_PIPELINES = &#123; 'csdn.pipelines.CsdnPipeline': 300,&#125; 在piplines.py中编写一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pymysqlfrom scrapy.utils.project import get_project_settingsfrom twisted.enterprise import adbapifrom .items import CsdnItemclass DBHelper: def __init__(self): self.settings = get_project_settings() # 获取settings配置数据 dbparams = dict( host=self.settings['MYSQL_HOST'], # 读取settings中的配置 db=self.settings['MYSQL_DBNAME'], user=self.settings['MYSQL_USER'], passwd=self.settings['MYSQL_PASSWD'], charset='utf8', # 编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) # **表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... dbpool = adbapi.ConnectionPool('pymysql', **dbparams) self.dbpool = dbpool def connect(self): return self.dbpool # 插入数据 def insert(self, item): self.settings = get_project_settings() # 获取settings配置数据 if isinstance(item, CsdnItem): tb_name = self.settings['MYSQL_TABLE'] sql = """insert into """ + tb_name + """(id,title,link) values (%s,%s,%s) """ # print(sql) # 调用插入的方法 query = self.dbpool.runInteraction(self._conditional_insert, sql, item) # 调用异常处理方法 query.addErrback(self._handle_error) return item # 写入数据库中 def _conditional_insert(self, canshu, sql, item): # 取出要存入的数据，这里item就是爬虫代码爬下来存入items内的数据 if isinstance(item, CsdnItem): import datetime # 字符串转为DateTime类型 # dateTime_p = datetime.datetime.strptime(item['date'], '%Y-%m-%d %H:%M:%S') params = ( item['tag'], item['title'], item['url']) canshu.execute(sql, params) # 错误处理方法 def _handle_error(self, failue): pass print('--------------database operation exception!!-----------------') # self.connect.rollback() print(failue)# 这里执行scrapy处理脚本class CsdnPipeline(object): def __init__(self): self.db = DBHelper() def process_item(self, item, spider): # 插入数据库 self.db.insert(item) return item 具体说明注释已经写的很清楚了。 这样就完成了导入至数据库的工作 再次运行爬虫。 1scrapy crawl csdn_spider 可以看到，数据就全部自动导入到数据库了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理：系统总线总结]]></title>
    <url>%2F2019%2F08%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总线的基本概念历史：早期计算机采用分散连接的方式，这种连接方式以运算器为中心，I/O与存储器交换信息时，都要通过运算器，致使运算器停止运算。为了提高CPU工作效率，改进为存储器为中心的分散连接。随着IO设备的增多，这种连接方式逐渐淘汰，所以出现了总线连接的方式。计算机使用总线结构便于增减外设，同时减少了信息传输线。 知识点： 总线：总线是连接多个部件的信息传输线，是各部件共享的传输介质。以CPU为中心的双总线结构：包括存储总线（M总线）和I/O总线，前者连接CPU和主存，后者连接CPU和I/O。缺点：这种结构在I/O与主存进行交换信息依然要占用CPU单总线结构:单独拉出一条系统总线，CPU，主存，和各IO设备连接到该系统总线。当I/O与主存进行交换信息时，CPU可以继续处理不访问主存或I/O设备的操作。缺点：因为只有一组总线。容器发生冲突，就必须设置判优逻辑，这会影响整机的工作速度以存储器为中心的双总线结构：在单总线的基础上又开辟了一条CPU与主存之间的总线（存储总线）。存储总线只提供主存与CPU直接的信息传输。有点像上面两种结构的折中。 总线的分类分类标准： 按数据传送方式可分为：并行传输总线和串行传输总线 按总线的使用范围可分为 计算机总线，测控总线，网络通信总线 （==重点==）按连接部件分 片内总线，系统总线，通信总线。片内总线：芯片内部的总线，如：CPU内部，寄存器和寄存器之间，寄存器和ALU之间都是由片内总线连接，速度极快。系统总线：系统总线是指：在CPU，主存，I/O设备各大部件之间的信息传输线。系统总线下面按照传输信息的不同又可分为数据总线，地址总线，控制总线1. 数据总线用来传输各部件之间的数据信息，双向数据线。2.地址总线用来指出数据总线上的源数据或目的数据所在主存单元或I/O设备的地址。单向传输：由CPU输出。用来指明CPU要访问的存储单元或I/O地址3.控制总线用来发出各种控制信号的传输线（控制信号，响应信号，时序信号）。对于某个特定的控制线来说他是单向的，但是从总体上看控制总线是双向的。 （举个例子，假如有A,B两条控制线，其中A的方向为CPU到I/O，B的方向为I/O到CPU，对于A,B来说，他们的控制信号传输方向是不能改变的，但从总体上看，控制总线既有从CPU-&gt;I/O的，也有I/O到CPU的，所以总体上是双向的） 通信总线按传输方式分为两种：串行通信和并行通信 1.串行通信串行通信是指单条1位宽的数据线，一位一位分时地进行传输。 2.并行通信多条并行的1位宽的数据，同时进行传输。 3.对比 - 串行通信 并行通信 优点 稳定，信号不易受到干扰 传输速率快 缺点 传输速率慢 易受干扰 适用场景 远距离传输 近距离传输 # 总线的特性及性能指标 ## 总线特性 1. 机械特性 指连接方式上的一些特性 2. 电气特性 指每个传输线的信号的传递方向和电平范围（什么范围为高？什么范围为低） 3. 功能特性 每个传输线的功能 4. 时间特性 任一根线在什么时间内有效 总线指标 总线宽度：数据总线的根数，用位（bit）表示 总线带宽：单位时间内总线上传输数据的位数 通常用MBps（兆字节每秒） （注意与bps进行区别，bps指的是波特率，是单位时间内传输的位数） 总线复用：一条信号线上分时传送两种信号。采用多路复用技术实现 时钟同步/异步 信号线数 总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等 其他指标：负载能力、电源电压、总线宽度是否可以扩展等 负载能力：指驱动能力，当总线接上负载后，总线输入输出的逻辑电平是否保持在额定范围内。 总线标准1. ISA总线 具有独立于CPU的总线时钟 总线宽度为16位，地址线为24位 CPU需花大量时间来控制和外部设备交换数据2.EISA总线 在ISA总线的基础得来，从CPU分离出了总线控制权 总线宽度为32位，地址宽度为32位3.VESA(VL-BUS)总线 总线宽度为32位，可扩展至64位4.PCI总线 高性能，不依赖某个具体的处理器，数据线为32位可扩展至64位 兼容性良好 支持即插即用（Plug and Play）（PCI和USB都支持） 采用多路复用技术 ………………. 5.AGP总线AGP（Accelerated Graphics Port 加速图形端口）处理三维数据和图形的总线，一般用于显卡。 6.RS-232C总线一种串行通信总线，可用于实现载波通信 7.USB总线通用串行总线（USB）具有以下特征 即插即用 很强的连接能力，可以连接多个外设到一个系统 数据传输率 1.0可达1.5Mbps 2.0可达480Mbps 标准统一 体积小巧 生命力强 总线结构一般分为单总线结构和多总线结构 单总线结构有个系统总线，CPU，主存，I/O设备都挂在上面，容易造成计算机性能的瓶颈。 多总线结构双总线结构：包括主存总线和I/O总线三总线结构：包括主存总线（CPU和主存之间）、I/O总线（CPU和IO之间）和DMA总线（主存和IO之间） 总线控制总线控制包括了判优控制和通信控制：主模块：主模块对总线有控制权从模块：从模块只能响应主模块发来的总线命令，没有总线控制权 判优控制判优控制可分为集中式和分布式两种 集中式 链式查询其控制总线由BS（总线忙）,BR（总线请求）,BG（总线同意）三条线构成。BG是串行地由一个I/O接口送到下一个I/O接口。如果到达的接口有请求，BG信号就不再往下传，意味着该接口获得了总线的使用权，然后建立BS（总线忙）信号。优先级逐级递减，对电路故障敏感 计数器定时查询相比链式查询，少了一根总线同意线（BG），多了一组设备地址线。工作方式： 总线控制器接到BR线送来的总线请求信号后，在总线未被使用的情况下（BS=0）由计数器开始计数，并通过设备地址线发出一组地址信号，然后某个与该信号一致的设备获得总线使用权。此时终止计数查询，查询可以从0开始（此时优先级逐级递减），也可以从上一次终止计数的地方开始（此时各部件优先级相同，这种也叫循环计数） 独立请求方式独立请求方式，每一设备都有单独的一组BR（总线请求）和BG（总线同意）。而总线控制部件中有一排队电路，可按优先次序确定响应哪个设备的请求。特点是响应时间短，速度快，但控制复杂 对比 - 优点 缺点 控制线数 链式查询 控制简单，仅用三根线即可控制并且很容易扩充设备 对电路故障敏感，低优先级的设备很难获得控制权 3根 计数器定时查询 优先次序可以被改变，对电路故障没那么敏感 增加了控制线，控制也比较复杂 ${log_2{n}}$ 独立请求方式 响应速度快，优先次序控制灵活 控制线线路较多，控制复杂 2n 分布式考纲和书上没有，不总结 通信控制目的：解决通信双方如何获知信息传输开始和传输结束，以及通信双方如何协调与配合可分为：同步，异步，半同步，分离式 总线周期（通信周期） 申请分配阶段由主模块提出申请，经过总线仲裁机构决定下一周期总线使用权给哪个申请者 寻址阶段获得了使用权的主模块通过总线发出本次要访问的从模块的地址和有关命令 传数阶段主模块和从模块进行数据交换。 结束阶段主模块让出总线控制权 通信方式同步通信通信双方由统一时钟信号控制下进行通信，时钟信号通常由CPU的总线控制部件发出，每个周期内完成特定的任务。 异步通信不采用统一的时钟信号控制通信，而采用应答的方式进行通信可分为：不互锁，半互锁，全互锁 1. 不互锁 对于主模块来说：主模块发出信息后，不需要等待街道从模块的回答信号，而是经过一段时间，便撤销请求信号 对于从模块来说：从模块接收到请求后，在条件就发出回答信号，并经过一段时间，便撤销回答信号。 应用场景：CPU向主存写信息 2.半互锁 对于主模块来说：主模块发出请求信号，必须接到从模块的回答信号才撤销其请求信号，有互锁关系 对于从模块来说：从模块接到请求信号后发出回答信号，而不必等待获知主模块的撤销请求信号，而是隔一段时间后就撤回回答信号，无互锁关系。 应用场景多机系统中，CPU访问共享存储器，CPU发出访存命令后，必须接收到存储器未被占用的回答信号，才能进行真正的访存操作 3.全互锁 对于主模块来说：主模块发出请求信号，必须接收到从模块的回答信号，然后发出撤销请求信号，存在互锁关系 对于从模块来说：从模块发出回答信号之后，必须等待获知主模块的撤销请求信号，存在互锁关系 应用场景：网络通信，例如著名的三次握手半同步通信半同步通信既保留了同步通信的特点（发送方所有的地址，命令、数据信号的发出时间在系统时钟的某个上升沿开始，接收方都采用系统时钟后沿时刻进行识别判断），同时又通过插入N个“等待”（WAIT）信号解决与协调通信速度不一致的问题，双方像异步通信那也，允许不同速度的模块进行工作分离式通信进一步分析总线传输周期得知，除了申请总线这一阶段，其余时间主要花在下面3个地方 主模块通过传输总线向从模块发出地址与命令 从模块准备数据 从模块经过数据总线向主模块发送数据 可以看见，在2中从模块准备数据的过程中，总线并没有完全利用，处于等待状态，为了发掘系统每一瞬间的潜力，因此采用了分离式通信。分离式通信将传输周期（or总线周期）分为两个子周期。 第一个子周期模块A在获得总线使用权后，将命令，地址等信息发到系统总线上，然后立刻放弃总线使用权，给别的模块使用 第二个子周期B模块接收到命令后，经过一段时间（译码，读取）准备好数据之后，申请总线控制权，一旦获批，B模块便把数据放到系统总线上，传输给A，然后立刻放弃总线控制权。显然：上面两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习总结]]></title>
    <url>%2F2019%2F07%2F30%2FReact%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言前端可以做到读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序，而不是信息的纯展示。这种单张网页的应用程序称为 SPA（single-page-application）。2010年后，前端工程师从开发页面（切模板），逐渐变成了开发“前端应用”（跑在浏览器里面的应用程序）。目前，最流行的前端框架 Vue、Angular、React 等等，都属于 SPA 开发框架。 react脚手架建立工程1、安装1npm install create-react-app -g 2、创建1create-react-app react-demo (react-demo项目名) 3、初始化1cd react-demo 1npm install or cnpm install or yarn install 4、运行1yarn start 创建一个helloWorld Demo引入模块 12345//第一步 导入reactimport React,&#123;Component&#125; from 'react';import '../assets/css/index.css'import logo from '../assets/images/logo.svg';import '../assets/css/App.css'; 1234567891011121314151617181920212223242526272829303132/** * 绑定原生属性注意： * class 要换成className * for 要换成htmlFor * style 要用&#123;&#125;包裹成对象 *///第二步，编写组件类并继承React.Componentclass Home extends Component&#123; constructor()&#123; super(); //定义数据 this.state=&#123; msg:'你好，世界！' &#125; &#125;//第三步，重写render()方法，用于渲染页面 render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;img src=&#123;logo&#125; width='500px'&gt;&lt;/img&gt; &lt;/div&gt; ); &#125;&#125;//第四步，导出该类export default Home; 然后启动工程即可完成一个简单的demo 1yarn start react是面向组件的，通过JSX语法来操作虚拟dom节点，如果state的数据发生了变化则会触发对应的dom的刷新。JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 注意在本地引用img等资源时，需要通过{xx}对象形式引用。如果是网络图片，直接用url引用即可。 JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 react 通过state来定义和绑定数据，但这种绑定并不是MVVM那种双向数据绑定，在JSX中要使用时通过 123456789101112131415161718192021## 知识点：### 1. 目录结构分析![20190816155754](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155754.png!blog)用脚手架创建的工程的目录是有些不完整的，需要补全（为了方便归档）component文件主要放组件，model放数据模型，App.js是默认的根组件，index.js是入口文件，相当于main，yarn.lock是项目生成的临时文件，package.json是依赖管理文件（类似maven的pom文件），nodel_modules是存放依赖包的文件夹### 2. 创建组件第一步 导入react第二步，编写组件类并继承React.Component第三步，重写render()方法，用于渲染页面第四步，导出该类### 3. JSX注意事项如果要在模板中嵌套多个HTML标签，需要使用一个父元素对其进行包裹 &lt;div&gt; &lt;h1&gt;{this.state.msg}&lt;/h1&gt; &lt;img src={logo} width=&apos;500px&apos;&gt;&lt;/img&gt; &lt;/div&gt;12345### 4.绑定数据或对象js中定义对象用&#123;&#125;,其实就是restful风格的东东。类似于 { title:”xxx”, content:”xxxx”} 123数据的定义用[ ]，一对方括号即可。在react中绑定对象只需要在state中定义即可 this.state={ msg:’你好，世界！’ } 12# 事件及数据绑定Demo import React from ‘react’ class Demo1 extends React.Component{ constructor(props){ super(props); this.state={ msg:”demo1组件”, text:””, keydown:””, } } run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; } inputChange=(e)=&gt;{ //获取表单的值 //console.log(e.target.value); this.setState({ text: e.target.value }) } inputChange1=()=&gt;{ let value = this.refs.input.value; this.setState({ text: value }) } getInputValue=()=&gt;{ alert(this.state.text) } inputOnKeydown = (e)=&gt;{ console.log(e.keyCode); this.setState({ keydown:e.keyCode }) } inputChange2 = (e)=&gt;{ this.setState({ text:e.target.value }) } changeTextMode = (e)=&gt;{ this.setState({ text:&quot;改变后的model值,可以看到下面这个输入框的数据已经改变，而上面两个输入框未发生变化&quot; }) } render(){ return ( &lt;div&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;事件对象演示&lt;/h2&gt; {this.state.msg} {/* 事件对象 */} &lt;button id=&apos;buttonId&apos; onClick={this.run}&gt;事件对象&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;表单事件演示&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input type=&quot;text&quot; onChange={this.inputChange}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;ref获取dom节点,获得表单值&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input ref=&apos;input&apos; type=&quot;text&quot; onChange={this.inputChange1}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;键盘事件&lt;/h2&gt; &lt;p&gt;{this.state.keydown}&lt;/p&gt; &lt;input type=&quot;text&quot; onKeyDown={this.inputOnKeydown}/&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;react实现双向数据绑定&lt;/h2&gt; &lt;p&gt;model改变影响view(通过value属性),view改变影响model&lt;/p&gt; &lt;p&gt;model值：{this.state.text}&lt;/p&gt; &lt;input type=&apos;text&apos; value={this.state.text} onChange={this.inputChange2}&gt;&lt;/input&gt; &lt;button onClick={this.changeTextMode}&gt;改变model的值&lt;/button&gt; &lt;/div&gt; ) }} export default Demo1 ; 123456789![20190816155821](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155821.png!blog)## 知识点：### 事件绑定：1. 绑定事件需要在对应的事件响应中获得正确的this对象 例如：为Button 绑定了一个事件 事件对象 12如果你用箭头函数写响应方法，则this指向的就是react的当前组件 run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12如果你用的是普通写法写的函数响应 funtion run(e){ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12需要使用下面这种写法传递对象指向 事件对象 12### 数据绑定（View-&gt;Model） {this.state.text} 12 inputChange=(e)=&gt;{ //获取表单的值，设置model的数据 //console.log(e.target.value); this.setState({ text: e.target.value }) }12### 数据绑定（Model-&gt;View） 获取表单值 12 getInputValue=()=&gt;{ alert(this.state.text) //获取model中的数据 } 12### 双向数据绑定（M-&gt;V&amp;V-&gt;M 俗称MVVM） react实现双向数据绑定 model改变影响view(通过value属性),view改变影响model model值：{this.state.text} 改变model的值 12345678value 通过属性绑定model 完成 m-&gt;v的绑定通过监听onChange完成v-&gt;m的绑定 ，和上面那个View-&gt;Model的绑定是一样的。# TodoList小练习该练习的旨在熟悉双向数据绑定和react的基础用法，另外扩展了localStorage缓冲处理方案，实现刷新不会丢失数据状态。![20190816155842](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155842.png!blog) import React, {Component}from ‘react’;import Storage from ‘../model/storage’ class Demo3 extends Component { constructor(props) { super(props); this.state = { todo:’’, todolist:[], }; } //生命周期函数，页面加载触发 componentDidMount=()=&gt;{ let list = Storage.get(&apos;todolist&apos;); if(list){ console.log(&quot;get:&quot;+list) this.setState({ todolist:list }) } } addTodoText=(e)=&gt;{ this.setState({ todo: e.target.value }) } onAddBtnClick=()=&gt;{ let todolist = this.state.todolist; todolist.push({ todo:this.state.todo, checked:false }) this.setState({ todolist:todolist, todo:&quot;&quot; }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } onPressEnter=(e)=&gt;{ if(e.keyCode==13){ this.onAddBtnClick(); } } ondelBtnClick=(index)=&gt;{ let todolist = this.state.todolist; todolist.splice(index,1); this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } checkChange = (index)=&gt;{ let todolist = this.state.todolist; todolist[index].checked=!todolist[index].checked; this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } render() { return ( &lt;div&gt; &lt;h2&gt;todoList 演示&lt;/h2&gt; &lt;header&gt;&lt;input type=&quot;text&quot; value={this.state.todo} onChange={this.addTodoText} onKeyDown={this.onPressEnter}/&gt; &lt;button onClick={this.onAddBtnClick}&gt;增加&lt;/button&gt;&lt;/header&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;未完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(!value.checked){ return ( &lt;div key={index}&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;已完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(value.checked){ return ( &lt;div key={index} className=&apos;complete&apos;&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;/div&gt; ); }} export default Demo3; 12345678&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;# 远程请求数据Demo通过axios向服务端请求数据，我这里没有通过配置代理解决跨域问题，而是在后端配置了取消CROS请求来解决跨域问题 import React from ‘react’import axios from ‘axios’import request from ‘../model/server’import jsonp from ‘fetch-jsonp’ class Demo4 extends React.Component { constructor(props) { super(props); this.state = { list:[], }; } getData = ()=&gt;{ let api = ‘http://localhost:18080/house/resources/findAll&#39; axios.get(api) .then((response)=&gt;{ console.log(response) this.setState({ list:response.data }) }) .catch((error)=&gt;{ console.log(error) }) // let data =await request.get(api) // console.log(data) } render() { return ( &lt;div&gt; &lt;h2&gt;axios获取服务器数据,未处理跨域，取消cros&lt;/h2&gt; &lt;button onClick={this.getData}&gt;获取服务器数据&lt;/button&gt; &lt;p&gt;url:&lt;a href=&apos;http://localhost:18080/house/resources/findAll&apos;&gt;http://localhost:18080/house/resources/findAll&lt;/a&gt;&lt;/p&gt; &lt;ul&gt; { this.state.list.map((value,index)=&gt;{ return ( &lt;li key={index}&gt;{value.created}&lt;/li&gt; ) }) } &lt;/ul&gt; &lt;h2&gt;jsonp获取服务器数据,跨域请求&lt;/h2&gt; &lt;p&gt;怎么看，看你的地址加入callback=xxx之后是否能访问就知道是否支持jsonp了&lt;/p&gt; &lt;/div&gt; ); }} export default Demo4; 12345678910111213![1565942347213](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1565942347213.png)## 知识点：### 1. 跨域问题所谓跨域问题就是 协议，域名，端口三者有其一不一致则出现跨域，一般情况下跨域是不被浏览器支持的。### 2. axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。使用 npm install –save axios 1234# React-router 4.x基本配置及动态路由使用### 安装 cnpm install react-router-dom –save 12### 引入 import {BrowserRouter as Router,Route,Link} from ‘react-router-dom’ 12### 基本使用： 首页 新闻 12345678910111213141516![20190816155928](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155928.png!blog)![20190816155957](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155957.png!blog)### 动态路由的使用#### 定义路由 12#### 使用路由 { this.state.list1.map((value,key)=&gt;{ return ( //ES6模板字符串写法 &lt;Link to={/content/${value.aid}?content=${value.content}} key={key}&gt; {value.title} ) })} 12#### 在子组件中获得动态路由的传参 aid:this.props.match.params.aid, 123456789在prps.match.params中获取传参即可### 利用get实现动态路由无需定义路由格式，直接使用，在路由后面像get方法一样传参类似"?name=zhong"这种#### 使用路由 {value.title} 12345其中**?content=$&#123;value.content&#125;** 就是使用了get传参#### 在子组件中获得动态路由的传参 componentDidMount(){ //通过npm带的url模块解析get参数 cnpm install url --save 安装即可 console.log(url.parse(this.props.location.search,true)) let news = { aid:this.props.match.params.aid, //通过动态路由传值 content:url.parse(this.props.location.search,true).query.content, //通过get传值 } this.setState({ news:news }) }```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot下采用Dubbo进行服务治理]]></title>
    <url>%2F2019%2F07%2F19%2FSpringBoot%E4%B8%8B%E9%87%87%E7%94%A8Dubbo%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%2F</url>
    <content type="text"><![CDATA[Dubbo 是什么Apache Dubbo™ (incubating)是一款高性能Java RPC框架官网：http://dubbo.apache.org/zh-cn/index.html使用感受：Dubbo将传统的服务调用关系分为了消费者和提供者。符合现在前后端分离的这种模式。 Dubbo架构如图节点角色说明： 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 使用记录主要记录dubbo的工作流程，加深理解，如果需要详细的配置及代码请移步度娘 1、服务注册中心使用zookeeper作为服务注册中心，将其部署在docker上。Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 部署+启动12345678#启动dockerservice docker start#拉取镜像docker pull zookeeper:3.5#创建容器docker create --name zk -p 2181:2181 zookeeper:3.5#启动容器docker start zk 启动成功后，可查看容器运行情况 1docker ps 默认端口是2181。 2、SpringBoot下引入Dubbo进行服务治理最明显的感受就是dubbo是非侵入性的，原先的service可以不发生改变，由dubbo调用该service并暴露一个dubbo服务接口给controller，简单的代码就可以实现服务治理。 2.1dubbo配置在springboot的配置文件application.properties中 1234567891011121314151617#Dubbo配置# Service versiondubbo.service.version = 1.0.0# 服务的扫描包dubbo.scan.basePackages = zhong.dubbo.server.api# 应用名称dubbo.application.name = dubbo-provider-house-resources# 协议以及端口dubbo.protocol.name = dubbodubbo.protocol.port = 20881# zk注册中心dubbo.registry.address = zookeeper://192.168.146.128:2181dubbo.registry.client = zkclient 2.2dubbo使用2.2.1定义dubbo服务接口dubbo的服务要实现此接口，同时，该接口也是暴露给外层应用调用的，需要注意的是，要把接口和实现分开。 2.2.2实现dubbo服务接口新增一个api包，在这里使用dubbo并暴露出dubbo服务的接口给表现层（我随便说的，感觉像类似） 1234567891011121314151617/** * 这个是dubbo服务，不要和spring的服务搞混了 */@Service(version = "1.0.0")public class HouseResourcesService implements ApiHouseResourcesService &#123; /** * 注入的是spring的服务 */ @Autowired private zhong.dubbo.server.service.HouseResourcesService houseResourcesService; @Override public int saveHouseResources(HouseResources houseResources) &#123; return this.houseResourcesService.saveHouseResources(houseResources); &#125;&#125; 2.3查看dubbo服务利用dubbo-admin即可查看注册的服务如果没配置过dubbo-admin，可以看这篇https://blog.csdn.net/weixin_41154636/article/details/96478016 2.3调用dubbo在Controller中，因为在上一步中已经完成dubbo服务接口的定义及实现，并且把dubbo 服务的接口注入到spring容器中了。所以只需要在controller中调用duddo服务即可。使用起来非常简单呢。 1234567891011121314151617181920212223242526272829303132@RequestMapping("house/resources")@Controllerpublic class HouseResourcesController &#123; @Autowired private HouseResourcesService houseResourcesService; /** * * @param houseResources 接收json数据 * @return */ @PostMapping @ResponseBody public ResponseEntity&lt;Void&gt; save(@RequestBody HouseResources houseResources)&#123; try &#123; boolean success = this.houseResourcesService.save(houseResources); if(success)&#123; return ResponseEntity.status(HttpStatus.CREATED).build(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); &#125; @GetMapping @ResponseBody public ResponseEntity&lt;String&gt; get()&#123; return ResponseEntity.ok("ok"); &#125;&#125; 可以从dubbo-admin中看到消费者列表这个时候这里的消费者就是指某个controller，这里只是完成了服务的订阅，当某个请求过来的时候，才是真正的服务调用，dubbo会根据负载均衡的不同策略对已注册的服务选择调用。 Dubbo的工作流程总结 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo-Admin的配置以及遇到的坑]]></title>
    <url>%2F2019%2F07%2F19%2FDubbo-Admin%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Dubbo-Admin下载配置环境： linux centos7在github上clone到本地即可 1git clone https://github.com/apache/dubbo-admin.git 前端配置dubbo采用前后端分离部署，所以他的部署相对有点麻烦，如果按照官方的文档，像个铁憨憨一样c+v，则会出现npm install fail 等错误。因为前端工程是用vue开发的，所以得先配个node.js即可，node.js中自带了npm。首先进入前端工程目录下 1cd dubbo-admin/dubbo-admin-ui 修改前端工程端口及配置信息如果需要修改前端工程端口或其他配置信息，进入到 1vim config/index.js 配置文件下修改即可需要注意的是，如果修改了后端的端口，记得修改ProxyTable的配置 构建dubbo-admin前端工程运行 1npm install 启动dubbo-admin前端工程在当前目录下，运行 1npm run dev 运行前端项目，然后就应该可以访问页面了。 配置后端项目进入后端工程，后端是用springboot和Maven构建的。所以如果你没配置maven的话，可以在先配个maven在linux中配置maven非常简单，具体操作咨询度娘。 修改后端配置修改注册中心端口1vim dubbo-admin-server/src/main/resources/application.properties 在这里主要配置注册中心的端口因为我的zookeeper（服务注册中心）是部署在本机的，所以用本机地址即可。 修改dubbo-admin后台服务端口默认端口为8080，如果需要更改，加入配置 1server.port=&lt;端口号&gt; 构建进入到dubbo-admin-server目录下，进行构建，如果直接在项目根目录构建会出错。 1cd dubbo-admin-server 运行 1mvn clean package 将项目打包，正常情况下的能构建成功的，如果是npm fail失败的原因，请仔细检查前端工程的配置或是否将前端工程build和install 启动运行 1mvn --projects dubbo-admin-server spring-boot:run 然后你再次访问前端页面，就可以监视到通过dubbo注册在zookeeper的服务了。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加法器的实现及优化]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、半加器半加器有一个异或门和与门组成，异或门赋值记录数值，与门记录是否产生了进位。但是半加器是无法完成加法运算的。 需要完成加法运算，需要用到全加器 2、全加器 全加器由两个半加器组成，绿色的为一个半加器，橙色的为另一个半加器。三个输入，两个输出。 两个输出表示了他能表示的范围为0,1,2,3 对应的二进制则为表上的Cout 与 S 例如进行1+1的运算时 先来看看S的输出： A端输入1，B端输入1，C端输入0（最低位加法运算默认为0），1（A）异或1（B） 结果为0（记为D）0（D）+0（Cin）结果是0，所以绿色的异或门输出（S）为0，说明该位的运算结果为0。 再来看看Cout（进位）的输出： 1（A）与1（B） 结果为1，说明产生了进位，橙色的与门输出1。由S的输出过程可得绿色的与门的输入为0,0，绿色的与门输出为0，这个时候需要一个或门即可判断两次加法（A+B和B+Cin）是否产生了进位，只要其中一个产生的进位，Cout置1。 运算结果： 将Cout与S连起来，就是10，也就是2。 减法的实现：减法实际上就是加法 A-B 可以表示为 A+ （-B） 这个-B可以用补码来表示。 如上图所示，sub-mode负责加减法的选择，同时他连接到最低位的Cin端。 如果为加法，则sub-mode为0，那么直接进行加法运算 如果为减法，则sub-mode为1，最低位数字Cin（C0端）被置为1，同时控制电路对B的每一位是输入数字作取反处理，这样就完成的（-B）补码的“按位取反，末位加一”的操作。然后按加法运算即可 3、行波进位加法器行波进位加法器就是由n个全加器构成的，可以运算n位的加法。 例如计算：1101+0110。将每个低位的Cout（进位输出）作为对应高位的Cin（进位输入）。 这里Cout最高位为1，而假设我们当前的寄存器的位数为4位，则产生了溢出。 溢出和进位的区别：溢出：表示数据超过了正常的表示范围，如果采用浮点表示还分成上溢出和下溢出。 进位：N进制进位这个就是逢N进一 需要注意，溢出和进位并没有直接关系。溢出的发生只在有符号位时发生，也就是说你的机器数是带符号的就有可能产生溢出。 判断溢出的方法：1、最高位数值和符号位都发生了进位或者都不产生进位，则没有溢出。最高位数值和符号位有一个产生进位，另一个没有进位，则为溢出。计算机实现用异或电路 例如 1,111+0,100 -&gt;10011(舍去最高位) ，最终结果为 0,011 未发生进位 2、如果采用两位符号位表示，原理和方法1一样，采用了两位符号位来记录原来的1位符号位和最高数值位的进位情况，这样就不需要用异或电路。符号位为00或11则未溢出，如果为01为正溢出（此时真正的符号位正），10为负溢出（此时真正的符号为负） 行波进位加法器的运算过程：在进行加法运算时，首先准备好的是（从右往左为1,2,3,4号）1号全加器的3个input。而2、3、4号全加器的Cin全部来自前一个全加器的Cout，只有等到1号全加器运算完毕，2、3、4号全加器才能依次进行进位运算，最终得到结果。 这样进位输出，像波浪一样，依次从低位到高位传递， 最终产生结果的加法器，也因此得名为行波进位加法器（Ripple-Carry Adder，RCA）。 RCA的优点是电路布局简单，设计方便， 我们只要设计好了全加器，连接起来就构成了多位的加法器。 但是缺点也很明显，也就是高位的运算必须等待低位的运算完成， 这样造成了整个加法器的延迟时间很长。那么，RCA的效率到底如何呢？让我们来算一算： 将4bit的RCA内部结构全部打开，就得到了如图2所示的4-bit RCA的门电路图。要对一个电路的性能进行分析，我们就要找出其中的最长路径。 也就是找出所有的从输入到输出的电路连接中，经过的门数最多的那一条，也称为关键路径（如下图所示）。 判断延迟的两个指标：（1）门延迟经过每个门所花费的实际，称为门延迟 （2）线延迟输入信号进入到这块电路之后，在连接线上传递需要花时间。 称为线延迟 行波进位加法器的延迟分析：以只考虑门延迟为例 从第一个全加器的A-S这条通路来看，产生第一个S输出，需要通过两个门的延迟。 所以它显然不是最长的路径，当然，从A出发或着从B出发都是一样的， 所以对于第一个全加器，它的最长路径，是红色线标记的那条，后面的全加器关键路径同理可得。 那么，假设经过一个门电路的延迟时间为T，那么经过4个全加器所需要的总延迟时间就是：2T x 4 + T(第一个全加器产生3个T) = 9T。所以推出，经过n个全加器所产生的总延迟时间为2T x n + T = (2n+1)T。 对于一个32bit的RCA，有总延迟时间：(2n+1)T =(2×32+1)×T =65T，这是什么概念呢？举个例子，iPhone 5s的A7 SoC处理器采用28nm制造工艺，主频1.3GHz（0.66ns CPU时钟周期中每两个上沿所隔的时间）。按照这个工艺水平，门延迟T设为0.02ns，那么32-bit RCA的延迟时间为1.3ns ，时钟频率为769MHz，远超A7处理器的主频延迟时间，更别说这个32bit的RCA只是一个加法运算器，更更别说，我们在计算过程中只考虑了门延迟，还有线延迟等各种延迟没有加入计算…… 4、超前进位加法器从上面可以看到，影响行波进位加法器（RCA）运算效率的主要因素是高位的运算必须等待低位的“进位输出信号”，那我们的优化思路就是‘能否提前计算出“进位输出信号’ ？” 答案是有的，如图所示。 全加器有三个输入，当其中的两个为1时，必定产生进位。这样就有了如下的公式： Ai Bi Ci 分别是全加器的三个输入，Ci+1为进位输出 Ci为进位输入。 如果是最低位，则Ci=C0，C0根据加法或是减法置为0或者1。 简化公式得： 如果表示4个全加器的进位输入输出： 可以得到由每个低位全加器的进位输出得到每个高位全加器的进位输入。 最终我们需要得到的是C4，经过换算，C4=G3+P3·G2+P3·P2·G1+P3·P2·P1·G0+P3·P2·P1·P0·C0，而这些参数，全部已知！并不需要前一个全加器运算输出，由此我们得到了提前计算进位输出的方法， 用这样的方法实现了加法器就被称为超前进位加法器（Carry-Lookahead Adder，CLA）。 这样就实现了提前获得进位输入的能力，这样就大大提高了加法运算的效率。但有得必有失，这样的代价是电路比较复杂。 超前进位加法器的实现 C4的结果由或门实现，把每个多项式进行求和，乘用与门实现。 延迟分析 使用CLA来进行加法运算的效率如何呢？还是按照Apple A7处理器的工艺水平，单个CLA的延迟为0.08ns，4级CLA的延迟为0.26ns，时钟频率3.84GHz，都远远小于主频的延迟，完全符合标准。然而，由图可见，计算4bit的二进制数，就要平行排列4个全加器，那么要是计算8bit，16bit，32bit……的呢？可能就需要更复杂的布线方式，这就是CLA的缺点。 比较一下RCA和CLA的优缺点： 行波进位加法器（RCA） 超前进位加法器（LCA） 结构特点 低位全加器的Cout连接到高一位全加器Cin 每个全加器的进位输入并不来自于前一级的全加器，而是来自超前进位的逻辑电路 优点 电路布局简单，设计方便 计算Ci+1的延迟时间固定为三级门延迟，与加法器的位数无关 缺点 高位的运算必须等待低位的运算完成，延迟时间长 如果进一步拓宽加法器的位数，则电路变得非常复杂 32位的加法器如果采用行波进位的方式，我们已经分析过需要65级的门延迟， 那如果采用超前进位的方式，理想情况下也只需要四级的门延迟，但可惜的是， 这也只是一个理想。因为要实现32位的完全的超前进位，电路就会变得非常的复杂。 因此通常的实现方法， 是采用多个小规模的超前进位加法器拼接而成一个较大的加法器，例如，用4个8-bit的超前进位加法器连接成32-bit加法器。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
</search>
