<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于Python的图算法实现]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言本来是想用C语言好好写的，可是指针和结构体太烦人了，弄得我头凉。因此决定用python实现一下图的一些算法。图的存储结构实现图的实现有邻接矩阵，邻接表，十字链表等。我后面的算法主要用邻接表建议直接看[邻接表实现2，基于字典实现](# 邻接表实现2 (基于字典实现，好用))首先定义了一个异常类：12class GraphError(Exception): pass 邻接矩阵实现（不重要也不好用）基于邻接矩阵定义了一个实现图的类，其中矩阵元素可以是1或者其他权值，表示有边，或者用一个特殊值表示“无关联”。构造参数的unconn就是表示无关联的值，默认为0。 图的构造函数的主要参数是mat,表示初始的邻接矩阵。要求是一个二维数组，且为方阵。代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# unconn 无关联参数# 邻接矩阵实现class Graph: def __init__(self, mat, unconn=0): vnum = len(mat) # 检查是否为方阵 for x in mat: if len(x) != vnum: raise ValueError("参数错误：不为方阵") # 拷贝数据 self._mat = [mat[i][:] for i in range(vnum)] self._unconn = unconn self._vnum = vnum # 返回顶点数目 def vertex_num(self): return self._vnum # 检查该顶点是否合法，也就是下标是否找得到 def _invalid(self, v): return v &lt; 0 or v &gt;= self._vnum # 加入新的顶点 def add_vertex(self): raise GraphError("邻接矩阵不支持加入顶点") # 加入新的边 def add_edge(self, vi, vj, val=1): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") self._mat[vi][vj] = val # 获得某条边 def get_edge(self, vi, vj): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") return self._mat[vi][vj] # 获得某个顶点的出边 def out_edges(self, vi): if self._invalid(vi): raise GraphError("顶点不合法") return self.out_edge(self._mat[vi], self._unconn) # 获得某个顶点的出边 @staticmethod def _out_edges(row, unconn): edges = [] for i in range(len(row)): if row[i] != unconn: edges.append((i, row[i])) return edges def __str__(self): return "[\n" + ",\n".join(map(str, self._mat)) + "\n]" \ + "\nUnconnected: " + str(self._unconn) 这个简单的邻接矩阵实现的图类并未支持增加顶点，因为邻接矩阵增加顶点要增加多一行一列，挺麻烦的，就不想写了。 邻接表实现1（基于邻接矩阵，不好用）邻接矩阵的缺点是占用空间很多，如果是稀疏图就很难受了，可能会有很大的空间损失，因此常用邻接表实现图的存储。在上面邻接矩阵的实现下，可考虑一种“压缩后”的邻接表实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 邻接表实现（压缩邻接矩阵形式）class GraphAL(Graph): def __init__(self, mat=[], unconn=0): vnum = len(mat) for x in mat: if len(x) != vnum: raise ValueError("参数错误：不为方阵") self._mat = [Graph._out_edges(mat[i], unconn) for i in range(vnum)] self._vnum = vnum self._unconn = unconn def add_vertex(self): self._mat.append([]) self._vnum += 1 return self._vnum - 1 def add_edge(self, vi, vj, val=1): if self._vnum == 0: raise GraphError("无法为空图增加边") if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") row = self._mat[vi] i = 0 while i &lt; len(row): if row[i][0] == vj: self._mat[vi][i] = (vj, val) return if row[i][0] &gt; vj: # 没有到与vj的边，退出循环加入边 break i += 1 self._mat[vi].insert(i, (vj, val)) def get_edge(self, vi, vj): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") for i, val in self._mat[vi]: if i == vj: return val return self._unconn def out_edges(self, vi): if self._invalid(vi): raise GraphError("顶点不合法") return self._mat[vi] 邻接表实现2 (基于字典实现，好用) 数据格式如图所示： 12345678graph = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 如上图所示，该类是一个无向网，如果需要改成有向网，只需要更改add_edge这个方法 新建一个GraphAL.py文件，在文件中添加： 12345678910111213141516171819202122232425262728293031323334# 邻接表实现无向网（图）（字典形式）class GraphAL: def __init__(self, graph=&#123;&#125;): self._graph = graph self._vnum = len(graph) def _invalid(self, vertex): return self._graph.__contains__(vertex) def add_vertex(self, vertex): if self._invalid(vertex): raise GraphError("添加顶点失败，已经有该顶点") self._graph[vertex] = &#123;&#125; self._vnum += 1 def add_edge(self, vi, vj, val): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") self._graph[vi].update(&#123;vj: val&#125;) self._graph[vj].update(&#123;vi: val&#125;) def get_edge(self, vi, vj): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") return self._graph[vi][vj] def get_vertexNum(self): return self._graph.__len__() # 在无向网（图）中是边，有向网（图）是出边，取决于数据 def out_edge(self, vertex): if not self._invalid(vertex): raise GraphError("不存在" + vertex + "这样的顶点") return self._graph[vertex] 你也可以不传入图的参数，会默认创建一个新图。通过add_vertex和add_edge即可完成图的构建。 图的一些算法实现图的遍历BFS（广度优先搜索）算法原理及步骤按照广度优先原则遍历图，利用了队列，有点像树的层次遍历。广度优先遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入队 顶点出队，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入队 当队列不为空的时候，循环1,2步 算法流程graph LR start(起始点入队) deque[出队] isVisit{未被访问?} visit(访问该结点并输出) isnull[检查队空] end1((结束)) start-->deque deque-->isVisit isVisit--未被访问-->visit isVisit--已经被访问-->deque isnull-->end1 visit-->isnull isnull--不为空-->deque 算法实现123456789101112131415161718# 广度优先遍历def bfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") queue = [start] # 队列实现BFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while queue.__len__() &gt; 0: # 队非空时 vertex = queue.pop(0) # 队首顶点出队 nodes = self._graph[vertex] # 获得其邻接顶点 for node in nodes: if node not in seen: queue.append(node) # 其邻接顶点如果没有被访问，则入队，并且保留父顶点 seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 具体的存储结构为： 12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 1234567def test_bfs(self): print("bfs测试：") bfs, bfsparent = TestGraph.g.bfs("A") print("BFS:" + graph.GraphAL.printPath(bfs)) print("BFS生成路径:" + bfsparent.__str__()) print("BFS生成路径打印：" + graph.GraphAL.printTreePath(bfsparent).__str__()) pass DFS（深度优先搜索）算法原理及步骤DFS和BFS很像，不过DFS是深度优先的原则，具体实现是栈。 DFS遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入栈 顶点出栈，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入栈 当栈不为空的时候，循环1,2步 算法流程graph LR start(起始点入栈) deque[出栈] isVisit{未被访问?} visit(访问该结点并输出) isnull[检查栈空] end1((结束)) start-->deque deque-->isVisit isVisit--未被访问-->visit isVisit--已经被访问-->deque isnull-->end1 visit-->isnull isnull--不为空-->deque 算法实现123456789101112131415161718# 深度优先遍历def dfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") stack = [start] # 栈实现DFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while stack.__len__() &gt; 0: # 栈非空时 vertex = stack.pop() # 顶点出栈 nodes = self._graph[vertex] # 获取出栈顶点的邻接顶点 for node in nodes: if node not in seen: stack.append(node) seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 存储结构12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 测试结果1234567891011121314151617图的结构为：('A', &#123;'B': 5, 'C': 1&#125;)('B', &#123;'A': 5, 'C': 2, 'D': 1&#125;)('C', &#123;'A': 1, 'B': 2, 'D': 4, 'E': 8&#125;)('D', &#123;'B': 1, 'C': 4, 'E': 3, 'F': 6&#125;)('E', &#123;'C': 8, 'D': 3&#125;)('F', &#123;'D': 6&#125;)dfs测试：DFS:A-&gt;C-&gt;E-&gt;D-&gt;F-&gt;BDFS生成路径:&#123;'A': None, 'B': 'A', 'C': 'A', 'D': 'C', 'E': 'C', 'F': 'D'&#125;DFS生成路径打印：A-&gt;BA-&gt;CA-&gt;C-&gt;DA-&gt;C-&gt;EA-&gt;C-&gt;D-&gt;F 最小生成树最小生成树针对的是连通网而言的。假定一个网络G，他的边带有权值，自然可以通过BFS,DFS获得他的生成树，权值最小的那棵树，就称最小生成树 最小生成树有许多实际的应用，例如通信网，输电网及各种网的规划。 Prim算法算法原理及算法流程假设现在有这样一颗图 graph RL V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V1--6---V2 V1--1---V3 V1--5---V4 V2--5---V3 V3--5---V4 V3--6---V5 V3--4---V6 要对该图进行prim算法进行最小生成树。首先找一个开始顶点，假设从V1开始 V1的邻接节点全部入队。并且由于该队列是优先级队列，会按照权重排序 graph LR V13((v1,v3,1)) V14((v1,v4,5)) V12((v1,v2,6)) V13-->V14 V14-->V12 流程算法实现测试克鲁斯卡尔算法算法原理在一个连通图中不断选取权值最小的边，然后连起来，就是这样。 算法实现测试最短路径dijkstra算法算法原理算法实现测试弗洛依德算法算法原理算法实现测试拓扑排序算法原理算法实现测试关键路径算法原理算法实现测试st=>start: 初始化队列，初始顶点入队 e=>end: 结束BFS deque=>operation: 出队 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否队空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 初始化栈，初始顶点进栈 e=>end: 结束DFS deque=>operation: 出栈 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否栈空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用操作及使用技巧]]></title>
    <url>%2F2019%2F08%2F19%2FVim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[早期版本：viVim常用操作Vim是一个功能强大的全屏幕的文本编辑器，是Linux/UNIX上最常用的文本编辑器，他的作用是建立、编辑、显示文本文件。VIm 没有菜单，只有命令vim常用命令编辑模式常用命令 a 在光标所在字符后插入 A在光标所在行尾插入 i在光标所在字符前插入 I在光标所在行行首前插入 o在光标下插入新行 O在光标上插入新行 命令模式常用命令按:进入命令模式，如果当前是编辑模式，记得按下ECS。 设置与保存命令 :wq 保存退出 :wq!强制保存退出（文件所有者及root可用） :w new_filename 另存为指定文件 ZZ 快捷键，保存修改并退出 :q! 不保存修改直接退出 q 退出 set nu 设置行号 set nonu 取消行号 移动命令 gg 到第一行 G到最后一行 nG 到第n行 :n 到第n行 $ 移至行尾 0 移至行首 删除命令 x 删除光标所在处的字符 nx删除光标所在处后n个字符 dd 删除光标所在行 dG删除光标所在行到文件末尾的内容 D删除光标所在处到行尾的内容 :n1,n2d 删除指定范围的行 复制和剪切命令复制是yy和p和组合键 剪切是dd和p的组合键 yy复制当前行 nyy 复制当前行一下的n行 dd 剪切当前行 ndd 剪切当前行一下的n行 p或P 粘贴在当前光标所在行下或行上 替换和撤销命令 r 取代光标所在处的字符 R 从光标所在处开始替换字符,按Esc结束 u 撤销上一步操作 检索命令 /string 检索指定字符串，检索时忽略大小写 :set ic 检索时不忽略大小写 ：set noic n 搜索指定字符串的下一个出现位置 :%s/old/new/g 全文替换指定字符串 ,如果后面是c就会替换时询问你 :n1,n2s/old/new/g 在一定范围内替换指定字符串 #### 一些使用技巧导入命令执行结果如果需要把一个vim文件的内容导入到当前编辑内容中 使用r! 文件名即可 该命令会把某个vim文件的当前光标所在行内容导入当前编辑内容中 :which 命令 查找某个命令的位置 定义快捷键:map 快捷键触发命令 例如： map ^P I#&lt;ESC&gt; 如果要实现一个快速注释某一行的命令，需要四部 进入编辑模式 使用I移至行首 输入# 按ESC回到命令模式 如果用快捷键，可以快速完成这个操作 :map ^p I#&lt;ESC&gt; ^P 可以用ctrl+V+P弄出来，表示要当按下ctrl+p的时候触发。 如果需要去掉注释可以用一下方式定义快捷键 :map ^B 0x 然后就可以去掉注释了。 如果需要添加个人邮箱 :map ^H i610596547@qq.com&lt;ESC&gt; 连续行注释 :n1,n2s/^/#g n1,n2s表示指定范围行 /^/#g在行首替换字符（也就是增加） 如果需要把连续行的注释去掉，也是用替换 :n1,n2s^#//g 其实就是正则表达式的简单应用。 如果要用//连续注释 可以用 :n1,n2s/^/\/\//g其中\/\/是//的转义 替代命令:ab 替代文本 被替代文本 例如： :ab mail 610596547 保存快捷键在root用户在/root/.vimrc下可写入快捷键 如果是别的用户则在/home/username/.vimrc下写入 centos7 会自动帮你写入，而且文件名变为了.viminfo]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令-关机重启命令]]></title>
    <url>%2F2019%2F08%2F19%2FLinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[shutdown描述：关机，重启这个命令比较“安全”选项： -h 关机 -r 重启 -c 取消前一个关机命令 例如：1234shutdown -h now #现在关机shutdown -h 20:30 #晚上八点半关机shutdown -r now #现在重启shutdown -c #取消前一个关机命令 其他重启，关机命令 halt poweroff init 0 系统运行级别 0 关机 1 单用户 (只启动最核心程序，只有root用户，类似于windows的安全模式) 2 不完全多用户，不含NFS服务（NFS[网络文件系统]，不太安全） 3 完全多用户 4 未分配 5 图形界面 6 重启 1init 6 #重启 如果觉得难记，可以查看 cat /etc/inittab centos 7下只有3,5可以选 12# multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5 查询当前的运行级别 1runlevel 例如： 12[zhong@localhost ~]$ runlevelN 5 N代表开机之后直接进入了5级别。 接下来，进入3级别，即无图形界面级别 1init 3 1234567==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===Authentication is required to manage system services or units.Authenticating as: rootPassword: ==== AUTHENTICATION COMPLETE ===[zhong@localhost ~]$ runlevel 5 3 当前就显示，系统由5进入到3级别。 查看虚拟机。 发现系统果然进入了命令行界面。 现在在切换回图形界面：使用命令 1init 5 123456[zhong@localhost ~]$ init 5==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===Authentication is required to manage system services or units.Authenticating as: rootPassword: ==== AUTHENTICATION COMPLETE === 查看当前运行级别 12[zhong@localhost ~]$ runlevel3 5 再看看虚拟机： 成功切换回了图形界面。 退出登录命令log out 维护服务器离开之后一定要记得退出登录。不然可能造成不良后果。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS上安装配置Python3.7]]></title>
    <url>%2F2019%2F08%2F19%2FCentOS%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEPython3-7%2F</url>
    <content type="text"><![CDATA[安装依赖包1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make1yum install libffi-devel -y下载python3.7的包 方法一：直接在官方网站下载打开python的官方网站：https://www.python.org/ –&gt;Downloads–&gt;Source code–&gt;Latest Python 3 Release - Python 3.7.0–&gt;拉到最下面，选择Gzipped source tarball，下载到本地，然后上传到服务器即可 方法二：通过wget1wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz 然后执行： 1234tar -zxvf Python-3.7.0.tgz #解压解包cd Python-3.7.0./configure #运行配置make&amp;&amp;make install #编译并安装 安装的目录通常在：/usr/bin/下 配置这里为了使默认python变成python3，需要加一条软链接,并把之前的python命令改成python.bak，而且pip也是要进行链接的： 1234mv /usr/bin/python /usr/bin/python.bakln -s /usr/local/bin/python3 /usr/bin/pythonmv /usr/bin/pip /usr/bin/pip.bakln -s /usr/local/bin/pip3 /usr/bin/pip 接下来需要配置yum的引用，因为yum引用的是之前系统默认的python2.7，现在变成了3.7，需要把他改回来。需要改动两个地方 1vi /usr/libexec/urlgrabber-ext-down 1vi /usr/bin/yum 测试输入 1python -V 1pip -V 如果出现3.7版本，就说明成功了。 使用新建一个py文件 1vim helloWorld.py 修改内容如下： 12#! /usr/bin/python print("hello,world") 第一句一定要加的，除非你配个虚拟环境virtualenv 增加执行权限： 1chmod +x helloWorld.py 运行： 1./helloWorld.py 如果控制台输出为： 1hello,world 即测试成功了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令-网络命令]]></title>
    <url>%2F2019%2F08%2F18%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[write命令功能：给用户发信息，以Ctrl+C结束，通信双方要求已登录。用法：wirte &lt;用户名&gt;执行权限：所有用户实例：在zhong这个用户下给root用户发信息在root用户中就可以看见了wall命令英文缩写：wirte all功能：发广播信息，所有登录用户都能收到执行权限：所有用户 用法：wall [message] 示例： 12345[root@localhost ~]# wall Hello Broadcast message from root@localhost.localdomain (pts/2) (Sun Aug 18 21:29:41 2019):Hello 1234[zhong@localhost ~]$ Broadcast message from root@localhost.localdomain (pts/2) (Sun Aug 18 21:29:41 2019):Hello 可以看到，发送者自己也能收到这个信息。 ping命令功能：测试网络连通性 用法：ping [-c] [ip] 选项：-c指定发送次数 示例： 12345678910[zhong@localhost ~]$ ping www.baidu.com -c 4PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=128 time=26.6 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=128 time=32.5 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=128 time=37.5 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=128 time=32.4 ms--- www.a.shifen.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 26.609/32.293/37.540/3.875 ms 重点看丢包率packet loss，丢包率高则说明网络状况不佳。 ifconfig英文原意：interface configure 描述：查看和设置网卡信息 执行权限：root 语法：ifconfig 网卡名称 ip 查看网卡信息1234567891011121314151617181920212223242526[zhong@localhost ~]$ ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.146.128 netmask 255.255.255.0 broadcast 192.168.146.255 inet6 fe80::487d:9db5:efb1:19b8 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:b5:b4:4c txqueuelen 1000 (Ethernet) RX packets 7377 bytes 504286 (492.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8791 bytes 14466799 (13.7 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 272 bytes 29576 (28.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 272 bytes 29576 (28.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:29:75:7b txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33是本机网卡，inet addr：当前网络ip地址 last功能：列出目前与过去登入系统的用户信息 如果想知道用户的最后登录用户可以用lastlog traceroute描述：显示数据包到主机间的路径 用法：traceroute 服务器地址 12345678910111213141516171819[root@ecs-s2-medium-2-linux-20190722215607 ~]# traceroute www.baidu.comtraceroute to www.baidu.com (180.101.49.12), 30 hops max, 60 byte packets 1 * * * 2 * * * 3 100.80.0.1 (100.80.0.1) 7.387 ms * 7.234 ms 4 * 10.241.6.21 (10.241.6.21) 8.529 ms 8.700 ms 5 10.241.8.141 (10.241.8.141) 10.065 ms * 9.837 ms 6 * 10.230.2.146 (10.230.2.146) 1.128 ms 1.128 ms 7 10.230.2.108 (10.230.2.108) 9.665 ms 9.843 ms 9.932 ms 8 10.230.2.42 (10.230.2.42) 2.296 ms 3.847 ms 3.644 ms 9 * 10.1.128.65 (10.1.128.65) 2.442 ms 2.725 ms10 10.1.128.82 (10.1.128.82) 2.841 ms * 10.1.128.74 (10.1.128.74) 2.760 ms11 * * *12 183.60.190.97 (183.60.190.97) 7.199 ms 183.60.190.101 (183.60.190.101) 8.062 ms 8.015 ms13 113.96.4.65 (113.96.4.65) 4.938 ms * 4.298 ms14 * 202.97.54.238 (202.97.54.238) 26.562 ms *15 58.213.94.118 (58.213.94.118) 32.441 ms 32.433 ms *16 58.213.94.90 (58.213.94.90) 29.217 ms * *17 58.213.96.118 (58.213.96.118) 32.847 ms 58.213.96.94 (58.213.96.94) 32.748 ms 58.213.96.62 (58.213.96.62) 28.098 该命令会返回每个节点的延时，可以用此查看是哪个网络节点出现了问题。 netstat命令描述：显示网络相关信息 权限：所有用户 选项： -t TCP协议 -u UDP协议 -l 监听 -r 路由 -m 显示ip地址和端口号 例如： # netstat -tlun 查看本机监听的端口 # netstat -an 查看本机所有的网络连接 # netstat -rn 查看本机路由表 例如： 123456[root@localhost ~]# netstat -tunActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 192.168.146.128:22 192.168.146.1:53249 ESTABLISHEDtcp 0 36 192.168.146.128:22 192.168.146.1:54298 ESTABLISHEDtcp 0 0 192.168.146.128:22 192.168.146.1:54280 ESTABLISHED 通常这个命令用来与查看某个端口是否被占用，然后关闭 12netstat -anp |grep 端口号kill -9 进程pid setup描述：配置网络 执行权限：root 这个命令是红帽自带的配置命令。可以进入系统配置界面]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令-压缩解压命令]]></title>
    <url>%2F2019%2F08%2F17%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[打包命令在总结解压前，需要先了解打包命令，Linux的有些压缩格式是无法直接压缩目录的，需要用到tar命令进行打包成文件。 使用方法：tar -cf[v] 打包后的文件名 需要打包的目录名 选项: -c打包 -f指定文件名 -v输出详细信息 -x解包 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cf testDir.tar testDir[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar 几种压缩格式及命令.gz格式这种格式在Linux中用的最多，也最常见 压缩文件命令.gz文件可以用gzip 命令进行压缩 注意点 gz命令只能压缩文件，该命令无法压缩目录。 gz压缩完成后不保存源文件 压缩目录压缩目录有两种方法，因为gz命令是无法直接压缩目录的，所以要先对目录进行打包，打包成tar文件 方法一：先打包，在压缩 先使用tar -cf 打包后的文件名 需要打包的文件名先把目录打成tar包 再用gzip将tar包压缩。 方法二：利用tar打包并压缩如果需要压缩目录，则需要用到tar命令，该命令将目录打包成文件同时进行压缩，压缩后的格式为tar.gz 再复习下常用选项 -c打包 -v显示详细信息 -f指定文件名 -z打包同时压缩成.gz压缩包 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cvf testDir.tar testDir/ #打包某个目录testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar 然后可用gz命令对该目录打包后的文件进行压缩 123[root@ecs-s2-medium-2-linux-20190722215607 home]# gzip testDir.tar [root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz 如果觉得先打包再压缩有点麻烦，可以加入-z参数，在打包的同时进行压缩 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -zcf testDir.tar.gz testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz[root@ecs-s2-medium-2-linux-20190722215607 home]# 解压缩文件使用gunzip或者gzip -d命令可以进行解压缩 解压目录因为压缩目录有两种方法，同样解压也有两种方法： 方法一：先解压，在进行解包 先用gunzip 压缩文件名进行解压 再用tar -xf t包名进行解包 方法二：利用tar解包并解压常见选项如下： -x解包 （与-c对应） -v显示详细信息 -f指定压缩文件 -z解压缩 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -xzvf testDir.tar.gz testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz 使用tar命令的注意点-f选项后面一定要加文件名，也就是如果你要把选项写在一起，请把-f放在最后面，像这样-xzvf或者-czvf .bz2格式该格式是.gz的升级版，他的好处是压缩比非常惊人，常用来压缩大文件。 压缩文件使用bzip2进行压缩 用法：bzip 选项[-k] [文件] 选项：-k产生压缩文件后保留原文件 压缩后的格式：.bz2 压缩目录方法一：先打包，在压缩 先使用tar -cf 打包后的文件名 需要打包的文件名先把目录打成tar包 再用bzip将tar包压缩。 方法二：利用tar打包并压缩如果你想在用tar命令打包的同时进行压缩，并且压缩后的格式为.bz2，那么需要加入选项-j （注意与tar压缩成.gz格式的-z选项进行区分） 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cjf testDir.tar.bz2 testDir[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.bz2 解压缩文件使用命令bunzip2就可以对.bz2文件进行解压缩 使用方法：bunzip2 选项[-k] [压缩文件名] 选项：-k解压缩后保留原文件 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# bunzip2 testDir.tar.bz2 [root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir[root@ecs-s2-medium-2-linux-20190722215607 home]# 解压缩目录方法一：先解压，再解包你可以先用gunzip进行解压文件，解压出来是个tar包，然后用用tar -xf进行解包即可 方法二：利用tar解包并解压tar -xjf进行解包并进行解压缩 注意区分：解压.gz格式的tar包时用的是-z，解压.bz2格式tar包时用的是-j .gz 与 .bz2用法比较 命令\格式 .gz .bz2 压缩文件 gzip bzip2 压缩目录 方法一：先用tar -cf进行打包，在用gzip进行压缩；方法二：直接用tar -czf进行压缩 方法一：先用tar -cf进行打包，在用bzip2进行压缩；方法二：直接用tar -cjf进行压缩 解压缩文件 gunzip bunzip2 解压缩目录 方法一：先用gunzip进行解压，解压得到的文件是.tar包，在用 tar -xf进行解包；方法二：直接用tar -xzf进行解包并解压缩 方法一：先用bunzip2进行解压，再用tar -xf进行解包；方法二：直接用tar -xjf进行解包并解压缩。 再次强调注意点： 如果你使用tar -czf或tar -cjf进行压缩目录，f后面要跟两个东西，一个是压缩后的文件名，一个是需要压缩的目录。类似这样tar -cjf testDir.tar.gz testDir 如果你使用tar -xzf或tar -xjf进行解压缩目录，f之后只用跟需要解压的文件即可。类似这样tar -xjf testDir.tar.bz2 .zip格式.zip是windows和linux都支持的压缩格式 压缩后的格式为.zip zip压缩命令使用格式：zip 选项[-r] [压缩后的文件名] [文件或目录] 选项：-r 压缩目录 与gz命令不同的是：可压缩目录，保留源文件 例如： 12[root@ecs-s2-medium-2-linux-20190722215607 home]# zip -r testDir.zip testDir adding: testDir/ (stored 0%) 该命令还会很人性化的提醒你压缩比。因为我这个是空目录，所以是0。 zip解压缩命令使用unzip就可以解压缩.zip的压缩文件 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# unzip testDir.zip Archive: testDir.zip creating: testDir/]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令-用户管理命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[useradd功能描述：添加新用户 执行权限：root 命令所在路径：/usr/sbin/useradd 1useradd xxx #用户名 passwd如果需要给用户密码好让该用户访问系统，则需要用到该命令 功能描述：设置用户密码 执行权限：所有用户 命令所在路径：/usr/bin/passwd 1passwd xxx #用户名 如果不加参数，则更改当前用户的密码 1passwd who功能描述：查看登录用户信息 执行权限：所有用户 命令所在路径：/usr/bin/who 123[root@ecs-s2-medium-2-linux-20190722215607 /]# whoroot tty1 2019-08-07 11:17root pts/4 2019-08-16 22:08 (183.39.158.131) 第一个部分是登录的用户名，第二个是登录终端（tty1是本地登录，pts表示远程登录），第三个是登录的时间，最后的是登录的主机ip（缺省为本地登录） w功能描述：查看登录用户详细信息 执行权限：所有用户 命令所在路径： /usr/bin/w 12345[root@ecs-s2-medium-2-linux-20190722215607 /]# w 23:17:56 up 25 days, 2 min, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 07Aug19 9days 0.01s 0.01s -bashroot pts/4 183.39.158.131 22:08 4.00s 0.02s 0.00s w load average: 0.00, 0.01, 0.05表示1分钟，5分钟，10分钟内负载百分比 IDLE表示该用户空闲了多久，PCPU表示CPU时间 ，JCPU表示总共占用的CPU实际 WHAT表示用户当前执行的命令]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令-帮助命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[man命令man可以查看命令的帮组和配置文件的帮助 man查看命令信息例如想要查看ls的帮助信息 1man ls 查看ls命令的帮助信息 按空格翻页 按q离开 NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息，输入/xxx即可 man查看配置文件信息例如查看 locale.conf配置，注意不需要加绝对路径，直接名字即可 1man locale.conf NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息 往后翻，可以查看到使用的方法 1234567OPTIONS The following locale settings may be set using /etc/locale.conf: LANG=, LANGUAGE=, LC_CTYPE=, LC_NUMERIC=, LC_TIME=, LC_COLLATE=, LC_MONETARY=, LC_MESSAGES=, LC_PAPER=, LC_NAME=, LC_ADDRESS=, LC_TELEPHONE=, LC_MEASUREMENT=, LC_IDENTIFICATION=. Note that LC_ALL may not be configured in this file. For details about the meaning and semantics of these settings, refer to locale(7).EXAMPLE Example 1. German locale with English messages 特殊情况如果碰到一个即是命令又是配置文件的该怎么办？ 例如passwd命令 用whereis查看passwd 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whereis passwdpasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.5.gz 可以看到查出来既有命令又有配置文件，第一个是命令的位置，第二个是配置文件的位置，第三个是命令帮助文件的位置，第四个是配置文件帮助命令的位置 1是命令的帮助 5是配置文件的帮助。优先显示命令的帮组 1man 5 passwd 即可查看该配置文件的信息 whatis命令如果只是想简单的看下该命令是做什么的可以用此命令 1what is 该命令会直接显示NAME的信息，这样就不用看一大片的英文了。 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whatis lsls (1) - list directory contents apropos 命令如果想简单的查看配置文件的信息，用该命令即可 例如 12[root@ecs-s2-medium-2-linux-20190722215607 /]# apropos locale.conflocale.conf (5) - Configuration file for locale settings –help 选项利用--help会把常见的选项信息列出 123456789101112131415161718192021222324[root@ecs-s2-medium-2-linux-20190722215607 /]# ls --helpUsage: ls [OPTION]... [FILE]...List information about the FILEs (the current directory by default).Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be 'never', 'auto', or 'always' (the default); more info below -d, --directory list directories themselves, not their contents -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -ls --color help 命令该命令可以查看Shell内置命令的帮助信息 什么是内置命令？在shell中默认设置的命令就是内置命令。shell的作用就是向内核解释代码。 例如cd命令 12[root@ecs-s2-medium-2-linux-20190722215607 /]# type cdcd is a shell builtin 使用help命令查看cd命令 12345678910111213141516171819202122232425262728[root@ecs-s2-medium-2-linux-20190722215607 /]# help cdcd: cd [-L|[-P [-e]]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars' is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed -P use the physical directory structure without following symbolic links -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status The default is to follow symbolic links, as if `-L' were specified. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. 总结 man 查看命令或配置文件帮助 whatis 获得命令简短的信息 apropos 获得配置文件的简短信息 help 查看shell查看shell内置命令信息]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署云服务器的全过程]]></title>
    <url>%2F2019%2F08%2F16%2Fhexo%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言由于不想部署在github上，因为Github的访问速度在国内比较慢，所以有了此文。 部署之前先了解一下hexo利于git更新的流程，部署在Github上和部署在云服务器上没有特别大的本质区别。 整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。再利于nginx托管这些静态资源，就可以实现快速的访问。 环境本地环境 Windows10(64bit) 已经装好了git,nodejs,hexo 已经在本地调试好了hexo静态网站 服务器环境 华为云ECS（1M1核2G，centos7） 已经装好了git，nodejs，以及编译好了Nginx 本地机器配置配置密钥在本地机器（Windows环境）中进入 使用git bash生成ssh公钥12# 本地 windows gitBashssh-keygen -t rsa 一路回车，直至如下图，即可。 在本地服务器中配置好了公钥，接下来我们需要把这个公钥交给服务器，相当于本地机器有了一把能访问服务器的“钥匙”，所以接下来需要配置服务器。 服务器配置安装Git,nodejs,Nginx等linux下安装这些非常简单，直接百度即可。 创建git新用户及配置创建git新用户1234adduser git #加入git用户passwd git #配置你的密码chmod 740 /etc/sudoers #修改权限 r=4 w=2 x=1 rwx=7 r__=4 ___=0,也就是说git的sudo使用权为只读vim /etc/sudoers 打开suduers，找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在他的下面加入以下内容 1git ALL=(ALL) ALL wq保存后，需要将权限修改回来 1chmod 400 /etc/sudoers 将公钥配置到服务器上首先你得在你的本地机器上找到你的公钥，一般在用户的家目录下，windows是Administrator目录，linux是~/.ssh下 我的本地机器是windows，所以在Administrator目录下。 将该文件的内容复制。 在服务器端，切换至刚刚创建好的git用户下，创建.ssh文件和authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 修改权限 123cd ~chmod 600 .ssh/authorzied_keys # 将文件设置为可读可写chmod 700 .ssh #将该文件夹设置为可读可写可执行，注意文件夹的可执行是指能访问 测试git连接切换到本地机器上，在本地机器上测试是否能连接到你的远程git用户 1ssh -v git@SERVER_IP 测试成功 如果你的测试不成功，请查看具体的输出信息，通常是公钥没配置好，可以把原来生成的公钥删了，重新配置一遍。 创建网站的根目录创建网站的根目录的目的是为了让nginx托管这些静态文件。 创建一个目录用于作为网站的根目录。切换成root用户 12su rootmkdir /home/hexo # 此目录为网站的根目录 变更该目录的所有者 1chown git:git -R /home/hexo 安装以及配置Nginx安装过程略，具体可百度。编译好nginx后，进入其配置文件 1vim conf/nginx.conf 在http端下配置你的虚拟主机 12345678910111213141516171819server&#123; listen 8081; #监听8081端口 server_name 139.159.245.212; #你的服务器名，通常是域名，如果是域名，你就需要监听80端口 root /home/hexo; #网站的根目录 location / &#123; &#125;#access_log logs/access.log mylog;error_page 404 /404.html; #配置40x页面 location = /40x.html &#123;&#125;error_page 500 502 503 504 /50x.html; #配置50x页面 location = /50x.html &#123;&#125;&#125; 注意使用 nginx -t 命令检查配置文件的语法是否出错。然后使用 systemctl restart nginx.service 或者 在编译好的nginx目录下使用sbin/nginx -s reload命令重启服务即可。 实现自动化部署建立git裸库该裸库什么版本信息和数据都不保存，单纯是为了共享而存在。 在root 用户下 123su rootcd /home/git # 在 git 用户目录下创建git init --bare hexo.git 这时，git 用户的 ~ 目录下就存在一个 hexo.git 文件夹，可使用 ls 命令查看。再修改 hexo.git 的所有者。 1chown git:git -R hexo.git 使用 git-hooks 同步网站根目录在这使用的是 post-receive 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 blog.git 裸库的 hooks 文件夹中，新建 post-receive 文件。 1vim hexo.git/hooks/post-receive 填入以下内容，其中 /home/hexo 为网站目录，根据自己的填入,保存退出。 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/hexo.git checkout -f 该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下 -f这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了 保存后，要赋予这个文件可执行权限。 1chmod +x /home/git/hexo.git/hooks/post-receive 这样就完成了git自动部署的配置 本地机器中部署至服务器在本地中，和部署到 github 服务一样，需要先 hexo g 命令生成静态文件，通过 hexo s 命令能够正常进行本地访问，并且确保已经安装了 hexo-deployer-git。 配置hexohexo 根目录下的 _config.yml 文件，找到 deploy。 1234deploy: type: git repo: git@SERVER:/home/git/hexo.git # 填写你的服务器地址 将SERVER替换掉 branch: master # 分支 之后按照正常的流程部署 1hexo c &amp;&amp; hexo g &amp;&amp; hexo d 测试自动化部署 部署成功，访问测试]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬取CSDN博客列表]]></title>
    <url>%2F2019%2F08%2F16%2FScrapy%E7%88%AC%E5%8F%96CSDN%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 其可以应用在数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。 具体可查看文档 scrapy中文文档 新建Scrapy爬虫项目如果你还没有安装Scrapy，可以通过下面这个命令安装 1pip install scrapy 新建一个项目安装好之后就可以创建项目了 1scrapy startproject 你的项目名 创建好之后的目录如上图所示 每个文件的具体作用可以参照Scrapy的官方文档，这里就不再赘述。 新建一个爬虫通过命令 1scrapy genspider 你的爬虫名 设置配置文件如果你不需要存入数据库或者做进一步的反爬处理，则可以跳过这一步，打开setting.py进行以下修改 设置浏览器名把BOT_NAME设置为你的浏览器名，如果使用默认，别人一看就知道是爬虫 1BOT_NAME = 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11' 设置日志级别这样就不需要打印太多日志信息，干扰视线 1LOG_LEVEL='WARN' 设置模式将机器人模式设为FALSE 1ROBOTSTXT_OBEY = False 设置你要抓取的博客页数12#博客页数CsdnPage = 2; 设置你的数据库为了方便将数据自动导入数据库，需要设置数据库配置信息，我使用的是mysql 1234567#数据库设置MYSQL_HOST = '你的主机名'MYSQL_PORT = 3306 #端口MYSQL_DBNAME = 'DBNAME' # 数据库名MYSQL_TABLE = 'TABLE_NAME' #表名MYSQL_USER = '你的用户名' MYSQL_PASSWD='你的密码' 新建数据项数据项的作用是方便scrapy以结构化的数据插入到数据库中。 打开 items.py，复制一下代码即可，或者你如果要爬新的数据，请记得加入新的字段 12345678import scrapyclass CsdnItem(scrapy.Item): # define the fields for your item here like: title = scrapy.Field() url = scrapy.Field() #date = scrapy.Field() tag = scrapy.Field() pass 编写爬虫文件123456789101112131415161718192021222324252627282930313233import scrapyfrom ..items import CsdnItemfrom ..settings import CsdnPageclass CsdnSpiderSpider(scrapy.Spider): name = &apos;csdn_spider&apos; allowed_domains = [&apos;blog.csdn.net&apos;] start_urls = [&apos;https://blog.csdn.net/weixin_41154636/article/list/1&apos;] def parse(self, response): try: for div in response.xpath(&apos;//div[contains(@class,&quot;article-item-box&quot;)]&apos;): item = CsdnItem() item[&apos;title&apos;] = div.xpath(&apos;./h4/a/text()&apos;)[1].extract().strip() item[&apos;url&apos;] = div.xpath(&apos;./h4/a/@href&apos;)[0].extract().strip() item[&apos;tag&apos;] = item[&apos;url&apos;].split(&apos;/&apos;)[-1] # 爬取时间戳，方便按时间排序 # item[&apos;date&apos;] = div.xpath(&apos;//span[@class=&quot;date&quot;]/text()&apos;)[1].extract().strip() # 我也不知道为什么抓出来会有这个- -，所以特殊处理一下 if item[&apos;title&apos;] == &apos;帝都的凛冬&apos;: continue # 控制台输出 print(item[&apos;title&apos;] + &quot; &quot; + item[&apos;url&apos;] + &quot; &quot; + item[&apos;tag&apos;]) # 封装成bean，装入数据库 yield item # 实现翻页的功能 for page in range(2, CsdnPage + 1): url = &quot;https://blog.csdn.net/weixin_41154636/article/list/%s&quot; % page yield scrapy.Request(url, callback=self.parse) except BaseException: print(BaseException.__cause__) pass 具体代码的说明注释已经写得很清楚了。 另外，需要注意的是，因为CSDN的翻页是通过ajax请求实现的，所以需要自己构造请求。 如果发现跑不起来，很可能是因为CSDN的HTML结构发生了改变，你可以了解一下XPATH的写法，然后修改即可。 先看下运行结果吧： 进入到spiders目录中运行 1scrapy crawl csdn_spider #你的爬虫名，在上面的代码最开始定义的 DONE！信息已经爬下来了，接下来就是把数据保存至数据库中。 保存数据至数据库在setting.py中，把pipeline注释去掉 123ITEM_PIPELINES = &#123; 'csdn.pipelines.CsdnPipeline': 300,&#125; 在piplines.py中编写一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pymysqlfrom scrapy.utils.project import get_project_settingsfrom twisted.enterprise import adbapifrom .items import CsdnItemclass DBHelper: def __init__(self): self.settings = get_project_settings() # 获取settings配置数据 dbparams = dict( host=self.settings['MYSQL_HOST'], # 读取settings中的配置 db=self.settings['MYSQL_DBNAME'], user=self.settings['MYSQL_USER'], passwd=self.settings['MYSQL_PASSWD'], charset='utf8', # 编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) # **表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... dbpool = adbapi.ConnectionPool('pymysql', **dbparams) self.dbpool = dbpool def connect(self): return self.dbpool # 插入数据 def insert(self, item): self.settings = get_project_settings() # 获取settings配置数据 if isinstance(item, CsdnItem): tb_name = self.settings['MYSQL_TABLE'] sql = """insert into """ + tb_name + """(id,title,link) values (%s,%s,%s) """ # print(sql) # 调用插入的方法 query = self.dbpool.runInteraction(self._conditional_insert, sql, item) # 调用异常处理方法 query.addErrback(self._handle_error) return item # 写入数据库中 def _conditional_insert(self, canshu, sql, item): # 取出要存入的数据，这里item就是爬虫代码爬下来存入items内的数据 if isinstance(item, CsdnItem): import datetime # 字符串转为DateTime类型 # dateTime_p = datetime.datetime.strptime(item['date'], '%Y-%m-%d %H:%M:%S') params = ( item['tag'], item['title'], item['url']) canshu.execute(sql, params) # 错误处理方法 def _handle_error(self, failue): pass print('--------------database operation exception!!-----------------') # self.connect.rollback() print(failue)# 这里执行scrapy处理脚本class CsdnPipeline(object): def __init__(self): self.db = DBHelper() def process_item(self, item, spider): # 插入数据库 self.db.insert(item) return item 具体说明注释已经写的很清楚了。 这样就完成了导入至数据库的工作 再次运行爬虫。 1scrapy crawl csdn_spider 可以看到，数据就全部自动导入到数据库了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理：系统总线总结]]></title>
    <url>%2F2019%2F08%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总线的基本概念历史：早期计算机采用分散连接的方式，这种连接方式以运算器为中心，I/O与存储器交换信息时，都要通过运算器，致使运算器停止运算。为了提高CPU工作效率，改进为存储器为中心的分散连接。随着IO设备的增多，这种连接方式逐渐淘汰，所以出现了总线连接的方式。计算机使用总线结构便于增减外设，同时减少了信息传输线。 知识点： 总线：总线是连接多个部件的信息传输线，是各部件共享的传输介质。以CPU为中心的双总线结构：包括存储总线（M总线）和I/O总线，前者连接CPU和主存，后者连接CPU和I/O。缺点：这种结构在I/O与主存进行交换信息依然要占用CPU单总线结构:单独拉出一条系统总线，CPU，主存，和各IO设备连接到该系统总线。当I/O与主存进行交换信息时，CPU可以继续处理不访问主存或I/O设备的操作。缺点：因为只有一组总线。容器发生冲突，就必须设置判优逻辑，这会影响整机的工作速度以存储器为中心的双总线结构：在单总线的基础上又开辟了一条CPU与主存之间的总线（存储总线）。存储总线只提供主存与CPU直接的信息传输。有点像上面两种结构的折中。 总线的分类分类标准： 按数据传送方式可分为：并行传输总线和串行传输总线 按总线的使用范围可分为 计算机总线，测控总线，网络通信总线 （==重点==）按连接部件分 片内总线，系统总线，通信总线。片内总线：芯片内部的总线，如：CPU内部，寄存器和寄存器之间，寄存器和ALU之间都是由片内总线连接，速度极快。系统总线：系统总线是指：在CPU，主存，I/O设备各大部件之间的信息传输线。系统总线下面按照传输信息的不同又可分为数据总线，地址总线，控制总线1. 数据总线用来传输各部件之间的数据信息，双向数据线。2.地址总线用来指出数据总线上的源数据或目的数据所在主存单元或I/O设备的地址。单向传输：由CPU输出。用来指明CPU要访问的存储单元或I/O地址3.控制总线用来发出各种控制信号的传输线（控制信号，响应信号，时序信号）。对于某个特定的控制线来说他是单向的，但是从总体上看控制总线是双向的。 （举个例子，假如有A,B两条控制线，其中A的方向为CPU到I/O，B的方向为I/O到CPU，对于A,B来说，他们的控制信号传输方向是不能改变的，但从总体上看，控制总线既有从CPU-&gt;I/O的，也有I/O到CPU的，所以总体上是双向的） 通信总线按传输方式分为两种：串行通信和并行通信 1.串行通信串行通信是指单条1位宽的数据线，一位一位分时地进行传输。 2.并行通信多条并行的1位宽的数据，同时进行传输。 3.对比 - 串行通信 并行通信 优点 稳定，信号不易受到干扰 传输速率快 缺点 传输速率慢 易受干扰 适用场景 远距离传输 近距离传输 # 总线的特性及性能指标 ## 总线特性 1. 机械特性 指连接方式上的一些特性 2. 电气特性 指每个传输线的信号的传递方向和电平范围（什么范围为高？什么范围为低） 3. 功能特性 每个传输线的功能 4. 时间特性 任一根线在什么时间内有效 总线指标 总线宽度：数据总线的根数，用位（bit）表示 总线带宽：单位时间内总线上传输数据的位数 通常用MBps（兆字节每秒） （注意与bps进行区别，bps指的是波特率，是单位时间内传输的位数） 总线复用：一条信号线上分时传送两种信号。采用多路复用技术实现 时钟同步/异步 信号线数 总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等 其他指标：负载能力、电源电压、总线宽度是否可以扩展等 负载能力：指驱动能力，当总线接上负载后，总线输入输出的逻辑电平是否保持在额定范围内。 总线标准1. ISA总线 具有独立于CPU的总线时钟 总线宽度为16位，地址线为24位 CPU需花大量时间来控制和外部设备交换数据2.EISA总线 在ISA总线的基础得来，从CPU分离出了总线控制权 总线宽度为32位，地址宽度为32位3.VESA(VL-BUS)总线 总线宽度为32位，可扩展至64位4.PCI总线 高性能，不依赖某个具体的处理器，数据线为32位可扩展至64位 兼容性良好 支持即插即用（Plug and Play）（PCI和USB都支持） 采用多路复用技术 ………………. 5.AGP总线AGP（Accelerated Graphics Port 加速图形端口）处理三维数据和图形的总线，一般用于显卡。 6.RS-232C总线一种串行通信总线，可用于实现载波通信 7.USB总线通用串行总线（USB）具有以下特征 即插即用 很强的连接能力，可以连接多个外设到一个系统 数据传输率 1.0可达1.5Mbps 2.0可达480Mbps 标准统一 体积小巧 生命力强 总线结构一般分为单总线结构和多总线结构 单总线结构有个系统总线，CPU，主存，I/O设备都挂在上面，容易造成计算机性能的瓶颈。 多总线结构双总线结构：包括主存总线和I/O总线三总线结构：包括主存总线（CPU和主存之间）、I/O总线（CPU和IO之间）和DMA总线（主存和IO之间） 总线控制总线控制包括了判优控制和通信控制：主模块：主模块对总线有控制权从模块：从模块只能响应主模块发来的总线命令，没有总线控制权 判优控制判优控制可分为集中式和分布式两种 集中式 链式查询其控制总线由BS（总线忙）,BR（总线请求）,BG（总线同意）三条线构成。BG是串行地由一个I/O接口送到下一个I/O接口。如果到达的接口有请求，BG信号就不再往下传，意味着该接口获得了总线的使用权，然后建立BS（总线忙）信号。优先级逐级递减，对电路故障敏感 计数器定时查询相比链式查询，少了一根总线同意线（BG），多了一组设备地址线。工作方式： 总线控制器接到BR线送来的总线请求信号后，在总线未被使用的情况下（BS=0）由计数器开始计数，并通过设备地址线发出一组地址信号，然后某个与该信号一致的设备获得总线使用权。此时终止计数查询，查询可以从0开始（此时优先级逐级递减），也可以从上一次终止计数的地方开始（此时各部件优先级相同，这种也叫循环计数） 独立请求方式独立请求方式，每一设备都有单独的一组BR（总线请求）和BG（总线同意）。而总线控制部件中有一排队电路，可按优先次序确定响应哪个设备的请求。特点是响应时间短，速度快，但控制复杂 对比 - 优点 缺点 控制线数 链式查询 控制简单，仅用三根线即可控制并且很容易扩充设备 对电路故障敏感，低优先级的设备很难获得控制权 3根 计数器定时查询 优先次序可以被改变，对电路故障没那么敏感 增加了控制线，控制也比较复杂 ${log_2{n}}$ 独立请求方式 响应速度快，优先次序控制灵活 控制线线路较多，控制复杂 2n 分布式考纲和书上没有，不总结 通信控制目的：解决通信双方如何获知信息传输开始和传输结束，以及通信双方如何协调与配合可分为：同步，异步，半同步，分离式 总线周期（通信周期） 申请分配阶段由主模块提出申请，经过总线仲裁机构决定下一周期总线使用权给哪个申请者 寻址阶段获得了使用权的主模块通过总线发出本次要访问的从模块的地址和有关命令 传数阶段主模块和从模块进行数据交换。 结束阶段主模块让出总线控制权 通信方式同步通信通信双方由统一时钟信号控制下进行通信，时钟信号通常由CPU的总线控制部件发出，每个周期内完成特定的任务。 异步通信不采用统一的时钟信号控制通信，而采用应答的方式进行通信可分为：不互锁，半互锁，全互锁 1. 不互锁 对于主模块来说：主模块发出信息后，不需要等待街道从模块的回答信号，而是经过一段时间，便撤销请求信号 对于从模块来说：从模块接收到请求后，在条件就发出回答信号，并经过一段时间，便撤销回答信号。 应用场景：CPU向主存写信息 2.半互锁 对于主模块来说：主模块发出请求信号，必须接到从模块的回答信号才撤销其请求信号，有互锁关系 对于从模块来说：从模块接到请求信号后发出回答信号，而不必等待获知主模块的撤销请求信号，而是隔一段时间后就撤回回答信号，无互锁关系。 应用场景多机系统中，CPU访问共享存储器，CPU发出访存命令后，必须接收到存储器未被占用的回答信号，才能进行真正的访存操作 3.全互锁 对于主模块来说：主模块发出请求信号，必须接收到从模块的回答信号，然后发出撤销请求信号，存在互锁关系 对于从模块来说：从模块发出回答信号之后，必须等待获知主模块的撤销请求信号，存在互锁关系 应用场景：网络通信，例如著名的三次握手半同步通信半同步通信既保留了同步通信的特点（发送方所有的地址，命令、数据信号的发出时间在系统时钟的某个上升沿开始，接收方都采用系统时钟后沿时刻进行识别判断），同时又通过插入N个“等待”（WAIT）信号解决与协调通信速度不一致的问题，双方像异步通信那也，允许不同速度的模块进行工作分离式通信进一步分析总线传输周期得知，除了申请总线这一阶段，其余时间主要花在下面3个地方 主模块通过传输总线向从模块发出地址与命令 从模块准备数据 从模块经过数据总线向主模块发送数据 可以看见，在2中从模块准备数据的过程中，总线并没有完全利用，处于等待状态，为了发掘系统每一瞬间的潜力，因此采用了分离式通信。分离式通信将传输周期（or总线周期）分为两个子周期。 第一个子周期模块A在获得总线使用权后，将命令，地址等信息发到系统总线上，然后立刻放弃总线使用权，给别的模块使用 第二个子周期B模块接收到命令后，经过一段时间（译码，读取）准备好数据之后，申请总线控制权，一旦获批，B模块便把数据放到系统总线上，传输给A，然后立刻放弃总线控制权。显然：上面两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习总结]]></title>
    <url>%2F2019%2F07%2F30%2FReact%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言前端可以做到读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序，而不是信息的纯展示。这种单张网页的应用程序称为 SPA（single-page-application）。2010年后，前端工程师从开发页面（切模板），逐渐变成了开发“前端应用”（跑在浏览器里面的应用程序）。目前，最流行的前端框架 Vue、Angular、React 等等，都属于 SPA 开发框架。 react脚手架建立工程1、安装1npm install create-react-app -g 2、创建1create-react-app react-demo (react-demo项目名) 3、初始化1cd react-demo 1npm install or cnpm install or yarn install 4、运行1yarn start 创建一个helloWorld Demo引入模块 12345//第一步 导入reactimport React,&#123;Component&#125; from 'react';import '../assets/css/index.css'import logo from '../assets/images/logo.svg';import '../assets/css/App.css'; 1234567891011121314151617181920212223242526272829303132/** * 绑定原生属性注意： * class 要换成className * for 要换成htmlFor * style 要用&#123;&#125;包裹成对象 *///第二步，编写组件类并继承React.Componentclass Home extends Component&#123; constructor()&#123; super(); //定义数据 this.state=&#123; msg:'你好，世界！' &#125; &#125;//第三步，重写render()方法，用于渲染页面 render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;img src=&#123;logo&#125; width='500px'&gt;&lt;/img&gt; &lt;/div&gt; ); &#125;&#125;//第四步，导出该类export default Home; 然后启动工程即可完成一个简单的demo 1yarn start react是面向组件的，通过JSX语法来操作虚拟dom节点，如果state的数据发生了变化则会触发对应的dom的刷新。JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 注意在本地引用img等资源时，需要通过{xx}对象形式引用。如果是网络图片，直接用url引用即可。 JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 react 通过state来定义和绑定数据，但这种绑定并不是MVVM那种双向数据绑定，在JSX中要使用时通过 123456789101112131415161718192021## 知识点：### 1. 目录结构分析![20190816155754](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155754.png!blog)用脚手架创建的工程的目录是有些不完整的，需要补全（为了方便归档）component文件主要放组件，model放数据模型，App.js是默认的根组件，index.js是入口文件，相当于main，yarn.lock是项目生成的临时文件，package.json是依赖管理文件（类似maven的pom文件），nodel_modules是存放依赖包的文件夹### 2. 创建组件第一步 导入react第二步，编写组件类并继承React.Component第三步，重写render()方法，用于渲染页面第四步，导出该类### 3. JSX注意事项如果要在模板中嵌套多个HTML标签，需要使用一个父元素对其进行包裹 &lt;div&gt; &lt;h1&gt;{this.state.msg}&lt;/h1&gt; &lt;img src={logo} width=&apos;500px&apos;&gt;&lt;/img&gt; &lt;/div&gt;12345### 4.绑定数据或对象js中定义对象用&#123;&#125;,其实就是restful风格的东东。类似于 { title:”xxx”, content:”xxxx”} 123数据的定义用[ ]，一对方括号即可。在react中绑定对象只需要在state中定义即可 this.state={ msg:’你好，世界！’ } 12# 事件及数据绑定Demo import React from ‘react’ class Demo1 extends React.Component{ constructor(props){ super(props); this.state={ msg:”demo1组件”, text:””, keydown:””, } } run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; } inputChange=(e)=&gt;{ //获取表单的值 //console.log(e.target.value); this.setState({ text: e.target.value }) } inputChange1=()=&gt;{ let value = this.refs.input.value; this.setState({ text: value }) } getInputValue=()=&gt;{ alert(this.state.text) } inputOnKeydown = (e)=&gt;{ console.log(e.keyCode); this.setState({ keydown:e.keyCode }) } inputChange2 = (e)=&gt;{ this.setState({ text:e.target.value }) } changeTextMode = (e)=&gt;{ this.setState({ text:&quot;改变后的model值,可以看到下面这个输入框的数据已经改变，而上面两个输入框未发生变化&quot; }) } render(){ return ( &lt;div&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;事件对象演示&lt;/h2&gt; {this.state.msg} {/* 事件对象 */} &lt;button id=&apos;buttonId&apos; onClick={this.run}&gt;事件对象&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;表单事件演示&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input type=&quot;text&quot; onChange={this.inputChange}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;ref获取dom节点,获得表单值&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input ref=&apos;input&apos; type=&quot;text&quot; onChange={this.inputChange1}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;键盘事件&lt;/h2&gt; &lt;p&gt;{this.state.keydown}&lt;/p&gt; &lt;input type=&quot;text&quot; onKeyDown={this.inputOnKeydown}/&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;react实现双向数据绑定&lt;/h2&gt; &lt;p&gt;model改变影响view(通过value属性),view改变影响model&lt;/p&gt; &lt;p&gt;model值：{this.state.text}&lt;/p&gt; &lt;input type=&apos;text&apos; value={this.state.text} onChange={this.inputChange2}&gt;&lt;/input&gt; &lt;button onClick={this.changeTextMode}&gt;改变model的值&lt;/button&gt; &lt;/div&gt; ) }} export default Demo1 ; 123456789![20190816155821](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155821.png!blog)## 知识点：### 事件绑定：1. 绑定事件需要在对应的事件响应中获得正确的this对象 例如：为Button 绑定了一个事件 事件对象 12如果你用箭头函数写响应方法，则this指向的就是react的当前组件 run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12如果你用的是普通写法写的函数响应 funtion run(e){ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12需要使用下面这种写法传递对象指向 事件对象 12### 数据绑定（View-&gt;Model） {this.state.text} 12 inputChange=(e)=&gt;{ //获取表单的值，设置model的数据 //console.log(e.target.value); this.setState({ text: e.target.value }) }12### 数据绑定（Model-&gt;View） 获取表单值 12 getInputValue=()=&gt;{ alert(this.state.text) //获取model中的数据 } 12### 双向数据绑定（M-&gt;V&amp;V-&gt;M 俗称MVVM） react实现双向数据绑定 model改变影响view(通过value属性),view改变影响model model值：{this.state.text} 改变model的值 12345678value 通过属性绑定model 完成 m-&gt;v的绑定通过监听onChange完成v-&gt;m的绑定 ，和上面那个View-&gt;Model的绑定是一样的。# TodoList小练习该练习的旨在熟悉双向数据绑定和react的基础用法，另外扩展了localStorage缓冲处理方案，实现刷新不会丢失数据状态。![20190816155842](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155842.png!blog) import React, {Component}from ‘react’;import Storage from ‘../model/storage’ class Demo3 extends Component { constructor(props) { super(props); this.state = { todo:’’, todolist:[], }; } //生命周期函数，页面加载触发 componentDidMount=()=&gt;{ let list = Storage.get(&apos;todolist&apos;); if(list){ console.log(&quot;get:&quot;+list) this.setState({ todolist:list }) } } addTodoText=(e)=&gt;{ this.setState({ todo: e.target.value }) } onAddBtnClick=()=&gt;{ let todolist = this.state.todolist; todolist.push({ todo:this.state.todo, checked:false }) this.setState({ todolist:todolist, todo:&quot;&quot; }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } onPressEnter=(e)=&gt;{ if(e.keyCode==13){ this.onAddBtnClick(); } } ondelBtnClick=(index)=&gt;{ let todolist = this.state.todolist; todolist.splice(index,1); this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } checkChange = (index)=&gt;{ let todolist = this.state.todolist; todolist[index].checked=!todolist[index].checked; this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } render() { return ( &lt;div&gt; &lt;h2&gt;todoList 演示&lt;/h2&gt; &lt;header&gt;&lt;input type=&quot;text&quot; value={this.state.todo} onChange={this.addTodoText} onKeyDown={this.onPressEnter}/&gt; &lt;button onClick={this.onAddBtnClick}&gt;增加&lt;/button&gt;&lt;/header&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;未完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(!value.checked){ return ( &lt;div key={index}&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;已完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(value.checked){ return ( &lt;div key={index} className=&apos;complete&apos;&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;/div&gt; ); }} export default Demo3; 12345678&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;# 远程请求数据Demo通过axios向服务端请求数据，我这里没有通过配置代理解决跨域问题，而是在后端配置了取消CROS请求来解决跨域问题 import React from ‘react’import axios from ‘axios’import request from ‘../model/server’import jsonp from ‘fetch-jsonp’ class Demo4 extends React.Component { constructor(props) { super(props); this.state = { list:[], }; } getData = ()=&gt;{ let api = ‘http://localhost:18080/house/resources/findAll&#39; axios.get(api) .then((response)=&gt;{ console.log(response) this.setState({ list:response.data }) }) .catch((error)=&gt;{ console.log(error) }) // let data =await request.get(api) // console.log(data) } render() { return ( &lt;div&gt; &lt;h2&gt;axios获取服务器数据,未处理跨域，取消cros&lt;/h2&gt; &lt;button onClick={this.getData}&gt;获取服务器数据&lt;/button&gt; &lt;p&gt;url:&lt;a href=&apos;http://localhost:18080/house/resources/findAll&apos;&gt;http://localhost:18080/house/resources/findAll&lt;/a&gt;&lt;/p&gt; &lt;ul&gt; { this.state.list.map((value,index)=&gt;{ return ( &lt;li key={index}&gt;{value.created}&lt;/li&gt; ) }) } &lt;/ul&gt; &lt;h2&gt;jsonp获取服务器数据,跨域请求&lt;/h2&gt; &lt;p&gt;怎么看，看你的地址加入callback=xxx之后是否能访问就知道是否支持jsonp了&lt;/p&gt; &lt;/div&gt; ); }} export default Demo4; 12345678910111213![1565942347213](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1565942347213.png)## 知识点：### 1. 跨域问题所谓跨域问题就是 协议，域名，端口三者有其一不一致则出现跨域，一般情况下跨域是不被浏览器支持的。### 2. axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。使用 npm install –save axios 1234# React-router 4.x基本配置及动态路由使用### 安装 cnpm install react-router-dom –save 12### 引入 import {BrowserRouter as Router,Route,Link} from ‘react-router-dom’ 12### 基本使用： 首页 新闻 12345678910111213141516![20190816155928](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155928.png!blog)![20190816155957](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155957.png!blog)### 动态路由的使用#### 定义路由 12#### 使用路由 { this.state.list1.map((value,key)=&gt;{ return ( //ES6模板字符串写法 &lt;Link to={/content/${value.aid}?content=${value.content}} key={key}&gt; {value.title} ) })} 12#### 在子组件中获得动态路由的传参 aid:this.props.match.params.aid, 123456789在prps.match.params中获取传参即可### 利用get实现动态路由无需定义路由格式，直接使用，在路由后面像get方法一样传参类似"?name=zhong"这种#### 使用路由 {value.title} 12345其中**?content=$&#123;value.content&#125;** 就是使用了get传参#### 在子组件中获得动态路由的传参 componentDidMount(){ //通过npm带的url模块解析get参数 cnpm install url --save 安装即可 console.log(url.parse(this.props.location.search,true)) let news = { aid:this.props.match.params.aid, //通过动态路由传值 content:url.parse(this.props.location.search,true).query.content, //通过get传值 } this.setState({ news:news }) }```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot下采用Dubbo进行服务治理]]></title>
    <url>%2F2019%2F07%2F19%2FSpringBoot%E4%B8%8B%E9%87%87%E7%94%A8Dubbo%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%2F</url>
    <content type="text"><![CDATA[Dubbo 是什么Apache Dubbo™ (incubating)是一款高性能Java RPC框架官网：http://dubbo.apache.org/zh-cn/index.html使用感受：Dubbo将传统的服务调用关系分为了消费者和提供者。符合现在前后端分离的这种模式。 Dubbo架构如图节点角色说明： 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 使用记录主要记录dubbo的工作流程，加深理解，如果需要详细的配置及代码请移步度娘 1、服务注册中心使用zookeeper作为服务注册中心，将其部署在docker上。Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 部署+启动12345678#启动dockerservice docker start#拉取镜像docker pull zookeeper:3.5#创建容器docker create --name zk -p 2181:2181 zookeeper:3.5#启动容器docker start zk 启动成功后，可查看容器运行情况 1docker ps 默认端口是2181。 2、SpringBoot下引入Dubbo进行服务治理最明显的感受就是dubbo是非侵入性的，原先的service可以不发生改变，由dubbo调用该service并暴露一个dubbo服务接口给controller，简单的代码就可以实现服务治理。 2.1dubbo配置在springboot的配置文件application.properties中 1234567891011121314151617#Dubbo配置# Service versiondubbo.service.version = 1.0.0# 服务的扫描包dubbo.scan.basePackages = zhong.dubbo.server.api# 应用名称dubbo.application.name = dubbo-provider-house-resources# 协议以及端口dubbo.protocol.name = dubbodubbo.protocol.port = 20881# zk注册中心dubbo.registry.address = zookeeper://192.168.146.128:2181dubbo.registry.client = zkclient 2.2dubbo使用2.2.1定义dubbo服务接口dubbo的服务要实现此接口，同时，该接口也是暴露给外层应用调用的，需要注意的是，要把接口和实现分开。 2.2.2实现dubbo服务接口新增一个api包，在这里使用dubbo并暴露出dubbo服务的接口给表现层（我随便说的，感觉像类似） 1234567891011121314151617/** * 这个是dubbo服务，不要和spring的服务搞混了 */@Service(version = "1.0.0")public class HouseResourcesService implements ApiHouseResourcesService &#123; /** * 注入的是spring的服务 */ @Autowired private zhong.dubbo.server.service.HouseResourcesService houseResourcesService; @Override public int saveHouseResources(HouseResources houseResources) &#123; return this.houseResourcesService.saveHouseResources(houseResources); &#125;&#125; 2.3查看dubbo服务利用dubbo-admin即可查看注册的服务如果没配置过dubbo-admin，可以看这篇https://blog.csdn.net/weixin_41154636/article/details/96478016 2.3调用dubbo在Controller中，因为在上一步中已经完成dubbo服务接口的定义及实现，并且把dubbo 服务的接口注入到spring容器中了。所以只需要在controller中调用duddo服务即可。使用起来非常简单呢。 1234567891011121314151617181920212223242526272829303132@RequestMapping("house/resources")@Controllerpublic class HouseResourcesController &#123; @Autowired private HouseResourcesService houseResourcesService; /** * * @param houseResources 接收json数据 * @return */ @PostMapping @ResponseBody public ResponseEntity&lt;Void&gt; save(@RequestBody HouseResources houseResources)&#123; try &#123; boolean success = this.houseResourcesService.save(houseResources); if(success)&#123; return ResponseEntity.status(HttpStatus.CREATED).build(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); &#125; @GetMapping @ResponseBody public ResponseEntity&lt;String&gt; get()&#123; return ResponseEntity.ok("ok"); &#125;&#125; 可以从dubbo-admin中看到消费者列表这个时候这里的消费者就是指某个controller，这里只是完成了服务的订阅，当某个请求过来的时候，才是真正的服务调用，dubbo会根据负载均衡的不同策略对已注册的服务选择调用。 Dubbo的工作流程总结 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo-Admin的配置以及遇到的坑]]></title>
    <url>%2F2019%2F07%2F19%2FDubbo-Admin%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Dubbo-Admin下载配置环境： linux centos7在github上clone到本地即可 1git clone https://github.com/apache/dubbo-admin.git 前端配置dubbo采用前后端分离部署，所以他的部署相对有点麻烦，如果按照官方的文档，像个铁憨憨一样c+v，则会出现npm install fail 等错误。因为前端工程是用vue开发的，所以得先配个node.js即可，node.js中自带了npm。首先进入前端工程目录下 1cd dubbo-admin/dubbo-admin-ui 修改前端工程端口及配置信息如果需要修改前端工程端口或其他配置信息，进入到 1vim config/index.js 配置文件下修改即可需要注意的是，如果修改了后端的端口，记得修改ProxyTable的配置 构建dubbo-admin前端工程运行 1npm install 启动dubbo-admin前端工程在当前目录下，运行 1npm run dev 运行前端项目，然后就应该可以访问页面了。 配置后端项目进入后端工程，后端是用springboot和Maven构建的。所以如果你没配置maven的话，可以在先配个maven在linux中配置maven非常简单，具体操作咨询度娘。 修改后端配置修改注册中心端口1vim dubbo-admin-server/src/main/resources/application.properties 在这里主要配置注册中心的端口因为我的zookeeper（服务注册中心）是部署在本机的，所以用本机地址即可。 修改dubbo-admin后台服务端口默认端口为8080，如果需要更改，加入配置 1server.port=&lt;端口号&gt; 构建进入到dubbo-admin-server目录下，进行构建，如果直接在项目根目录构建会出错。 1cd dubbo-admin-server 运行 1mvn clean package 将项目打包，正常情况下的能构建成功的，如果是npm fail失败的原因，请仔细检查前端工程的配置或是否将前端工程build和install 启动运行 1mvn --projects dubbo-admin-server spring-boot:run 然后你再次访问前端页面，就可以监视到通过dubbo注册在zookeeper的服务了。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加法器的实现及优化]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、半加器半加器有一个异或门和与门组成，异或门赋值记录数值，与门记录是否产生了进位。但是半加器是无法完成加法运算的。 需要完成加法运算，需要用到全加器 2、全加器 全加器由两个半加器组成，绿色的为一个半加器，橙色的为另一个半加器。三个输入，两个输出。 两个输出表示了他能表示的范围为0,1,2,3 对应的二进制则为表上的Cout 与 S 例如进行1+1的运算时 先来看看S的输出： A端输入1，B端输入1，C端输入0（最低位加法运算默认为0），1（A）异或1（B） 结果为0（记为D）0（D）+0（Cin）结果是0，所以绿色的异或门输出（S）为0，说明该位的运算结果为0。 再来看看Cout（进位）的输出： 1（A）与1（B） 结果为1，说明产生了进位，橙色的与门输出1。由S的输出过程可得绿色的与门的输入为0,0，绿色的与门输出为0，这个时候需要一个或门即可判断两次加法（A+B和B+Cin）是否产生了进位，只要其中一个产生的进位，Cout置1。 运算结果： 将Cout与S连起来，就是10，也就是2。 减法的实现：减法实际上就是加法 A-B 可以表示为 A+ （-B） 这个-B可以用补码来表示。 如上图所示，sub-mode负责加减法的选择，同时他连接到最低位的Cin端。 如果为加法，则sub-mode为0，那么直接进行加法运算 如果为减法，则sub-mode为1，最低位数字Cin（C0端）被置为1，同时控制电路对B的每一位是输入数字作取反处理，这样就完成的（-B）补码的“按位取反，末位加一”的操作。然后按加法运算即可 3、行波进位加法器行波进位加法器就是由n个全加器构成的，可以运算n位的加法。 例如计算：1101+0110。将每个低位的Cout（进位输出）作为对应高位的Cin（进位输入）。 这里Cout最高位为1，而假设我们当前的寄存器的位数为4位，则产生了溢出。 溢出和进位的区别：溢出：表示数据超过了正常的表示范围，如果采用浮点表示还分成上溢出和下溢出。 进位：N进制进位这个就是逢N进一 需要注意，溢出和进位并没有直接关系。溢出的发生只在有符号位时发生，也就是说你的机器数是带符号的就有可能产生溢出。 判断溢出的方法：1、最高位数值和符号位都发生了进位或者都不产生进位，则没有溢出。最高位数值和符号位有一个产生进位，另一个没有进位，则为溢出。计算机实现用异或电路 例如 1,111+0,100 -&gt;10011(舍去最高位) ，最终结果为 0,011 未发生进位 2、如果采用两位符号位表示，原理和方法1一样，采用了两位符号位来记录原来的1位符号位和最高数值位的进位情况，这样就不需要用异或电路。符号位为00或11则未溢出，如果为01为正溢出（此时真正的符号位正），10为负溢出（此时真正的符号为负） 行波进位加法器的运算过程：在进行加法运算时，首先准备好的是（从右往左为1,2,3,4号）1号全加器的3个input。而2、3、4号全加器的Cin全部来自前一个全加器的Cout，只有等到1号全加器运算完毕，2、3、4号全加器才能依次进行进位运算，最终得到结果。 这样进位输出，像波浪一样，依次从低位到高位传递， 最终产生结果的加法器，也因此得名为行波进位加法器（Ripple-Carry Adder，RCA）。 RCA的优点是电路布局简单，设计方便， 我们只要设计好了全加器，连接起来就构成了多位的加法器。 但是缺点也很明显，也就是高位的运算必须等待低位的运算完成， 这样造成了整个加法器的延迟时间很长。那么，RCA的效率到底如何呢？让我们来算一算： 将4bit的RCA内部结构全部打开，就得到了如图2所示的4-bit RCA的门电路图。要对一个电路的性能进行分析，我们就要找出其中的最长路径。 也就是找出所有的从输入到输出的电路连接中，经过的门数最多的那一条，也称为关键路径（如下图所示）。 判断延迟的两个指标：（1）门延迟经过每个门所花费的实际，称为门延迟 （2）线延迟输入信号进入到这块电路之后，在连接线上传递需要花时间。 称为线延迟 行波进位加法器的延迟分析：以只考虑门延迟为例 从第一个全加器的A-S这条通路来看，产生第一个S输出，需要通过两个门的延迟。 所以它显然不是最长的路径，当然，从A出发或着从B出发都是一样的， 所以对于第一个全加器，它的最长路径，是红色线标记的那条，后面的全加器关键路径同理可得。 那么，假设经过一个门电路的延迟时间为T，那么经过4个全加器所需要的总延迟时间就是：2T x 4 + T(第一个全加器产生3个T) = 9T。所以推出，经过n个全加器所产生的总延迟时间为2T x n + T = (2n+1)T。 对于一个32bit的RCA，有总延迟时间：(2n+1)T =(2×32+1)×T =65T，这是什么概念呢？举个例子，iPhone 5s的A7 SoC处理器采用28nm制造工艺，主频1.3GHz（0.66ns CPU时钟周期中每两个上沿所隔的时间）。按照这个工艺水平，门延迟T设为0.02ns，那么32-bit RCA的延迟时间为1.3ns ，时钟频率为769MHz，远超A7处理器的主频延迟时间，更别说这个32bit的RCA只是一个加法运算器，更更别说，我们在计算过程中只考虑了门延迟，还有线延迟等各种延迟没有加入计算…… 4、超前进位加法器从上面可以看到，影响行波进位加法器（RCA）运算效率的主要因素是高位的运算必须等待低位的“进位输出信号”，那我们的优化思路就是‘能否提前计算出“进位输出信号’ ？” 答案是有的，如图所示。 全加器有三个输入，当其中的两个为1时，必定产生进位。这样就有了如下的公式： Ai Bi Ci 分别是全加器的三个输入，Ci+1为进位输出 Ci为进位输入。 如果是最低位，则Ci=C0，C0根据加法或是减法置为0或者1。 简化公式得： 如果表示4个全加器的进位输入输出： 可以得到由每个低位全加器的进位输出得到每个高位全加器的进位输入。 最终我们需要得到的是C4，经过换算，C4=G3+P3·G2+P3·P2·G1+P3·P2·P1·G0+P3·P2·P1·P0·C0，而这些参数，全部已知！并不需要前一个全加器运算输出，由此我们得到了提前计算进位输出的方法， 用这样的方法实现了加法器就被称为超前进位加法器（Carry-Lookahead Adder，CLA）。 这样就实现了提前获得进位输入的能力，这样就大大提高了加法运算的效率。但有得必有失，这样的代价是电路比较复杂。 超前进位加法器的实现 C4的结果由或门实现，把每个多项式进行求和，乘用与门实现。 延迟分析 使用CLA来进行加法运算的效率如何呢？还是按照Apple A7处理器的工艺水平，单个CLA的延迟为0.08ns，4级CLA的延迟为0.26ns，时钟频率3.84GHz，都远远小于主频的延迟，完全符合标准。然而，由图可见，计算4bit的二进制数，就要平行排列4个全加器，那么要是计算8bit，16bit，32bit……的呢？可能就需要更复杂的布线方式，这就是CLA的缺点。 比较一下RCA和CLA的优缺点： 行波进位加法器（RCA） 超前进位加法器（LCA） 结构特点 低位全加器的Cout连接到高一位全加器Cin 每个全加器的进位输入并不来自于前一级的全加器，而是来自超前进位的逻辑电路 优点 电路布局简单，设计方便 计算Ci+1的延迟时间固定为三级门延迟，与加法器的位数无关 缺点 高位的运算必须等待低位的运算完成，延迟时间长 如果进一步拓宽加法器的位数，则电路变得非常复杂 32位的加法器如果采用行波进位的方式，我们已经分析过需要65级的门延迟， 那如果采用超前进位的方式，理想情况下也只需要四级的门延迟，但可惜的是， 这也只是一个理想。因为要实现32位的完全的超前进位，电路就会变得非常的复杂。 因此通常的实现方法， 是采用多个小规模的超前进位加法器拼接而成一个较大的加法器，例如，用4个8-bit的超前进位加法器连接成32-bit加法器。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSM的后台管理系统]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%9F%BA%E4%BA%8ESSM%E7%9A%84%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言：使用SpringMVC+Spring+Mybatis以及maven的一个简单的后台管理系统，程序的结构分为表现层（Controller）、业务层(Service)、数据层(Dao)，包括权限授权、分页查询、日志记录，订单及产品查询，授权管理等功能。 远程仓库地址： https://github.com/XiaoZhong233/SSM_Maneger_DEMO 技术点：1、Spring IOC &amp; DI（控制反转和依赖注入） 2、Spring AOC (切面编程) 3、Spring Security 进行用户登录与注销等安全授权 4、Mybatis dao层半ORM数据库技术（单表查询、多表查询等） 5、Mybatis插件PageHelper，进行分页查询 6、方法级权限关联与控制（运用Sercurity标签等技术） 7、前端使用AdminLTE静态页面模板以及jquery等技术 说明：1、SSM的配置还是比较繁琐的，不过作为入门级的DEMO，还是有必要自己亲自配的 2、Mybatis使用XML配置，DAO层由于想要提高SQL部分的解耦程度，所以使用XML配置统一管理 3、Service和Controller中由于不需要过多的配置、因此使用注解的方式进行依赖注入 运行结果：先放两张图 数据库设计数据表数据包括订单，产品，游客，会员以及日志。 产品表 订单表 会员表 旅客表 数据库ER图 表之间的关系旅客表（traverller）、订单表（orders）、会员表(member)、产品表（product）的id都是uuid（）下随机生成的 订单表（orders）-&gt;产品表（product）一对一的关系 订单表（orders）-&gt;会员表(member) 一对一的关系 订单表（orders）-&gt;旅客表（traverller）多对多的关系（在Mybatis时中和一对多的处理很像，只不过多对多需要一张中间表） 项目结构图：项目为多模块结构: 流程：引入依赖文件（pom.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;scau.zhong&lt;/groupId&gt; &lt;artifactId&gt;ssm_pratice&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;!--版本锁定--&gt; &lt;mybatis.version&gt;3.5.1&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;spring.version&gt;5.1.7.RELEASE&lt;/spring.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--spring全家桶--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring安全组件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--权限控制_页面控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mysql坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet API--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!--数据库连接池C3P0--&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--权限控制JSR250注解标签--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--多模块项目--&gt; &lt;modules&gt; &lt;module&gt;ssm_dao&lt;/module&gt; &lt;module&gt;ssm_service&lt;/module&gt; &lt;module&gt;ssm_domain&lt;/module&gt; &lt;module&gt;ssm_utils&lt;/module&gt; &lt;module&gt;ssm_web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 实体类建立Product实体类12345678910111213141516171819202122232425package domain; import org.springframework.format.annotation.DateTimeFormat;import util.DateUtils; import java.io.Serializable;import java.util.Date; public class Product implements Serializable &#123; private String id; // 主键 private String productNum; // 编号 唯一 private String productName; // 名称 private String cityName; // 出发城市 //这个注解的目的是用spring来帮助处理这个属性从表单提交时的数据转换 @DateTimeFormat(pattern="yyyy-MM-dd HH:mm") private Date departureTime; // 出发时间 private String departureTimeStr;//出发时间格式化数据 private double productPrice; // 产品价格 private String productDesc; // 产品描述 private Integer productStatus; // 状态 0 关闭 1 开启 private String productStatusStr;//状态格式化 //省略getter 和 setter &#125; Member实体类12345678910111213package domain; import java.io.Serializable; public class Member implements Serializable &#123; private String id; private String name; private String nickname; private String phoneNum; private String email; //省略getter 和 setter &#125; Traveller实体类123456789101112131415161718package domain; import java.io.Serializable; public class Traveller implements Serializable &#123; private String id; private String name; private String sex; private String phoneNum; private Integer credentialsType; private String credentialsTypeStr; private String credentialsNum; private Integer travellerType; private String travellerTypeStr; //省略getter 和 setter &#125; Orders实体类1234567891011121314151617181920212223242526272829package domain; import org.springframework.format.annotation.DateTimeFormat;import util.DateUtils; import java.io.Serializable;import java.util.Date;import java.util.List; public class Orders implements Serializable &#123; private String id; private String orderNum; @DateTimeFormat(pattern="yyyy-MM-dd HH:mm") private Date orderTime; private String orderTimeStr; //订单时间格式化 private int orderStatus; private String orderStatusStr; //订单状态格式化 private int peopleCount; private Product product; private List&lt;Traveller&gt; travellers; private Member member; private Integer payType; private String payTypeStr; //支付状态格式化 private String orderDesc; //省略getter 和 setter &#125; 配置与整合SSM整合的关键是用Spirng去整合SpirngMVC以及Mybatis，所以整合的基本流程是这样的： 1、配置Spring 2、配置Mybatis 3、配置Spring mvc 4、整合Spring和Mybatis 5、整合Spring和SpringMVC 因为这里用到Spring security认证，所以还需要配置一个Spring security，但不属于SSM范围内。 配置文件统一放在Resources目录下，方便管理 配置Spring 新建一个xml文件命令为applicationContext.xml ，引入约束 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd"&gt; 开启注解扫描，dao层不扫描，只扫描service和controller层 123 &lt;!--开启注解扫描，只需要扫描Service层的注解即可，DAO层由xml配置--&gt;&lt;!-- &lt;context:component-scan base-package="dao"/&gt;--&gt; &lt;context:component-scan base-package="service"/&gt; 注意这里的base-package应该是全路径包名，我这里在java目录下只有一个包所以只写了一层 配置Mybatis建立实体类与dao接口 具体的实体类代码和接口代码就不贴出来了。 mybatis使用半ORM映射技术，不需要你自己实现DAO接口，它会自动帮你实现一个代理dao接口，其内部原理大概就是动态代理技术（基于接口）和XML（注解）解析等 有了实体类，我们封装的对象就有了，有了接口，封装的dao方法就有了，现在要做的是就是对接口方法进行一个“增强”，也就是动态代理，这个mybatis会自动帮我们实现，所以只需要进行mapper的配置来说明如何增强即可。 配置mappermybatis中需要注意的一点是，mapper配置必须与dao接口处于同一个包下或者具有相同的包结构 这里我将xml配置文件全部放置在resources目录下，所以必须和dao接口的包结构一致。 当然，你在开始一个项目的时候，不肯一下子配置这么多mapper的，都是你需要的时候再配就可以了。 在mapper中的配置、以memberMapper为例： 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IMemberDao"&gt; &lt;select id="findMemberById" resultType="domain.Member"&gt; select * from member where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; namespace属性指定dao接口所在的bao，id是方法名，mybatis需要找到你要增强的方法的路径，合起来也就是dao.IMemberDao.findMemberById 其他的mapper也大同小异，就不贴出来了。 配置mybatis全局配置文件新建一个xml文件，SqlMapConfig.xml 在这里主要配置数据源信息，mapper信息等全局配置 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--使用typeAlias配置别名--&gt; &lt;typeAliases&gt; &lt;!--type指定全限定类名,alias指定别名，别名不区分大小写--&gt; &lt;typeAlias type="domain.Product" alias="product"/&gt; &lt;typeAlias type="domain.Orders" alias="orders"/&gt; &lt;typeAlias type="domain.Member" alias="member"/&gt; &lt;typeAlias type="domain.Traveller" alias="traveller"/&gt; &lt;typeAlias type="domain.User" alias="user"/&gt; &lt;typeAlias type="domain.Role" alias="role"/&gt; &lt;typeAlias type="domain.Permission" alias="permission"/&gt; &lt;typeAlias type="domain.SysLog" alias="log"/&gt; &lt;/typeAliases&gt; &lt;!--这个mapper必须在最下面！！ 映射dao的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/ProductMapper"/&gt; &lt;mapper resource="dao/OrderMapper"/&gt; &lt;mapper resource="dao/MemberMapper"/&gt; &lt;mapper resource="dao/TravellerMapper"/&gt; &lt;mapper resource="dao/UserMapper"/&gt; &lt;mapper resource="dao/RoleMapper"/&gt; &lt;mapper resource="dao/PermissionMapper"/&gt; &lt;mapper resource="dao/User_RoleMapper"/&gt; &lt;mapper resource="dao/SysLogMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 会发现：我这里没有配置数据源信息，原因是没必要配（但你配了也无妨），因为之后在spring整合mybatis时，会在spring中配置。 至此、mybatis的配置就完成了。 配置SpringMVC新建一个xml spring-mvc.xml文件，用来配置springMVC 引入约束在spring-mvc.xml中加入以下内容 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; 开启注解扫描12&lt;!--开启注解扫描,只扫描Controller包下的注解--&gt;&lt;context:component-scan base-package="controller"/&gt; 配置视图解析器视图解析器也就是告诉前端控制器到哪去找视图（在这里是jsp文件） 1234567&lt;!--视图解析器--&gt;&lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--prefix代表路径前缀--&gt; &lt;property name="prefix" value="/pages/"/&gt; &lt;!--suffix表示文件后缀--&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 需要注意的是这里的id是固定的，spring容器需要根据这个id找到这个视图解析器 配置静态资源不拦截123456&lt;!--告诉前端控制器哪些静态资源不拦截--&gt;&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**" /&gt;&lt;mvc:resources location="/img/" mapping="/img/**" /&gt;&lt;mvc:resources location="/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/plugins/" mapping="/plugins/**" /&gt; 其他配置123456789&lt;!--开启SpringMVC注解支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; Spring整合Mybatis回到刚才创建的Spring配置文件applicationContext.xml中，在这里整合Mybatis 因为之前在mybatis中未配置数据源信息，所以要先配置数据源 spring中配置数据源123456789&lt;!--Spring整合mybatis--&gt;&lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--注入数据库连接信息--&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ssm1?use Unicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt; 配置sqlSession工厂对象12345678910111213141516171819202122&lt;!--配置sqlSession工厂对象--&gt; &lt;bean id="factory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置pagerHelper插件,注意其他配置 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;props&gt; &lt;prop key="helperDialect"&gt;mysql&lt;/prop&gt; &lt;prop key="reasonable"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--设置数据源--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--映射mybatis全局配置文件--&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml"/&gt; &lt;/bean&gt; 配置事务管理Spring是有事务管理的，这点非常棒，这样你就不用利用AOP自己写一个事务管理了 1234567&lt;!-- 配置Spring的声明式事务管理 --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 配置Mybatis的Mapper1234567891011121314151617181920212223242526272829&lt;!--映射mapper文件,获取生成代理Dao--&gt;&lt;bean id="productMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IProductDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="orderMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IOrdersDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IUserDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="roleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IRoleDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="permissionMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IPermissionDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="user_roleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IUser_RoleDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="SysLogMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.ISysLogDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt; Spirng整合SpringMVC如果没配置，我们的Spring容器是没有被创建的，通过监听servletContext对象，在初始化的时候创建spring容器。 在web.xml中配置1234567891011121314&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!--加载spring的配置，整合spring mvc与spring，通过监听servletContext对象的生命周期实现，默认加载applicationContext.xml文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 针对Spring配置：读取配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml,classpath*:spring-security.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--监听请求--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;&lt;/listener&gt; 配置前端控制器12345678910111213141516&lt;!--配置前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动加载该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置过滤器123456789101112131415161718&lt;!--解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置Spring Security同在web.xml文件中，配置 12345678910&lt;!--配置Spring security--&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 指定你要拦截路径，这里是全部，Spring Security帮助我们完成用户的认证与授权操作 新建一个xml配置文件 spring-security.xml用来配置安全认证的一些选项。 在spring-security.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt; &lt;!--开启权限控制标签--&gt; &lt;security:global-method-security jsr250-annotations="disabled" secured-annotations="disabled" pre-post-annotations="enabled"/&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern="/login.jsp" security="none"/&gt; &lt;security:http pattern="/failer.jsp" security="none"/&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式，不使用则无法使用security标签控制页面显示 --&gt; &lt;security:http auto-config="true" use-expressions="true"&gt; &lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt; &lt;security:intercept-url pattern="/**" access="hasAnyAuthority('ROLE_USER','ROLE_ADMIN','ROLE_SUPER')"/&gt; &lt;!-- 定义跳转的具体的页面 --&gt; &lt;security:form-login login-page="/login.jsp" login-processing-url="/login.do" default-target-url="/index.jsp" authentication-failure-url="/failer.jsp" authentication-success-forward-url="/pages/main.jsp" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 注销按钮 退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.do" logout-success-url="/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 userService是实现spring service的规范实现类--&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式 --&gt; &lt;security:password-encoder ref="passwordEncoder"/&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; Dao接口建立基于XML配置Mybatis配置全局配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--使用typeAlias配置别名--&gt; &lt;typeAliases&gt; &lt;!--type指定全限定类名,alias指定别名，别名不区分大小写--&gt; &lt;typeAlias type="domain.Product" alias="product"/&gt; &lt;typeAlias type="domain.Orders" alias="orders"/&gt; &lt;typeAlias type="domain.Member" alias="member"/&gt; &lt;typeAlias type="domain.Traveller" alias="traveller"/&gt; &lt;/typeAliases&gt; &lt;!--这个mapper必须在最下面！！ 映射dao的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/ProductMapper"/&gt; &lt;mapper resource="dao/OrderMapper"/&gt; &lt;mapper resource="dao/MemberMapper"/&gt; &lt;mapper resource="dao/TravellerMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 这里没有配置数据源信息的原因是已经在spring中配置了 创建mybatis工厂对象将mybatis工厂对象交给Spring IOC容器管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解扫描，只需要扫描Service层的注解即可，DAO层由xml配置--&gt;&lt;!-- &lt;context:component-scan base-package="dao"/&gt;--&gt; &lt;context:component-scan base-package="service"/&gt; &lt;!--Spring整合mybatis--&gt; &lt;!--配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--注入数据库连接信息--&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ssm1?use Unicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--配置sqlSession工厂对象--&gt; &lt;bean id="factory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--设置数据源--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--映射mybatis全局配置文件--&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置Spring的声明式事务管理 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!--映射mapper文件,获取生成代理Dao--&gt; &lt;bean id="productMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IProductDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt; &lt;/bean&gt; &lt;bean id="orderMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IOrdersDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置Mapper文件MemberMapper123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IMemberDao"&gt; &lt;select id="findMemberById" resultType="domain.Member"&gt; select * from member where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ProductMapper12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IProductDao"&gt; &lt;select id="findAll" resultType="product"&gt; select * from product &lt;/select&gt; &lt;insert id="insert" parameterType="product"&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="java.lang.String" order="BEFORE"&gt; select replace(uuid(),'-','') &lt;/selectKey&gt; insert into product(id,productNum,productName,departureTime,cityName,productPrice,productDesc,productStatus) values (#&#123;id&#125;,#&#123;productNum&#125;,#&#123;productName&#125;,#&#123;departureTime&#125;,#&#123;cityName&#125;,#&#123;productPrice&#125;,#&#123;productDesc&#125;,#&#123;productStatus&#125;) &lt;/insert&gt; &lt;select id="findById" resultType="product" parameterType="java.lang.String"&gt; select * from product where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; TraverllerMapper123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.ITraveller"&gt; &lt;select id="findTravellerByOrderId" resultType="traveller" parameterType="java.lang.String"&gt; select * from traveller where id in (select travellerId from order_traveller where #&#123;oid&#125; = orderId) &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.IOrdersDao&quot;&gt; &lt;!--嵌套结果查询--&gt; &lt;resultMap id=&quot;orderMap&quot; type=&quot;domain.Orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt; &lt;result property=&quot;orderNum&quot; column=&quot;orderNum&quot;/&gt; &lt;result property=&quot;orderTime&quot; column=&quot;orderTime&quot;/&gt; &lt;result property=&quot;orderStatus&quot; column=&quot;orderStatus&quot;/&gt; &lt;result property=&quot;peopleCount&quot; column=&quot;peopleCount&quot;/&gt; &lt;result property=&quot;payType&quot; column=&quot;payType&quot;/&gt; &lt;result property=&quot;orderDesc&quot; column=&quot;orderDesc&quot;/&gt; &lt;!--association:用于映射关联查询单个对象的信息 property:要将关联查询的用户信息映射到Orders中那个属性--&gt; &lt;association property=&quot;product&quot; javaType=&quot;domain.Product&quot;&gt; &lt;!-- id:关联查询的唯一标识 column:指定唯一标识信息的列 property:映射到product的哪个属性 --&gt; &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;productNum&quot; property=&quot;productNum&quot;/&gt; &lt;result column=&quot;productName&quot; property=&quot;productName&quot;/&gt; &lt;result column=&quot;cityName&quot; property=&quot;cityName&quot;/&gt; &lt;result column=&quot;departureTime&quot; property=&quot;departureTime&quot;/&gt; &lt;result column=&quot;productPrice&quot; property=&quot;productPrice&quot;/&gt; &lt;result column=&quot;productDesc&quot; property=&quot;productDesc&quot;/&gt; &lt;result column=&quot;productStatus&quot; property=&quot;productStatus&quot;/&gt; &lt;/association&gt; &lt;!--查询映射会员信息--&gt; &lt;association property=&quot;member&quot; javaType=&quot;domain.Member&quot;&gt; &lt;id column=&quot;mid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;phoneNum&quot; property=&quot;phoneNum&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;/association&gt; &lt;!--根据中间表查询旅客信息--&gt; &lt;!-- 关联旅客明细信息 一个订单关联查询出了多条旅客,要使用collection映射 collection:对关联查询到的多条记录映射到集合中 property:将关联查询到的多条记录映射到orders类的那个属性 ofType:指定映射的集合属性中pojo的类型 --&gt; &lt;collection property=&quot;travellers&quot; ofType=&quot;domain.Traveller&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;phoneNum&quot; property=&quot;phoneNum&quot;/&gt; &lt;result column=&quot;credentialsType&quot; property=&quot;credentialsType&quot;/&gt; &lt;result column=&quot;credentialsNum&quot; property=&quot;credentialsNum&quot;/&gt; &lt;result column=&quot;travellerType&quot; property=&quot;travellerType&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--定义Order的ResultMap懒加载模式映射,嵌套查询--&gt; &lt;resultMap id=&quot;OrderMapLazy&quot; type=&quot;domain.Orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;orderNum&quot; column=&quot;orderNum&quot;/&gt; &lt;result property=&quot;orderTime&quot; column=&quot;orderTime&quot;/&gt; &lt;result property=&quot;orderStatus&quot; column=&quot;orderStatus&quot;/&gt; &lt;result property=&quot;peopleCount&quot; column=&quot;peopleCount&quot;/&gt; &lt;result property=&quot;payType&quot; column=&quot;payType&quot;/&gt; &lt;result property=&quot;orderDesc&quot; column=&quot;orderDesc&quot;/&gt; &lt;!--配置Order对象中product映射 ofType是类型，用全限定名或别名--&gt; &lt;!--一对一查询--&gt; &lt;association property=&quot;product&quot; javaType=&quot;domain.Product&quot; select=&quot;dao.IProductDao.findById&quot; column=&quot;productId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;association property=&quot;member&quot; javaType=&quot;domain.Member&quot; select=&quot;dao.IMemberDao.findMemberById&quot; column=&quot;memberId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;!--多对多查询,需要根据中间表来查询--&gt; &lt;collection property=&quot;travellers&quot; ofType=&quot;domain.Traveller&quot; column=&quot;id&quot; select=&quot;dao.ITraveller.findTravellerByOrderId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;!--如果是一对多查询，还是用colleaction标签，只不过不需要通过中间表查询--&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; select o.id as oid,o.memberid,o.orderDesc,o.orderNum,o.orderStatus,o.orderTime,o.payType,o.peopleCount,o.productId, p.id as pid,p.cityName,p.departureTime,p.productDesc,p.productName,p.productNum,p.productPrice,p.productStatus, t.id as tid,t.credentialsNum,t.credentialsType,t.`name`,t.phoneNum,t.sex,t.travellerType, m.id as mid,m.email,m.`name`,m.nickName,m.phoneNum from orders o LEFT OUTER JOIN order_traveller ot on o.id=ot.orderId , product p,traveller t,member m WHERE o.productId = p.id and t.id = ot.travellerId and m.id = o.memberid &lt;/select&gt; &lt;select id=&quot;findAll1&quot; resultMap=&quot;OrderMapLazy&quot;&gt; select * from orders &lt;/select&gt; &lt;select id=&quot;getAll&quot; resultType=&quot;domain.Orders&quot;&gt; select * from orders &lt;/select&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;OrderMapLazy&quot; parameterType=&quot;java.lang.String&quot;&gt; select * from orders where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; Service实现略，具体的看源代码即可 Controller实现略，具体的看源代码即可 模块功能实现这里看下Controller的情况，就可以知道大概的功能了。 其中：UserController包括用户的一些常规操作以及授权操作，比如那个角色的用户可以访问哪些模块，哪个角色的用户看不见哪些模块的页面 产品管理产品、订单、游客、会员的表关系可以看这篇 https://blog.csdn.net/weixin_41154636/article/details/90680658 订单管理 用户管理 角色管理 资源权限管理 日志管理原理：利用AOP记录用户访问信息 权限控制如果以超级管理员（所有模块可访问） 是可以查看日志的 如果你只是普通的用户，是无法看见访问日志选项的 另外普通用户在访问某些模块时会提示权限不足 感想SSM配置好鸡儿多好鸡儿复杂，我选择Springboot :)]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
</search>
