<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编程珠玑：位排序（Python实现）]]></title>
    <url>%2F2019%2F09%2F09%2F%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%EF%BC%9A%E4%BD%8D%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题描述 输入 给出至多10,00,000个正整数的序列 特征： –每个数都小于10,000,00–数据不重复且 数据之间不存在关联关系 输出：增序输出序列 约束： –内存容量1MB–磁盘空间充足–运行时间至多几分钟—最好线性时间代码：https://github.com/XiaoZhong233/DataStructure_Python/blob/master/sort/vectorsort.py 采用位排序可满足上面的要求。位排序的优点就是特别特别省内存空间~100万个不同的整数排序只需要32Byte的内存空间。 什么是位排序位排序就是将n个整数转为二进制位，然后通过按顺序读出二进制达到排序的作用。 例如[3,7,5,2] = 00110101 然后从左往右读出该二进制串，可以获得最后的有序序列[2,3,5,7]，如果你想变成降序，那就从右往左读。 python实现位集合借鉴了某个大佬的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111# coding='utf-8'import arrayclass BitSet(object): def __init__(self, capacity): #"B"类型相当于 C 语言的 unsigned char， 即占用1byte（8位），所以size大小设置为8，一个数占一个字节 self.unit_size = 8 self.unit_count = int((capacity + self.unit_size - 1) / self.unit_size) self.capacity = capacity self.arr = array.array("B", [0] * self.unit_count) pass # 是否存在为1的位 def any(self): for a in self.arr: if a != 0: return True return False def all(self): #是否所有位都为 1， 即是否存在置为 0 的位 t = (1 &lt;&lt; self.unit_size) - 1 for a in self.arr: if (a &amp; t) != t: return False return True def none(self): #是否所有位都为 0，即是否不存在置为 1 的位 for a in self.arr: if a != 0: return False return True def count(self): # 1 的位的个数 c = 0 for a in self.arr: while a &gt; 0: if a &amp; 1: c+=1 a = a&gt;&gt;1 pass return c def size(self): #所有位的个数 return self.unit_count * self.unit_size def get(self, pos): #获取第 pos 位的值 index = int(pos / self.unit_size) offset = (self.unit_size - (pos - index * self.unit_size) - 1) % self.unit_size return (self.arr[index] &gt;&gt; offset) &amp; 1 def test(self, pos): #判断第 pos 位的值是否为 1 if self.get(pos): return True return False def set(self, pos = -1): #设置第 pos 位的值为 1，若 pos 为 -1， 则所有位都置为 1 if pos &gt;= 0: index = int(pos / self.unit_size) offset = (self.unit_size - (pos - index * self.unit_size) - 1) % self.unit_size self.arr[index] = (self.arr[index]) | (1 &lt;&lt; offset) else: t = (1 &lt;&lt; self.unit_size) - 1 for i in range(self.unit_count): self.arr[i] = self.arr[i] | t def reset(self, pos = -1): #设置第 pos 位的值为 0，若 pos 为 -1， 则所有位都置为 0 if pos &gt;= 0: index = int(pos / self.unit_size) offset = (self.unit_size - (pos - index * self.unit_size) - 1) % self.unit_size x = (1 &lt;&lt; offset) self.arr[index] = (self.arr[index]) &amp; (~x) else: for i in range(self.unit_count): self.arr[i] = 0 def flip(self, pos = -1): #把第 pos 位的值取反，若 pos 为 -1， 则所有位都取反 if pos &gt;= 0: if self.get(pos): self.reset(pos) else: self.set(pos) else: for i in range(self.unit_count): self.arr[i] = ~self.arr[i] + (1 &lt;&lt; self.unit_size) def binstr(self): b = '' for a in self.arr: t = bin(a) b += "0" * (self.unit_size - len(t) + 2) + t + "," return "[" + b.replace("0b", "").strip(",") + "]" def show(self): return self.arrif __name__ == '__main__': bitSet = BitSet(32) bitSet.set() print(bitSet.binstr()) print(bitSet.count()) 位排序（Python实现）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# coding = "utf-8"import syssys.path.append('../tool')import TimeCalculatorimport BitSetimport numpy as npdef generate_data(n): return np.random.randint(low=0, high=n, size=n)# 写成txt文件def wirte_data(n): data = generate_data(n) np.savetxt('./data.txt', X=data, fmt="%d",delimiter=" ", newline = " ")# 写成二进制文件def wirte_data2(n): data = generate_data(n) np.save(file ='./data', arr = data, )def load_data2(file = './data.npy'): return np.load(file)# 对n（n&lt;=1000000）个小于n的正整数序列进行排序# 时间在10s以内# 空间占用小于1MB@TimeCalculator.display_timedef vertorsort(data, n=1000000): bitset = BitSet.BitSet(n) # 初始化位图,模拟从I/O读入数据 for i in data: bitset.set(i) result = [] # 输出位图排序结果,模拟向I/0写入数据 print("空间大小占用:") print(str(sys.getsizeof(bitset)) + "Byte") for i in range(bitset.size()): if bitset.test(i): result.append(i) return result passif __name__ == '__main__': # 模拟100万个100万内的数据 wirte_data2(10**6) # 模拟从磁盘中读取数据 data = load_data2() # 模拟向I/O输出排序结果 result = vertorsort(data, 10**6) np.savetxt('./datasort.txt', X=result, fmt="%d",delimiter=" ", newline = " ") # print(result) 运行结果时间与空间花费 输出结果 优点与缺点 优点： 位排序非常非常非常节省内存空间，100万个不同的整数排序，只需要32B的辅助空间。 缺点 数据需要从I/O读取是硬伤，实际上正是由于了I/O拖累了整体的速度，100万个整数排序，需要4600ms（4.6秒）左右（如果采用C语言应该会更快），时间成本上比快速排序差远了。 如果使用快速排序，100万个整数差不多需要4~5MB的内存空间，非常大了，是位排序的15万倍。但快排的时间成本也是非常可观的，只需要400ms（0.4秒）作用。 下图是非递归快排的100万不同随机整数的排序时间花费： 快速排序果然是内部排序之王 适用场景位排序的适用场景是内存空间十分有限，但速度没那么严格的情况，典型的时间换空间。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOE网及关键路径实现]]></title>
    <url>%2F2019%2F09%2F03%2FAOE%E7%BD%91%E5%8F%8A%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[关键路径算法原理AOE网是另一种常用的带权有向图。这是一种重要的PERT模型（Program Evaluation and Review Technique,规划评估和评审技术），最早是美国军方支持开发出来的，用于大型工程的计划与管理，有着广泛的实际工程应用。抽象地看：AOE网是一种无环的带权有向图，其中 顶点表示事件，有向边表示活动，边上的权值通常表示活动的持续时间。 图中的一个顶点表示的事件，也就是他的入边所表示的活动已经完成，他的出边的活动刚刚开始，把这一情况看作事件。 实际工程或复杂事物里的一批相关活动（工作项目、任务等），可以用一个AOE网抽象的描述，然后就可以基于这个网考虑活动的安排了。 graph LR V0((V0)) V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V7((V7)) V8((V8)) V0--6-->V1 V0--4-->V2 V0--5-->V3 V1--1-->V4 V2--1-->V4 V3--2-->V5 V4--9-->V6 V4--7-->V7 V5--4-->V7 V6--2-->V8 V7--4-->V8 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445# 关键路径def criticalPath(self, delay=0): topo = self.topological_sort() if not topo: raise GraphError("存在有向环！") ve = [0 for i in range(len(topo))] # 事件最早开始时间 vl = [0 for i in range(len(topo))] # 事件最迟开始时间 cp = [] # 关键路径 result = &#123;&#125; # 返回结果 # --------------------------------计算事件的最早发生时间----------------------------- for i in range(topo.__len__()): start = topo[i] # 取出拓扑节点 for node in self.get_outEdge(start).keys(): # 获取拓扑节点的邻接点，计算ve w = self._graph[start][node] # 当前节点与邻接节点的边 j = topo.index(node) # 邻接节点的下标 if ve[j] &lt; ve[i] + w: # 更新邻接点的最早发生时间，选大的时间 ve[j] = ve[i] + w pass # --------------------------------计算事件的最晚发生时间----------------------------- for i in range(topo.__len__()): # 给每个事件的最迟发生时间置初值，初值为最早发生时间中的最大值 vl[i] = ve[topo.__len__() - 1] + delay for i in reversed(range(topo.__len__())): k = topo[i] # 取出拓扑节点 for node in self.get_inEdge(k).keys(): # 获取拓扑节点的逆邻接点，计算vl w = self._graph[node][k] # 逆邻接点和当前节点的边 j = topo.index(node) # 逆邻接点的下标 if vl[j] &gt; vl[i] - w: # 更新逆邻接点的最晚发生时间，选小的时间 vl[j] = vl[i] - w pass # --------------------------------判断每一活动是否为关键路径-------------------------- for i in range(topo.__len__()): start = topo[i] for node in self.get_outEdge(start).keys(): j = topo.index(node) # 获得邻接顶点的下标 w = self._graph[start][node] # 当前节点与邻接节点的边 e = ve[i] # 计算活动&lt;start,node&gt;的最早开始时间 l = vl[j] - w - delay # 计算活动&lt;start,node&gt;的最晚开始时间 if e == l: cp.append((start, node)) # 如果相等就说明为关键路径 pass for i in range(topo.__len__()): result[topo[i]] = (ve[i], vl[i]) pass return result, cp 测试graph LR V0((V0)) V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V7((V7)) V8((V8)) V0--6-->V1 V0--4-->V2 V0--5-->V3 V1--1-->V4 V2--1-->V4 V3--2-->V5 V4--9-->V6 V4--7-->V7 V5--4-->V7 V6--2-->V8 V7--4-->V8]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python, 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序及实现]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[拓扑排序算法原理拓扑排序是有向图（网）中的内容，只在有向网（图）的范畴中讨论。先看一个实际生活中可能遇到的问题：选课问题，例如上大一的时候你肯定要先学C语言，然后才能学数据结构。这个时候C语言和数据结构就构成了一个排列问题，谁在前谁在后。用图中的顶点表示一个活动，边表示活动之间的顺序关系。这样的图就称为AOV网（顶点活动网） 下图就是一个典型的AOV网实例。 任何无回路的AOV网N都可以求解出拓扑序列，方法很简单： 从N中选出一个入度为0的顶点作为序列的下一个顶点 从N网中删除所选顶点的出边 重复执行上面两步，直到已经选出了图N的所有顶点 拓扑排序算法有两个难点： 如何寻找入度为0的顶点 真的需要拷贝整张图，然后进行删除 一个显然的办法是不断遍历图，寻找入度为0的顶点。但时间代价会很高。顶点间的制约关系决定了顶点的入度。入度是一个整数，用一个整数表就能记录所以顶点的入度了。因此，我的方法是用一张入度表记录了每个顶点的入度，初始时，表中的各顶点的入度对应为图中顶点的入度，在随后的计算中，一旦选中一个顶点，就将该顶点的出边入度减一。 在实际的算法实现中还用了一个0度栈来记录已经入度为0但还未处理的顶点。 算法比较简单。 可以慢慢调试 算法实现123456789101112131415161718192021222324def topological_sort(self): indegree = &#123;&#125; # 入度表 zerov = [] # 利用0度栈记录已知的入度为0的但还未处理的顶点 m = 0 # 输出顶点计数 topo = [] # 拓扑排序结果 # 生成入度表和0度栈 for vetx in self._graph: indegree[vetx] = self.get_inEdge(vetx).__len__() if indegree[vetx] == 0: zerov.append(vetx) pass while zerov.__len__() != 0: Vi = zerov.pop() topo.append(Vi) m += 1 for Vj in self.get_outEdge(Vi).keys(): # 对顶点Vi的每个邻接点入度减1，如果Vj的入度变为0，则将Vj入栈，表示Vj就是下一个需要处理的顶点 indegree[Vj] -= 1 if indegree[Vj] == 0: zerov.append(Vj) if m &lt; self.get_vertexNum(): # 该有向图有回路 return False return topo 测试]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径:迪杰斯特拉算法实现]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最短路径dijkstra算法算法原理在看迪杰斯特拉算法之前，可以先回顾下BFS算法的过程。BFS的实现是通过一个队列实现。还是这张图选择假设BFS从A节点开始，A节点出队后，将A的邻接节点B,C入队然后B出队，D入队，C出队，E入队。整个BFS的流程大概如此，在这之中，可以看到BFS队列中不同节点离A的距离，每个出队的结点对于他的邻接节点的距离都是1，并且在队列中他们也是紧紧挨着的。 假如可以把这些顶点进行排序，然后不断更新队中节点到A的距离值，那么应该可以一步步的获得当前节点到A节点的最短距离了。 该算法有两个难点： 如何排序 我使用的是python的优先队列，该队列是基于堆这一种数据结构实现的，你也可以自行选择排序算法进行排序 如何更新距离 在BFS中每个节点到A的距离是固定的，是不会发生更新操作的，这是由于BFS算法实现过程中有个访问标志会标志某个节点是否已被访问，该标志保证了每个节点只访问一次。但是在迪杰斯特拉算法中，这样是不行的，因为想要在每个节点出队后，都要将该结点的邻接节点到目标点（这个例子中是A点）的距离进行比较更新，选择权值和小的。 看下面这个网 当遍历到B的时候A到B有两条路，一条是A-B，另一条是A-C-B，前者的距离为5，比较长，后者的距离为3（1+2）。在迪杰斯特拉中就会选择路径A-C-B这条路径。 在实际的算法实现中，距离的比较是通过一个distance的列表实现的，该列表距离了每个顶点到目标点的最短距离。然后在下一次遍历中不断得更新这个距离就可以了。 构造过程举例假设还是上面这个图。 要求图中顶点到A的最短距离 初始化初始化距离列表,inf 表示无穷，A的目标点，所以距离为0 graph TB A[A,0] B[B,inf] C[C,inf] D[D,inf] E[E,inf] F[F,inf] 初始化优先级队列，目标节点A入队 graph TB A((A,0)) 当队列不为空时，循环。 第一次构造 A出队,并标记为已访问，遍历A的邻接节点B、C，同时将A到B的距离5(0+5)和A到C的距离1(0+1)，与distance列表中的距离进行比较，由于distance中的距离都是无穷，所以distance中C的距离更新为1，B的距离更新为5 graph TB A[A,0] B[B,5] C[C,1] D[D,inf] E[E,inf] F[F,inf] B,C节点由于距离被更新了。需要参与下一次比较，所以B、C入队 graph LR B((B,5)) C((C,1)) C-->B 第二次构造 C出队，并标记为已访问，遍历C的邻接节点A,B,D,E，将C-A的距离1，C-B的距离3(1+2)和C-D的距离5(1+4)和C-E的距离9（1+8），与distance列表中的B,C,E的距离进行比较，更新为其中的较小值 graph TB A[A,0] B[B,3] C[C,1] D[D,5] E[E,9] F[F,inf] 由于B,D,E的距离被更新了。需要参与下一次的比较，所以B,C,E需要入队，带着他们的更新后的权值 graph LR B((B,5)) B1((B,3)) D((D,5)) E((E,9)) B1-->B B-->D D-->E 第三次构造 B出队，并标记为已访问，遍历B的子节点D,C,A，将B-D（3+1=4）,B-C（3+2=5）,B-A（3+5）的距离分别与distance中的D,C,A距离进行比较，取小的值，发现只有D的距离被更新为了4 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,9] F[F,inf] 由于D被更新了，需要参与下一次的比较，所以D入队，带着D更新后的权值 graph LR D1((D,4)) B((B,5)) D((D,5)) E((E,9)) D1-->B B-->D D-->E 第四次构造 D出队，并标记为已访问，遍历D的子节点B,C,E,F。将D-B（4+1=5）,D-C（4+4=8）,D-E(4+3=7),D-F(4+6=10)的距离分别与distance中的B,C,E,F距离进行比较，取小的值 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 由于只有E,F的距离被更新为7,和10，所以E，F需要带着他们更新后的权值入队，参与下一次的比较。 graph LR B((B,5)) D((D,5)) E1((E,7)) E((E,9)) F((F,10)) B-->D D-->E1 E1-->E E-->F 第五次构造 队首B出队，由于B被标记已访问，所以直接扔掉，进入下一个循环 graph LR D((D,5)) E1((E,7)) E((E,9)) F((F,10)) D-->E1 E1-->E E-->F 队首D出队，由于D已经被标记已访问，扔掉。进入下一个循环 graph LR E1((E,7)) E((E,9)) F((F,10)) E1-->E E-->F 队首E出队，标记为已访问。遍历其邻接节点C,D，将E-C（7+4=11），E-D（7+3=10）与distance中的C,D值进行比较，取小的值，发现C,D都不需要更新。 由于没有节点被更新，所以没有节点入队。此时的distance如下图 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 第六次构造 队首E出队，由于E被标记为已访问，扔掉，进入下一个循环 graph LR E((E,9)) F((F,10)) E-->F 队首E出队，由于E被标记为已访问，扔掉，进入下一个循环 graph LR F((F,10)) 队首F出队,发现他没有子节点，所以distance不会被更新，队列将不会加入新的结点。此时的distance如下图 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 第七次构造由于此时队列为空，所以循环结束，迪杰斯特拉算法求解完毕！此时的distance就是每个节点到目标点A的最短距离了。 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 迪杰斯特拉算法就是基于这种”宽度优先遍历”的思想，按路径的长度选择下一个最短节点然后逐步扩张（这一点也很像用MST性质实现的prim算法）。这个算法在探索中也会更新已经节点的最短路径，每一步都可以找到一个确定的最短路径，这就是典型的动态规划思想（在计算中保留一些信息，用来支持下一步的决策信息） 算法实现1234567891011121314151617181920212223242526# 迪杰斯特拉法算最短路径def dijkstra(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") graph = self._graph pqueue = [] # 优先级队列 heapq.heappush(pqueue, (0, start)) # 根顶点进队，最高优先级 seen = set() # 记录访问过的顶点 parent = &#123;start: None&#125; # 生成树 distance = self.__init_distance(start) # 初始化距离 while pqueue.__len__() &gt; 0: pair = heapq.heappop(pqueue) # pop弹出的是元组，第一个参数是距离（优先级），第二个是顶点 dist = pair[0] vertex = pair[1] seen.add(vertex) # 记录访问过的顶点 nodes = graph[vertex].keys() # 获取其顶点的邻接顶点 for node in nodes: if node not in seen: if dist + graph[vertex][node] &lt; distance[node]: # 如果当前顶点到开始顶点的距离小于距离列表中的值，更新距离 heapq.heappush(pqueue, (dist + graph[vertex][node], node)) parent[node] = vertex distance[node] = dist + graph[vertex][node] # 输出遍历结果 # print(vertex) return distance, parent pass 测试 可以发现，如刚才推导的结果一模一样。 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10]]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树:克鲁斯卡尔算法实现]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[克鲁斯卡尔算法算法原理及流程原理在一个连通图中不断选取权值最小的边，然后连起来，就是这样。假设给定图G，结果图T基本步骤如下： 将G中的所有边按权值递增的顺序进行排序 选择权值最短的边且边的两端点属于不同连通分量（如果两端点属于同一个连通分量中，那么就说明该子图是连通图！所以不行），然后该边与T中已选择的边进行连接，每次边连接都会使得T的连通分量减1 当边数小于顶点数时，不断重复1,2 如果当做完上面这些步骤后，得出的结果T中不能包含G中的所有顶点，则说明原图G是不连通的（也就是不是任意一个节点到另一个节点都走的通） 这里有两个难点： 最短边的选取 思路①：采用优先队列，在python中可以通过优先级队列实现，其他语言像C++,Java中也有类似实现的数据结构。 思路②：不断的扫描候选边列表，然后进行排序。这种方法就比较麻烦了，写的代码比较多，不过也很灵活，具体排序方式你可以选择。 如何判断边的两个端点的连通分量 思路①：不断的检查两个端点之间是否有路径，有路径就说明在同一个子图中，连通分量相同。不过这样也太麻烦了点还浪费计算时间 思路②：前人提出的一种方法，为每个连通分量确定一个代表元，如果两个顶点的代表元相同，则表示他们连通成环。例如下图 graph TD V1((v1)) V2((V2)) V3((V3)) V4((V4)) 当初始化的时候v1,v2,v3,v4的代表元就是他们的序号也就对应0,1,2,3 当v1 v2 构成新边的时候，就要把v2的代表元改为v1 的代表元0 。 这时候v1,v2,v3,v4的代表元就更新为0,0,2,3 graph TD V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 v1 v2是的连通分量相同并且他们的代表元也是相同的。 类似，如果想要连接v2 v3，此时v2 v3 的代表元不同，因此连接了也不会构成环。 直接把v3的代表元修改为v2的代表元即可，即0 graph LR V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 V2---V3 此时v1 v2 v3是连通的，他们的代表元是0,0,0 如果下一次操作中，想要把v3 连接到v1 ，检查他们的代表元，都是0所以连接起来一定会构成环 graph LR V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 V2---V3 V3---V1 因此，可以使用代表元判断欲加入的边是否会与已选择集合T中的边构成环路。 构成过程举例假设还是之前的这颗图G，其结果集T中目前还为空 graph RL V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V1--6---V2 V1--1---V3 V1--5---V4 V2--5---V3 V3--5---V4 V3--6---V5 V3--4---V6 初始化全部边入队，自动在优先队列中根据权值排好序 graph LR v46((v4,v6,2)) v56((V5,V6,6)) v32((v2,v3,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v13((v1,v3,1)) v13---v46 v46---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 并且初始化代表元列表，初始值为他们的下标。 例如v1的代表元初始值为1，v2的代表元初始值为2….vn的代表元初始值为n graph BT v1[v1,1] v2[v2,2] v3[v3,3] v4[v4,4] v5[v5,5] v6[v6,6] 第一次构造 队首出队，所以&lt;v1,v3&gt;边出队 graph LR v64((v6,v4,2)) v65((V6,V5,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v13((v1,v3,1)) v13---v64 v64---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v65 检查v1 v3的代表元，很明显不同,所以将&lt;v1,v3&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V1--1---V3 合并代表元,修改等于代表元值为3的代表元的值，改为v1的代表元即1 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,5] v6[v6,6] 第二次构造 队首出队，所以&lt;v4,v6&gt;边出队 graph LR v46((v4,v6,2)) v56((V5,V6,6)) v32((v2,v3,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v46---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v4 v6的代表元，很明显不同,所以将&lt;v4,v6&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V6--2---V4 合并代表元,修改等于代表元值为6的代表元的值，改为v4的代表元的值即4 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,5] v6[v6,4] 第三次构造 队首出队，所以&lt;v2,v5&gt;边出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v2 v5的代表元，很明显不同,所以将&lt;v2,v5&gt;加入T集合中 graph TD V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 合并代表元,修改等于代表元值为5的代表元的值，改为v2的代表元的值即2 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,2] v6[v6,4] 第三次构造 队首&lt;v3,v6&gt;出队 graph LR v56((v5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v14((v1,v4,5)) v12((v1,v2,6)) v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v3 v6的代表元，不同,所以将&lt;v3,v6&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 合并代表元,修改等于代表元值为4的代表元的值，改为v3代表元的值即1 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第四次构造 队首&lt;v1,v4&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v14((v1,v4,5)) v12((v1,v2,6)) v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v1 v4的代表元，相同,所以不将&lt;v1,v4&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 此时代表元不进行任何操作 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第五次构造 队首&lt;v3,v4&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v12((v1,v2,6)) v34---v32 v32---v12 v12---v35 v35---v56 检查v3 v4的代表元，相同，所以不将&lt;v3,v4&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 此时代表元不进行任何操作 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第六次构造 &lt;v2,v3&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v35((v3,v5,6)) v12((v1,v2,6)) v32---v12 v12---v35 v35---v56 检查v2 v3的代表元，不同，所以将&lt;v2,v3&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 V3--5---V2 合并代表元,修改等于代表元为2的代表元的值，改为v3代表元的值即1 graph BT v1[v1,1] v2[v2,1] v3[v3,1] v4[v4,1] v5[v5,1] v6[v6,1] 可以发现，当前T集合中已经有5条边了，最小生成树已经生成完毕。同时观察到，代表元中的值也相同了，表示他们都在同一个子图中了。 算法实现1234567891011121314151617181920212223242526272829303132# kruskal算法，最小生成树，前提该图必须是连通网def kruskal(self): # 初始化代表元和结果图 result, reps, pqueue, edgesCount = GraphAL(graph=&#123;&#125;), &#123;&#125;, [], 0 for key in self._graph.keys(): reps[key] = key # 边入队，按优先级排序,选出最短边 for key in self._graph: for end in self._graph[key].keys(): edges = self._graph[key][end] heapq.heappush(pqueue, (edges, key, end)) # 边入队 pass # 当边数达到n-1条时，即成功得到最小生成树时停止 while edgesCount &lt; self.get_vertexNum() - 1 and not pqueue.__len__() == 0: # 出队 pair = list(heapq.heappop(pqueue)) # 判断是否有该顶点,如果没有就要加入 if pair[1] not in result._graph: result.add_vertex(pair[1]) if pair[2] not in result._graph: result.add_vertex(pair[2]) # 检查两点是否属于不同连通分量 if reps[pair[1]] != reps[pair[2]]: result.add_edge(pair[1], pair[2], pair[0]) edgesCount += 1 # 合并连通分量 rep, orep = reps[pair[1]], reps[pair[2]] for key in reps.keys(): if reps[key] == orep: reps[key] = rep return result pass 测试 与刚才结果自动推的完全一致。 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 V3--5---V2]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树:Prim算法实现]]></title>
    <url>%2F2019%2F09%2F03%2F%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Prim算法算法原理及算法流程原理根据（MST性质：网络G必有一颗最小生成树），具体证明不再赘述，大概思想就是假设你现有一个图的集合G，从G中的一个顶点出发，不断的选择最短的一条连接边，扩充到已选边集N中，直至N包含了图G中的所有顶点。构造过程举例假设现在有这样一颗图第一次构造V1的邻接节点全部入队。并且由于该队列是优先级队列，会按照权重排序 graph LR V13((v1,v3,1)) V14((v1,v4,5)) V12((v1,v2,6)) V13-->V14 V14-->V12 队首出队，构造边，将该边加入到N集 此时N集中就有了一条边了 graph TB V1((v1)) V3((V3)) V1--1---V3 V3除了N集中的结点的邻接节点入队，优先队列会按照权重进行排序 graph LR V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V36((v3,v6,4)) V14((v1,v4,5)) V12((v1,v2,6)) V36-->V14 V14-->V32 V32-->V34 V34-->V12 V12-->V35 第二次构造队首出队，构造边，将该边加入到N集 此时N集有两条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V1--1---V3 V3--4---V6 将V6的除N集中已有的邻接节点入队， graph LR V64((v6,v4,2)) V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V14((v1,v4,5)) V12((v1,v2,6)) V64-->V14 V14-->V32 V32-->V34 V34-->V12 V12-->V35 V35-->V65 第三次构造队首出队，构造边，将该边&lt;6,4&gt;加入到N集 此时的N集就有三条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 将V4的除N集中已有的邻接节点入队,发现v4的邻接顶点都在N集中了，所以没有顶点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V14((v1,v4,5)) V12((v1,v2,6)) V14-->V32 V32-->V34 V34-->V12 V12-->V35 V35-->V65 第四次构造队首&lt;v1,v4&gt;出队，构造边，将该边&lt;v1,v4&gt;加入到N集，注意此时由于&lt;v1,v4&gt;加入N集中会构成连通，所以跳过本次构造边。 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 V1--5---V4 所以，当前N集中的边还是和原来一样，如下图： graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 将V4的除N集中已有的邻接节点入队,发现v4的邻接顶点都在N集中了，所以没有顶点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V12((v1,v2,6)) V32-->V34 V34-->V12 V12-->V35 V35-->V65 第五次构造队首&lt;v3,v2&gt;出队，构造边，将该边加入到N集中。 此时N集就有五条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 将V2的除N集中已有的邻接节点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V12((v1,v2,6)) V25((V2,V5,3)) V32-->V34 V34-->V12 V12-->V35 V35-->V65 V25-->V32 第六次构造队首&lt;v2,v5&gt;出队，构造边，加入边到N集中。此时N集中有5条边。由于总共就6个顶点，当构成最小生成树的时候边只能是5条，你如果在加一条边就连通了，所以prim构造生成树结束 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 最终结果graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 算法实现1234567891011121314151617181920212223242526272829303132333435363738# prim算法，最小生成树，前提该图必须是连通网 def prim(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") result = GraphAL(&#123;&#125;) edgeCount = 0 pqueue = [] # 优先级队列,候选列表 # 初始化优先级队列 for node in self._graph[start]: heapq.heappush(pqueue, (self._graph[start][node], start, node)) pass while edgeCount &lt; self.get_vertexNum() - 1 and not pqueue.__len__() == 0: # 出队 pair = heapq.heappop(pqueue) distance = pair[0] start = pair[1] end = pair[2] # 判断是否有该顶点,如果没有就要加入 if start not in result._graph: result.add_vertex(start) if end not in result._graph: result.add_vertex(end) # 如果当前点与下一节点未建立边，则尝试建立边 # 方式是检查下一节点是否在result中，如果有则说明这个节点已经建立过边了，再建立边的话会可能会形成连通，因此直接舍弃该边的建立 if end not in result._graph[start]: # 如果下一个节点如果未被其他节点连接则result._graph[end]返回false，开始构造边， # 如果下一个节点已经被连接了，则result._graph[end]返回true，舍弃该边的建立 if not result._graph[end]: result.add_edge(start, end, distance) edgeCount += 1 pass start = end # 子节点入队 for node in self._graph[start]: if node not in result._graph: heapq.heappush(pqueue, (self._graph[start][node], start, node)) pass return result 测试 与刚才流程构造的结果一致 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 #####]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的遍历:BFS和DFS]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-BFS%E5%92%8CDFS%2F</url>
    <content type="text"><![CDATA[图的遍历BFS（广度优先搜索）算法原理及步骤按照广度优先原则遍历图，利用了队列，有点像树的层次遍历。广度优先遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入队 顶点出队，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入队 当队列不为空的时候，循环1,2步 算法流程 算法实现123456789101112131415161718# 广度优先遍历def bfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") queue = [start] # 队列实现BFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while queue.__len__() &gt; 0: # 队非空时 vertex = queue.pop(0) # 队首顶点出队 nodes = self._graph[vertex] # 获得其邻接顶点 for node in nodes: if node not in seen: queue.append(node) # 其邻接顶点如果没有被访问，则入队，并且保留父顶点 seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 具体的存储结构为： 12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 1234567def test_bfs(self): print("bfs测试：") bfs, bfsparent = TestGraph.g.bfs("A") print("BFS:" + graph.GraphAL.printPath(bfs)) print("BFS生成路径:" + bfsparent.__str__()) print("BFS生成路径打印：" + graph.GraphAL.printTreePath(bfsparent).__str__()) pass DFS（深度优先搜索）算法原理及步骤DFS和BFS很像，不过DFS是深度优先的原则，具体实现是栈。 DFS遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入栈 顶点出栈，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入栈 当栈不为空的时候，循环1,2步 算法实现123456789101112131415161718# 深度优先遍历def dfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") stack = [start] # 栈实现DFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while stack.__len__() &gt; 0: # 栈非空时 vertex = stack.pop() # 顶点出栈 nodes = self._graph[vertex] # 获取出栈顶点的邻接顶点 for node in nodes: if node not in seen: stack.append(node) seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 存储结构12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 测试结果```python图的结构为：(‘A’, {‘B’: 5, ‘C’: 1})(‘B’, {‘A’: 5, ‘C’: 2, ‘D’: 1})(‘C’, {‘A’: 1, ‘B’: 2, ‘D’: 4, ‘E’: 8})(‘D’, {‘B’: 1, ‘C’: 4, ‘E’: 3, ‘F’: 6})(‘E’, {‘C’: 8, ‘D’: 3})(‘F’, {‘D’: 6}) dfs测试：DFS:A-&gt;C-&gt;E-&gt;D-&gt;F-&gt;BDFS生成路径:{‘A’: None, ‘B’: ‘A’, ‘C’: ‘A’, ‘D’: ‘C’, ‘E’: ‘C’, ‘F’: ‘D’}DFS生成路径打印：A-&gt;BA-&gt;CA-&gt;C-&gt;DA-&gt;C-&gt;EA-&gt;C-&gt;D-&gt;F```st=>start: 初始化队列，初始顶点入队 e=>end: 结束BFS deque=>operation: 出队 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否队空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 初始化栈，初始顶点进栈 e=>end: 结束DFS deque=>operation: 出栈 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否栈空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的存储结构实现：邻接表]]></title>
    <url>%2F2019%2F09%2F02%2F%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0%EF%BC%9A%E9%82%BB%E6%8E%A5%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[邻接表实现数据格式如图所示：12345678graph = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 如上图所示，该类是一个无向网，如果需要改成有向网，只需要更改add_edge这个方法 新建一个GraphAL.py文件，在文件中添加： 12345678910111213141516171819202122232425262728293031323334# 邻接表实现无向网（图）（字典形式）class GraphAL: def __init__(self, graph=&#123;&#125;): self._graph = graph self._vnum = len(graph) def _invalid(self, vertex): return self._graph.__contains__(vertex) def add_vertex(self, vertex): if self._invalid(vertex): raise GraphError("添加顶点失败，已经有该顶点") self._graph[vertex] = &#123;&#125; self._vnum += 1 def add_edge(self, vi, vj, val): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") self._graph[vi].update(&#123;vj: val&#125;) self._graph[vj].update(&#123;vi: val&#125;) def get_edge(self, vi, vj): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") return self._graph[vi][vj] def get_vertexNum(self): return self._graph.__len__() # 在无向网（图）中是边，有向网（图）是出边，取决于数据 def out_edge(self, vertex): if not self._invalid(vertex): raise GraphError("不存在" + vertex + "这样的顶点") return self._graph[vertex] 你也可以不传入图的参数，会默认创建一个新图。通过add_vertex和add_edge即可完成图的构建。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Python的图算法实现]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E5%9B%BE%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言本来是想用C语言好好写的，可是指针和结构体太烦人了，弄得我头凉。因此决定用python实现一下图的一些算法。远程仓库地址：https://github.com/XiaoZhong233/DataStructure_Python/tree/master/graph图的存储结构实现图的实现有邻接矩阵，邻接表，十字链表等。我后面的算法主要用邻接表 建议直接看 [邻接表实现2，基于字典实现](# 邻接表实现2 (基于字典实现，好用)) 首先定义了一个异常类： 12class GraphError(Exception): pass 邻接矩阵实现（不重要也不好用）基于邻接矩阵定义了一个实现图的类，其中矩阵元素可以是1或者其他权值，表示有边，或者用一个特殊值表示“无关联”。构造参数的unconn就是表示无关联的值，默认为0。 图的构造函数的主要参数是mat,表示初始的邻接矩阵。要求是一个二维数组，且为方阵。代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# unconn 无关联参数# 邻接矩阵实现class Graph: def __init__(self, mat, unconn=0): vnum = len(mat) # 检查是否为方阵 for x in mat: if len(x) != vnum: raise ValueError("参数错误：不为方阵") # 拷贝数据 self._mat = [mat[i][:] for i in range(vnum)] self._unconn = unconn self._vnum = vnum # 返回顶点数目 def vertex_num(self): return self._vnum # 检查该顶点是否合法，也就是下标是否找得到 def _invalid(self, v): return v &lt; 0 or v &gt;= self._vnum # 加入新的顶点 def add_vertex(self): raise GraphError("邻接矩阵不支持加入顶点") # 加入新的边 def add_edge(self, vi, vj, val=1): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") self._mat[vi][vj] = val # 获得某条边 def get_edge(self, vi, vj): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") return self._mat[vi][vj] # 获得某个顶点的出边 def out_edges(self, vi): if self._invalid(vi): raise GraphError("顶点不合法") return self.out_edge(self._mat[vi], self._unconn) # 获得某个顶点的出边 @staticmethod def _out_edges(row, unconn): edges = [] for i in range(len(row)): if row[i] != unconn: edges.append((i, row[i])) return edges def __str__(self): return "[\n" + ",\n".join(map(str, self._mat)) + "\n]" \ + "\nUnconnected: " + str(self._unconn) 这个简单的邻接矩阵实现的图类并未支持增加顶点，因为邻接矩阵增加顶点要增加多一行一列，挺麻烦的，就不想写了。 邻接表实现1（基于邻接矩阵，不好用）邻接矩阵的缺点是占用空间很多，如果是稀疏图就很难受了，可能会有很大的空间损失，因此常用邻接表实现图的存储。在上面邻接矩阵的实现下，可考虑一种“压缩后”的邻接表实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# 邻接表实现（压缩邻接矩阵形式）class GraphAL(Graph): def __init__(self, mat=[], unconn=0): vnum = len(mat) for x in mat: if len(x) != vnum: raise ValueError("参数错误：不为方阵") self._mat = [Graph._out_edges(mat[i], unconn) for i in range(vnum)] self._vnum = vnum self._unconn = unconn def add_vertex(self): self._mat.append([]) self._vnum += 1 return self._vnum - 1 def add_edge(self, vi, vj, val=1): if self._vnum == 0: raise GraphError("无法为空图增加边") if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") row = self._mat[vi] i = 0 while i &lt; len(row): if row[i][0] == vj: self._mat[vi][i] = (vj, val) return if row[i][0] &gt; vj: # 没有到与vj的边，退出循环加入边 break i += 1 self._mat[vi].insert(i, (vj, val)) def get_edge(self, vi, vj): if self._invalid(vi) or self._invalid(vj): raise GraphError("顶点不合法") for i, val in self._mat[vi]: if i == vj: return val return self._unconn def out_edges(self, vi): if self._invalid(vi): raise GraphError("顶点不合法") return self._mat[vi] 邻接表实现2 (基于字典实现，好用) 数据格式如图所示： 12345678graph = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 如上图所示，该类是一个无向网，如果需要改成有向网，只需要更改add_edge这个方法 新建一个GraphAL.py文件，在文件中添加： 12345678910111213141516171819202122232425262728293031323334# 邻接表实现无向网（图）（字典形式）class GraphAL: def __init__(self, graph=&#123;&#125;): self._graph = graph self._vnum = len(graph) def _invalid(self, vertex): return self._graph.__contains__(vertex) def add_vertex(self, vertex): if self._invalid(vertex): raise GraphError("添加顶点失败，已经有该顶点") self._graph[vertex] = &#123;&#125; self._vnum += 1 def add_edge(self, vi, vj, val): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") self._graph[vi].update(&#123;vj: val&#125;) self._graph[vj].update(&#123;vi: val&#125;) def get_edge(self, vi, vj): if not self._invalid(vi) or not self._invalid(vj): raise GraphError("不存在" + vi + "或者" + vj + "这样的顶点") return self._graph[vi][vj] def get_vertexNum(self): return self._graph.__len__() # 在无向网（图）中是边，有向网（图）是出边，取决于数据 def out_edge(self, vertex): if not self._invalid(vertex): raise GraphError("不存在" + vertex + "这样的顶点") return self._graph[vertex] 你也可以不传入图的参数，会默认创建一个新图。通过add_vertex和add_edge即可完成图的构建。 图的一些算法实现图的遍历BFS（广度优先搜索）算法原理及步骤按照广度优先原则遍历图，利用了队列，有点像树的层次遍历。广度优先遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入队 顶点出队，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入队 当队列不为空的时候，循环1,2步 算法流程graph LR start(起始点入队) deque[出队] isVisit{未被访问?} visit(访问该结点并输出) isnull[检查队空] end1((结束)) start-->deque deque-->isVisit isVisit--未被访问-->visit isVisit--已经被访问-->deque isnull-->end1 visit-->isnull isnull--不为空-->deque 算法实现123456789101112131415161718# 广度优先遍历def bfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") queue = [start] # 队列实现BFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while queue.__len__() &gt; 0: # 队非空时 vertex = queue.pop(0) # 队首顶点出队 nodes = self._graph[vertex] # 获得其邻接顶点 for node in nodes: if node not in seen: queue.append(node) # 其邻接顶点如果没有被访问，则入队，并且保留父顶点 seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 具体的存储结构为： 12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 1234567def test_bfs(self): print("bfs测试：") bfs, bfsparent = TestGraph.g.bfs("A") print("BFS:" + graph.GraphAL.printPath(bfs)) print("BFS生成路径:" + bfsparent.__str__()) print("BFS生成路径打印：" + graph.GraphAL.printTreePath(bfsparent).__str__()) pass DFS（深度优先搜索）算法原理及步骤DFS和BFS很像，不过DFS是深度优先的原则，具体实现是栈。 DFS遍历的结果不唯一。整个遍历过程大概是这样的：给定一个起始顶点，将该起始顶点入栈 顶点出栈，如果当前顶点未被标记访问，则访问该顶点，然后标记为已访问，如果当前顶点已访问则直接丢弃该顶点 当前访问顶点的邻接顶点入栈 当栈不为空的时候，循环1,2步 算法流程graph LR start(起始点入栈) deque[出栈] isVisit{未被访问?} visit(访问该结点并输出) isnull[检查栈空] end1((结束)) start-->deque deque-->isVisit isVisit--未被访问-->visit isVisit--已经被访问-->deque isnull-->end1 visit-->isnull isnull--不为空-->deque 算法实现123456789101112131415161718# 深度优先遍历def dfs(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") stack = [start] # 栈实现DFS seen = set(start) # 记录访问过的顶点 parent = &#123;start: None&#125; # Node代表根节点，数组形式保存树 result = [] while stack.__len__() &gt; 0: # 栈非空时 vertex = stack.pop() # 顶点出栈 nodes = self._graph[vertex] # 获取出栈顶点的邻接顶点 for node in nodes: if node not in seen: stack.append(node) seen.add(node) parent[node] = vertex result.append(vertex) return result, parent 测试例如遍历下图 存储结构12345678data = &#123; "A": &#123;"B": 5, "C": 1&#125;, "B": &#123;"A": 5, "C": 2, "D": 1&#125;, "C": &#123;"A": 1, "B": 2, "D": 4, "E": 8&#125;, "D": &#123;"B": 1, "C": 4, "E": 3, "F": 6&#125;, "E": &#123;"C": 8, "D": 3&#125;, "F": &#123;"D": 6&#125;,&#125; 测试结果1234567891011121314151617图的结构为：('A', &#123;'B': 5, 'C': 1&#125;)('B', &#123;'A': 5, 'C': 2, 'D': 1&#125;)('C', &#123;'A': 1, 'B': 2, 'D': 4, 'E': 8&#125;)('D', &#123;'B': 1, 'C': 4, 'E': 3, 'F': 6&#125;)('E', &#123;'C': 8, 'D': 3&#125;)('F', &#123;'D': 6&#125;)dfs测试：DFS:A-&gt;C-&gt;E-&gt;D-&gt;F-&gt;BDFS生成路径:&#123;'A': None, 'B': 'A', 'C': 'A', 'D': 'C', 'E': 'C', 'F': 'D'&#125;DFS生成路径打印：A-&gt;BA-&gt;CA-&gt;C-&gt;DA-&gt;C-&gt;EA-&gt;C-&gt;D-&gt;F 最小生成树最小生成树针对的是连通网而言的。假定一个网络G，他的边带有权值，自然可以通过BFS,DFS获得他的生成树，权值最小的那棵树，就称最小生成树 最小生成树有许多实际的应用，例如通信网，输电网及各种网的规划。 Prim算法算法原理及算法流程原理：根据（MST性质：网络G必有一颗最小生成树），具体证明不再赘述，大概思想就是假设你现有一个图的集合G，从G中的一个顶点出发，不断的选择最短的一条连接边，扩充到已选边集N中，直至N包含了图G中的所有顶点。 构造过程举例假设现在有这样一颗图 graph RL V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V1--6---V2 V1--1---V3 V1--5---V4 V2--5---V3 V3--5---V4 V3--6---V5 V3--4---V6 要对该图进行prim算法进行最小生成树。首先找一个开始顶点，假设从V1开始 第一次构造V1的邻接节点全部入队。并且由于该队列是优先级队列，会按照权重排序 graph LR V13((v1,v3,1)) V14((v1,v4,5)) V12((v1,v2,6)) V13-->V14 V14-->V12 队首出队，构造边，将该边加入到N集 此时N集中就有了一条边了 graph TB V1((v1)) V3((V3)) V1--1---V3 V3除了N集中的结点的邻接节点入队，优先队列会按照权重进行排序 graph LR V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V36((v3,v6,4)) V14((v1,v4,5)) V12((v1,v2,6)) V36-->V14 V14-->V32 V32-->V34 V34-->V12 V12-->V35 第二次构造队首出队，构造边，将该边加入到N集 此时N集有两条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V1--1---V3 V3--4---V6 将V6的除N集中已有的邻接节点入队， graph LR V64((v6,v4,2)) V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V14((v1,v4,5)) V12((v1,v2,6)) V64-->V14 V14-->V32 V32-->V34 V34-->V12 V12-->V35 V35-->V65 第三次构造队首出队，构造边，将该边&lt;6,4&gt;加入到N集 此时的N集就有三条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 将V4的除N集中已有的邻接节点入队,发现v4的邻接顶点都在N集中了，所以没有顶点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V14((v1,v4,5)) V12((v1,v2,6)) V14-->V32 V32-->V34 V34-->V12 V12-->V35 V35-->V65 第四次构造队首&lt;v1,v4&gt;出队，构造边，将该边&lt;v1,v4&gt;加入到N集，注意此时由于&lt;v1,v4&gt;加入N集中会构成连通，所以跳过本次构造边。 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 V1--5---V4 所以，当前N集中的边还是和原来一样，如下图： graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V3--4---V6 V6--2---V4 将V4的除N集中已有的邻接节点入队,发现v4的邻接顶点都在N集中了，所以没有顶点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V12((v1,v2,6)) V32-->V34 V34-->V12 V12-->V35 V35-->V65 第五次构造队首&lt;v3,v2&gt;出队，构造边，将该边加入到N集中。 此时N集就有五条边了 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 将V2的除N集中已有的邻接节点入队 graph LR V65((V6,V5,6)) V32((v3,v2,5)) V34((v3,v4,5)) V35((v3,v5,6)) V12((v1,v2,6)) V25((V2,V5,3)) V32-->V34 V34-->V12 V12-->V35 V35-->V65 V25-->V32 第六次构造队首&lt;v2,v5&gt;出队，构造边，加入边到N集中。此时N集中有5条边。由于总共就6个顶点，当构成最小生成树的时候边只能是5条，你如果在加一条边就连通了，所以prim构造生成树结束 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 最终结果graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 算法实现1234567891011121314151617181920212223242526272829303132333435363738# prim算法，最小生成树，前提该图必须是连通网 def prim(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") result = GraphAL(&#123;&#125;) edgeCount = 0 pqueue = [] # 优先级队列,候选列表 # 初始化优先级队列 for node in self._graph[start]: heapq.heappush(pqueue, (self._graph[start][node], start, node)) pass while edgeCount &lt; self.get_vertexNum() - 1 and not pqueue.__len__() == 0: # 出队 pair = heapq.heappop(pqueue) distance = pair[0] start = pair[1] end = pair[2] # 判断是否有该顶点,如果没有就要加入 if start not in result._graph: result.add_vertex(start) if end not in result._graph: result.add_vertex(end) # 如果当前点与下一节点未建立边，则尝试建立边 # 方式是检查下一节点是否在result中，如果有则说明这个节点已经建立过边了，再建立边的话会可能会形成连通，因此直接舍弃该边的建立 if end not in result._graph[start]: # 如果下一个节点如果未被其他节点连接则result._graph[end]返回false，开始构造边， # 如果下一个节点已经被连接了，则result._graph[end]返回true，舍弃该边的建立 if not result._graph[end]: result.add_edge(start, end, distance) edgeCount += 1 pass start = end # 子节点入队 for node in self._graph[start]: if node not in result._graph: heapq.heappush(pqueue, (self._graph[start][node], start, node)) pass return result 测试 与刚才流程构造的结果一致 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V3--4---V6 V6--2---V4 V3--5---V2 V2--3---V5 克鲁斯卡尔算法算法原理及流程原理在一个连通图中不断选取权值最小的边，然后连起来，就是这样。 假设给定图G，结果图T 基本步骤如下： 将G中的所有边按权值递增的顺序进行排序 选择权值最短的边且边的两端点属于不同连通分量（如果两端点属于同一个连通分量中，那么就说明该子图是连通图！所以不行），然后该边与T中已选择的边进行连接，每次边连接都会使得T的连通分量减1 当边数小于顶点数时，不断重复1,2 如果当做完上面这些步骤后，得出的结果T中不能包含G中的所有顶点，则说明原图G是不连通的（也就是不是任意一个节点到另一个节点都走的通） 这里有两个难点： 最短边的选取 思路①：采用优先队列，在python中可以通过优先级队列实现，其他语言像C++,Java中也有类似实现的数据结构。 思路②：不断的扫描候选边列表，然后进行排序。这种方法就比较麻烦了，写的代码比较多，不过也很灵活，具体排序方式你可以选择。 如何判断边的两个端点的连通分量 思路①：不断的检查两个端点之间是否有路径，有路径就说明在同一个子图中，连通分量相同。不过这样也太麻烦了点还浪费计算时间 思路②：前人提出的一种方法，为每个连通分量确定一个代表元，如果两个顶点的代表元相同，则表示他们连通成环。例如下图 graph TD V1((v1)) V2((V2)) V3((V3)) V4((V4)) 当初始化的时候v1,v2,v3,v4的代表元就是他们的序号也就对应0,1,2,3 当v1 v2 构成新边的时候，就要把v2的代表元改为v1 的代表元0 。 这时候v1,v2,v3,v4的代表元就更新为0,0,2,3 graph TD V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 v1 v2是的连通分量相同并且他们的代表元也是相同的。 类似，如果想要连接v2 v3，此时v2 v3 的代表元不同，因此连接了也不会构成环。 直接把v3的代表元修改为v2的代表元即可，即0 graph LR V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 V2---V3 此时v1 v2 v3是连通的，他们的代表元是0,0,0 如果下一次操作中，想要把v3 连接到v1 ，检查他们的代表元，都是0所以连接起来一定会构成环 graph LR V1((v1)) V2((V2)) V3((V3)) V4((V4)) V1---V2 V2---V3 V3---V1 因此，可以使用代表元判断欲加入的边是否会与已选择集合T中的边构成环路。 构成过程举例假设还是之前的这颗图G，其结果集T中目前还为空 graph RL V1((V1)) V2((V2)) V3((V3)) V4((V4)) V5((V5)) V6((V6)) V1--6---V2 V1--1---V3 V1--5---V4 V2--5---V3 V3--5---V4 V3--6---V5 V3--4---V6 初始化全部边入队，自动在优先队列中根据权值排好序 graph LR v46((v4,v6,2)) v56((V5,V6,6)) v32((v2,v3,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v13((v1,v3,1)) v13---v46 v46---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 并且初始化代表元列表，初始值为他们的下标。 例如v1的代表元初始值为1，v2的代表元初始值为2….vn的代表元初始值为n graph BT v1[v1,1] v2[v2,2] v3[v3,3] v4[v4,4] v5[v5,5] v6[v6,6] 第一次构造 队首出队，所以&lt;v1,v3&gt;边出队 graph LR v64((v6,v4,2)) v65((V6,V5,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v13((v1,v3,1)) v13---v64 v64---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v65 检查v1 v3的代表元，很明显不同,所以将&lt;v1,v3&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V1--1---V3 合并代表元,修改等于代表元值为3的代表元的值，改为v1的代表元即1 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,5] v6[v6,6] 第二次构造 队首出队，所以&lt;v4,v6&gt;边出队 graph LR v46((v4,v6,2)) v56((V5,V6,6)) v32((v2,v3,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v46---v25 v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v4 v6的代表元，很明显不同,所以将&lt;v4,v6&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V1--1---V3 V6--2---V4 合并代表元,修改等于代表元值为6的代表元的值，改为v4的代表元的值即4 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,5] v6[v6,4] 第三次构造 队首出队，所以&lt;v2,v5&gt;边出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v25((v2,v5,3)) v14((v1,v4,5)) v12((v1,v2,6)) v25---v36 v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v2 v5的代表元，很明显不同,所以将&lt;v2,v5&gt;加入T集合中 graph TD V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 合并代表元,修改等于代表元值为5的代表元的值，改为v2的代表元的值即2 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,4] v5[v5,2] v6[v6,4] 第三次构造 队首&lt;v3,v6&gt;出队 graph LR v56((v5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v36((v3,v6,4)) v14((v1,v4,5)) v12((v1,v2,6)) v36---v14 v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v3 v6的代表元，不同,所以将&lt;v3,v6&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 合并代表元,修改等于代表元值为4的代表元的值，改为v3代表元的值即1 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第四次构造 队首&lt;v1,v4&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v14((v1,v4,5)) v12((v1,v2,6)) v14---v34 v34---v32 v32---v12 v12---v35 v35---v56 检查v1 v4的代表元，相同,所以不将&lt;v1,v4&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 此时代表元不进行任何操作 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第五次构造 队首&lt;v3,v4&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v34((v3,v4,5)) v35((v3,v5,6)) v12((v1,v2,6)) v34---v32 v32---v12 v12---v35 v35---v56 检查v3 v4的代表元，相同，所以不将&lt;v3,v4&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 此时代表元不进行任何操作 graph BT v1[v1,1] v2[v2,2] v3[v3,1] v4[v4,1] v5[v5,2] v6[v6,1] 第六次构造 &lt;v2,v3&gt;出队 graph LR v56((V5,V6,6)) v32((v3,v2,5)) v35((v3,v5,6)) v12((v1,v2,6)) v32---v12 v12---v35 v35---v56 检查v2 v3的代表元，不同，所以将&lt;v2,v3&gt;加入T集合中 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 V3--5---V2 合并代表元,修改等于代表元为2的代表元的值，改为v3代表元的值即1 graph BT v1[v1,1] v2[v2,1] v3[v3,1] v4[v4,1] v5[v5,1] v6[v6,1] 可以发现，当前T集合中已经有5条边了，最小生成树已经生成完毕。同时观察到，代表元中的值也相同了，表示他们都在同一个子图中了。 算法实现1234567891011121314151617181920212223242526272829303132# kruskal算法，最小生成树，前提该图必须是连通网def kruskal(self): # 初始化代表元和结果图 result, reps, pqueue, edgesCount = GraphAL(graph=&#123;&#125;), &#123;&#125;, [], 0 for key in self._graph.keys(): reps[key] = key # 边入队，按优先级排序,选出最短边 for key in self._graph: for end in self._graph[key].keys(): edges = self._graph[key][end] heapq.heappush(pqueue, (edges, key, end)) # 边入队 pass # 当边数达到n-1条时，即成功得到最小生成树时停止 while edgesCount &lt; self.get_vertexNum() - 1 and not pqueue.__len__() == 0: # 出队 pair = list(heapq.heappop(pqueue)) # 判断是否有该顶点,如果没有就要加入 if pair[1] not in result._graph: result.add_vertex(pair[1]) if pair[2] not in result._graph: result.add_vertex(pair[2]) # 检查两点是否属于不同连通分量 if reps[pair[1]] != reps[pair[2]]: result.add_edge(pair[1], pair[2], pair[0]) edgesCount += 1 # 合并连通分量 rep, orep = reps[pair[1]], reps[pair[2]] for key in reps.keys(): if reps[key] == orep: reps[key] = rep return result pass 测试 与刚才结果自动推的完全一致。 graph LR V1((v1)) V3((V3)) V6((V6)) V4((V4)) V2((V2)) V5((V5)) V1--1---V3 V6--2---V4 V2--3---V5 V3--4---V6 V3--5---V2 最短路径dijkstra算法算法原理在看迪杰斯特拉算法之前，可以先回顾下BFS算法的过程。BFS的实现是通过一个队列实现。还是这张图 选择假设BFS从A节点开始，A节点出队后，将A的邻接节点B,C入队 然后B出队，D入队，C出队，E入队。整个BFS的流程大概如此，在这之中，可以看到BFS队列中不同节点离A的距离，每个出队的结点对于他的邻接节点的距离都是1，并且在队列中他们也是紧紧挨着的。 假如可以把这些顶点进行排序，然后不断更新队中节点到A的距离值，那么应该可以一步步的获得当前节点到A节点的最短距离了。 该算法有两个难点： 如何排序 我使用的是python的优先队列，该队列是基于堆这一种数据结构实现的，你也可以自行选择排序算法进行排序 如何更新距离 在BFS中每个节点到A的距离是固定的，是不会发生更新操作的，这是由于BFS算法实现过程中有个访问标志会标志某个节点是否已被访问，该标志保证了每个节点只访问一次。但是在迪杰斯特拉算法中，这样是不行的，因为想要在每个节点出队后，都要将该结点的邻接节点到目标点（这个例子中是A点）的距离进行比较更新，选择权值和小的。 看下面这个网 当遍历到B的时候A到B有两条路，一条是A-B，另一条是A-C-B，前者的距离为5，比较长，后者的距离为3（1+2）。在迪杰斯特拉中就会选择路径A-C-B这条路径。 在实际的算法实现中，距离的比较是通过一个distance的列表实现的，该列表距离了每个顶点到目标点的最短距离。然后在下一次遍历中不断得更新这个距离就可以了。 构造过程举例假设还是上面这个图。 要求图中顶点到A的最短距离 初始化初始化距离列表,inf 表示无穷，A的目标点，所以距离为0 graph TB A[A,0] B[B,inf] C[C,inf] D[D,inf] E[E,inf] F[F,inf] 初始化优先级队列，目标节点A入队 graph TB A((A,0)) 当队列不为空时，循环。 第一次构造 A出队,并标记为已访问，遍历A的邻接节点B、C，同时将A到B的距离5(0+5)和A到C的距离1(0+1)，与distance列表中的距离进行比较，由于distance中的距离都是无穷，所以distance中C的距离更新为1，B的距离更新为5 graph TB A[A,0] B[B,5] C[C,1] D[D,inf] E[E,inf] F[F,inf] B,C节点由于距离被更新了。需要参与下一次比较，所以B、C入队 graph LR B((B,5)) C((C,1)) C-->B 第二次构造 C出队，并标记为已访问，遍历C的邻接节点A,B,D,E，将C-A的距离1，C-B的距离3(1+2)和C-D的距离5(1+4)和C-E的距离9（1+8），与distance列表中的B,C,E的距离进行比较，更新为其中的较小值 graph TB A[A,0] B[B,3] C[C,1] D[D,5] E[E,9] F[F,inf] 由于B,D,E的距离被更新了。需要参与下一次的比较，所以B,C,E需要入队，带着他们的更新后的权值 graph LR B((B,5)) B1((B,3)) D((D,5)) E((E,9)) B1-->B B-->D D-->E 第三次构造 B出队，并标记为已访问，遍历B的子节点D,C,A，将B-D（3+1=4）,B-C（3+2=5）,B-A（3+5）的距离分别与distance中的D,C,A距离进行比较，取小的值，发现只有D的距离被更新为了4 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,9] F[F,inf] 由于D被更新了，需要参与下一次的比较，所以D入队，带着D更新后的权值 graph LR D1((D,4)) B((B,5)) D((D,5)) E((E,9)) D1-->B B-->D D-->E 第四次构造 D出队，并标记为已访问，遍历D的子节点B,C,E,F。将D-B（4+1=5）,D-C（4+4=8）,D-E(4+3=7),D-F(4+6=10)的距离分别与distance中的B,C,E,F距离进行比较，取小的值 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 由于只有E,F的距离被更新为7,和10，所以E，F需要带着他们更新后的权值入队，参与下一次的比较。 graph LR B((B,5)) D((D,5)) E1((E,7)) E((E,9)) F((F,10)) B-->D D-->E1 E1-->E E-->F 第五次构造 队首B出队，由于B被标记已访问，所以直接扔掉，进入下一个循环 graph LR D((D,5)) E1((E,7)) E((E,9)) F((F,10)) D-->E1 E1-->E E-->F 队首D出队，由于D已经被标记已访问，扔掉。进入下一个循环 graph LR E1((E,7)) E((E,9)) F((F,10)) E1-->E E-->F 队首E出队，标记为已访问。遍历其邻接节点C,D，将E-C（7+4=11），E-D（7+3=10）与distance中的C,D值进行比较，取小的值，发现C,D都不需要更新。 由于没有节点被更新，所以没有节点入队。此时的distance如下图 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 第六次构造 队首E出队，由于E被标记为已访问，扔掉，进入下一个循环 graph LR E((E,9)) F((F,10)) E-->F 队首E出队，由于E被标记为已访问，扔掉，进入下一个循环 graph LR F((F,10)) 队首F出队,发现他没有子节点，所以distance不会被更新，队列将不会加入新的结点。此时的distance如下图 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 第七次构造由于此时队列为空，所以循环结束，迪杰斯特拉算法求解完毕！此时的distance就是每个节点到目标点A的最短距离了。 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 迪杰斯特拉算法就是基于这种”宽度优先遍历”的思想，按路径的长度选择下一个最短节点然后逐步扩张（这一点也很像用MST性质实现的prim算法）。这个算法在探索中也会更新已经节点的最短路径，每一步都可以找到一个确定的最短路径，这就是典型的动态规划思想（在计算中保留一些信息，用来支持下一步的决策信息） 算法实现1234567891011121314151617181920212223242526# 迪杰斯特拉法算最短路径def dijkstra(self, start): if not self._invalid(start): raise GraphError("不存在" + start + "这样的顶点") graph = self._graph pqueue = [] # 优先级队列 heapq.heappush(pqueue, (0, start)) # 根顶点进队，最高优先级 seen = set() # 记录访问过的顶点 parent = &#123;start: None&#125; # 生成树 distance = self.__init_distance(start) # 初始化距离 while pqueue.__len__() &gt; 0: pair = heapq.heappop(pqueue) # pop弹出的是元组，第一个参数是距离（优先级），第二个是顶点 dist = pair[0] vertex = pair[1] seen.add(vertex) # 记录访问过的顶点 nodes = graph[vertex].keys() # 获取其顶点的邻接顶点 for node in nodes: if node not in seen: if dist + graph[vertex][node] &lt; distance[node]: # 如果当前顶点到开始顶点的距离小于距离列表中的值，更新距离 heapq.heappush(pqueue, (dist + graph[vertex][node], node)) parent[node] = vertex distance[node] = dist + graph[vertex][node] # 输出遍历结果 # print(vertex) return distance, parent pass 测试 可以发现，如刚才推导的结果一模一样。 graph TB A[A,0] B[B,3] C[C,1] D[D,4] E[E,7] F[F,10] 弗洛依德算法(待填坑)算法原理算法实现测试拓扑排序算法原理拓扑排序是有向图（网）中的内容，只在有向网（图）的范畴中讨论。 先看一个实际生活中可能遇到的问题：选课问题，例如上大一的时候你肯定要先学C语言，然后才能学数据结构。这个时候C语言和数据结构就构成了一个排列问题，谁在前谁在后。用图中的顶点表示一个活动，边表示活动之间的顺序关系。这样的图就称为AOV网（顶点活动网） 下图就是一个典型的AOV网实例。 任何无回路的AOV网N都可以求解出拓扑序列，方法很简单： 从N中选出一个入度为0的顶点作为序列的下一个顶点 从N网中删除所选顶点的出边 重复执行上面两步，直到已经选出了图N的所有顶点 拓扑排序算法有两个难点： 如何寻找入度为0的顶点 真的需要拷贝整张图，然后进行删除 一个显然的办法是不断遍历图，寻找入度为0的顶点。但时间代价会很高。顶点间的制约关系决定了顶点的入度。入度是一个整数，用一个整数表就能记录所以顶点的入度了。因此，我的方法是用一张入度表记录了每个顶点的入度，初始时，表中的各顶点的入度对应为图中顶点的入度，在随后的计算中，一旦选中一个顶点，就将该顶点的出边入度减一。 在实际的算法实现中还用了一个0度栈来记录已经入度为0但还未处理的顶点。 算法比较简单。 可以慢慢调试 算法实现123456789101112131415161718192021222324def topological_sort(self): indegree = &#123;&#125; # 入度表 zerov = [] # 利用0度栈记录已知的入度为0的但还未处理的顶点 m = 0 # 输出顶点计数 topo = [] # 拓扑排序结果 # 生成入度表和0度栈 for vetx in self._graph: indegree[vetx] = self.get_inEdge(vetx).__len__() if indegree[vetx] == 0: zerov.append(vetx) pass while zerov.__len__() != 0: Vi = zerov.pop() topo.append(Vi) m += 1 for Vj in self.get_outEdge(Vi).keys(): # 对顶点Vi的每个邻接点入度减1，如果Vj的入度变为0，则将Vj入栈，表示Vj就是下一个需要处理的顶点 indegree[Vj] -= 1 if indegree[Vj] == 0: zerov.append(Vj) if m &lt; self.get_vertexNum(): # 该有向图有回路 return False return topo 测试 关键路径算法原理算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445# 关键路径def criticalPath(self, delay=0): topo = self.topological_sort() if not topo: raise GraphError("存在有向环！") ve = [0 for i in range(len(topo))] # 事件最早开始时间 vl = [0 for i in range(len(topo))] # 事件最迟开始时间 cp = [] # 关键路径 result = &#123;&#125; # 返回结果 # --------------------------------计算事件的最早发生时间----------------------------- for i in range(topo.__len__()): start = topo[i] # 取出拓扑节点 for node in self.get_outEdge(start).keys(): # 获取拓扑节点的邻接点，计算ve w = self._graph[start][node] # 当前节点与邻接节点的边 j = topo.index(node) # 邻接节点的下标 if ve[j] &lt; ve[i] + w: # 更新邻接点的最早发生时间，选大的时间 ve[j] = ve[i] + w pass # --------------------------------计算事件的最晚发生时间----------------------------- for i in range(topo.__len__()): # 给每个事件的最迟发生时间置初值，初值为最早发生时间中的最大值 vl[i] = ve[topo.__len__() - 1] + delay for i in reversed(range(topo.__len__())): k = topo[i] # 取出拓扑节点 for node in self.get_inEdge(k).keys(): # 获取拓扑节点的逆邻接点，计算vl w = self._graph[node][k] # 逆邻接点和当前节点的边 j = topo.index(node) # 逆邻接点的下标 if vl[j] &gt; vl[i] - w: # 更新逆邻接点的最晚发生时间，选小的时间 vl[j] = vl[i] - w pass # --------------------------------判断每一活动是否为关键路径-------------------------- for i in range(topo.__len__()): start = topo[i] for node in self.get_outEdge(start).keys(): j = topo.index(node) # 获得邻接顶点的下标 w = self._graph[start][node] # 当前节点与邻接节点的边 e = ve[i] # 计算活动&lt;start,node&gt;的最早开始时间 l = vl[j] - w - delay # 计算活动&lt;start,node&gt;的最晚开始时间 if e == l: cp.append((start, node)) # 如果相等就说明为关键路径 pass for i in range(topo.__len__()): result[topo[i]] = (ve[i], vl[i]) pass return result, cp 测试 st=>start: 初始化队列，初始顶点入队 e=>end: 结束BFS deque=>operation: 出队 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否队空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);st=>start: 初始化栈，初始顶点进栈 e=>end: 结束DFS deque=>operation: 出栈 isVisit=>condition: 是否访问过该顶点? visit=>inputoutput: 访问 jump=>operation: 跳过该顶点的访问 isqueNull=>condition: 是否栈空 st->deque->isVisit isVisit(yes)->jump->isqueNull isVisit(no)->visit->isqueNull isqueNull(yes)->e isqueNull(no)->deque{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-1-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-1", options);]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>python,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim常用操作及使用技巧]]></title>
    <url>%2F2019%2F08%2F19%2FVim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[早期版本：viVim常用操作Vim是一个功能强大的全屏幕的文本编辑器，是Linux/UNIX上最常用的文本编辑器，他的作用是建立、编辑、显示文本文件。VIm 没有菜单，只有命令vim常用命令编辑模式常用命令 a 在光标所在字符后插入 A在光标所在行尾插入 i在光标所在字符前插入 I在光标所在行行首前插入 o在光标下插入新行 O在光标上插入新行 命令模式常用命令按:进入命令模式，如果当前是编辑模式，记得按下ECS。 设置与保存命令 :wq 保存退出 :wq!强制保存退出（文件所有者及root可用） :w new_filename 另存为指定文件 ZZ 快捷键，保存修改并退出 :q! 不保存修改直接退出 q 退出 set nu 设置行号 set nonu 取消行号 移动命令 gg 到第一行 G到最后一行 nG 到第n行 :n 到第n行 $ 移至行尾 0 移至行首 删除命令 x 删除光标所在处的字符 nx删除光标所在处后n个字符 dd 删除光标所在行 dG删除光标所在行到文件末尾的内容 D删除光标所在处到行尾的内容 :n1,n2d 删除指定范围的行 复制和剪切命令复制是yy和p和组合键 剪切是dd和p的组合键 yy复制当前行 nyy 复制当前行一下的n行 dd 剪切当前行 ndd 剪切当前行一下的n行 p或P 粘贴在当前光标所在行下或行上 替换和撤销命令 r 取代光标所在处的字符 R 从光标所在处开始替换字符,按Esc结束 u 撤销上一步操作 检索命令 /string 检索指定字符串，检索时忽略大小写 :set ic 检索时不忽略大小写 ：set noic n 搜索指定字符串的下一个出现位置 :%s/old/new/g 全文替换指定字符串 ,如果后面是c就会替换时询问你 :n1,n2s/old/new/g 在一定范围内替换指定字符串 #### 一些使用技巧导入命令执行结果如果需要把一个vim文件的内容导入到当前编辑内容中 使用r! 文件名即可 该命令会把某个vim文件的当前光标所在行内容导入当前编辑内容中 :which 命令 查找某个命令的位置 定义快捷键:map 快捷键触发命令 例如： map ^P I#&lt;ESC&gt; 如果要实现一个快速注释某一行的命令，需要四部 进入编辑模式 使用I移至行首 输入# 按ESC回到命令模式 如果用快捷键，可以快速完成这个操作 :map ^p I#&lt;ESC&gt; ^P 可以用ctrl+V+P弄出来，表示要当按下ctrl+p的时候触发。 如果需要去掉注释可以用一下方式定义快捷键 :map ^B 0x 然后就可以去掉注释了。 如果需要添加个人邮箱 :map ^H i610596547@qq.com&lt;ESC&gt; 连续行注释 :n1,n2s/^/#g n1,n2s表示指定范围行 /^/#g在行首替换字符（也就是增加） 如果需要把连续行的注释去掉，也是用替换 :n1,n2s^#//g 其实就是正则表达式的简单应用。 如果要用//连续注释 可以用 :n1,n2s/^/\/\//g其中\/\/是//的转义 替代命令:ab 替代文本 被替代文本 例如： :ab mail 610596547 保存快捷键在root用户在/root/.vimrc下可写入快捷键 如果是别的用户则在/home/username/.vimrc下写入 centos7 会自动帮你写入，而且文件名变为了.viminfo]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用命令-关机重启命令]]></title>
    <url>%2F2019%2F08%2F19%2FLinux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%85%B3%E6%9C%BA%E9%87%8D%E5%90%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[shutdown描述：关机，重启这个命令比较“安全”选项： -h 关机 -r 重启 -c 取消前一个关机命令 例如：1234shutdown -h now #现在关机shutdown -h 20:30 #晚上八点半关机shutdown -r now #现在重启shutdown -c #取消前一个关机命令 其他重启，关机命令 halt poweroff init 0 系统运行级别 0 关机 1 单用户 (只启动最核心程序，只有root用户，类似于windows的安全模式) 2 不完全多用户，不含NFS服务（NFS[网络文件系统]，不太安全） 3 完全多用户 4 未分配 5 图形界面 6 重启 1init 6 #重启 如果觉得难记，可以查看 cat /etc/inittab centos 7下只有3,5可以选 12# multi-user.target: analogous to runlevel 3# graphical.target: analogous to runlevel 5 查询当前的运行级别 1runlevel 例如： 12[zhong@localhost ~]$ runlevelN 5 N代表开机之后直接进入了5级别。 接下来，进入3级别，即无图形界面级别 1init 3 1234567==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===Authentication is required to manage system services or units.Authenticating as: rootPassword: ==== AUTHENTICATION COMPLETE ===[zhong@localhost ~]$ runlevel 5 3 当前就显示，系统由5进入到3级别。 查看虚拟机。 发现系统果然进入了命令行界面。 现在在切换回图形界面：使用命令 1init 5 123456[zhong@localhost ~]$ init 5==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ===Authentication is required to manage system services or units.Authenticating as: rootPassword: ==== AUTHENTICATION COMPLETE === 查看当前运行级别 12[zhong@localhost ~]$ runlevel3 5 再看看虚拟机： 成功切换回了图形界面。 退出登录命令log out 维护服务器离开之后一定要记得退出登录。不然可能造成不良后果。]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS上安装配置Python3.7]]></title>
    <url>%2F2019%2F08%2F19%2FCentOS%E4%B8%8A%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEPython3-7%2F</url>
    <content type="text"><![CDATA[安装依赖包1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make1yum install libffi-devel -y下载python3.7的包 方法一：直接在官方网站下载打开python的官方网站：https://www.python.org/ –&gt;Downloads–&gt;Source code–&gt;Latest Python 3 Release - Python 3.7.0–&gt;拉到最下面，选择Gzipped source tarball，下载到本地，然后上传到服务器即可 方法二：通过wget1wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz 然后执行： 1234tar -zxvf Python-3.7.0.tgz #解压解包cd Python-3.7.0./configure #运行配置make&amp;&amp;make install #编译并安装 安装的目录通常在：/usr/bin/下 配置这里为了使默认python变成python3，需要加一条软链接,并把之前的python命令改成python.bak，而且pip也是要进行链接的： 1234mv /usr/bin/python /usr/bin/python.bakln -s /usr/local/bin/python3 /usr/bin/pythonmv /usr/bin/pip /usr/bin/pip.bakln -s /usr/local/bin/pip3 /usr/bin/pip 接下来需要配置yum的引用，因为yum引用的是之前系统默认的python2.7，现在变成了3.7，需要把他改回来。需要改动两个地方 1vi /usr/libexec/urlgrabber-ext-down 1vi /usr/bin/yum 测试输入 1python -V 1pip -V 如果出现3.7版本，就说明成功了。 使用新建一个py文件 1vim helloWorld.py 修改内容如下： 12#! /usr/bin/python print("hello,world") 第一句一定要加的，除非你配个虚拟环境virtualenv 增加执行权限： 1chmod +x helloWorld.py 运行： 1./helloWorld.py 如果控制台输出为： 1hello,world 即测试成功了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用命令-网络命令]]></title>
    <url>%2F2019%2F08%2F18%2FLinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[write命令功能：给用户发信息，以Ctrl+C结束，通信双方要求已登录。用法：wirte &lt;用户名&gt;执行权限：所有用户实例：在zhong这个用户下给root用户发信息在root用户中就可以看见了wall命令英文缩写：wirte all功能：发广播信息，所有登录用户都能收到执行权限：所有用户 用法：wall [message] 示例： 12345[root@localhost ~]# wall Hello Broadcast message from root@localhost.localdomain (pts/2) (Sun Aug 18 21:29:41 2019):Hello 1234[zhong@localhost ~]$ Broadcast message from root@localhost.localdomain (pts/2) (Sun Aug 18 21:29:41 2019):Hello 可以看到，发送者自己也能收到这个信息。 ping命令功能：测试网络连通性 用法：ping [-c] [ip] 选项：-c指定发送次数 示例： 12345678910[zhong@localhost ~]$ ping www.baidu.com -c 4PING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=128 time=26.6 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=128 time=32.5 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=128 time=37.5 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=128 time=32.4 ms--- www.a.shifen.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3005msrtt min/avg/max/mdev = 26.609/32.293/37.540/3.875 ms 重点看丢包率packet loss，丢包率高则说明网络状况不佳。 ifconfig英文原意：interface configure 描述：查看和设置网卡信息 执行权限：root 语法：ifconfig 网卡名称 ip 查看网卡信息1234567891011121314151617181920212223242526[zhong@localhost ~]$ ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.146.128 netmask 255.255.255.0 broadcast 192.168.146.255 inet6 fe80::487d:9db5:efb1:19b8 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:b5:b4:4c txqueuelen 1000 (Ethernet) RX packets 7377 bytes 504286 (492.4 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 8791 bytes 14466799 (13.7 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 272 bytes 29576 (28.8 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 272 bytes 29576 (28.8 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt; mtu 1500 inet 192.168.122.1 netmask 255.255.255.0 broadcast 192.168.122.255 ether 52:54:00:29:75:7b txqueuelen 1000 (Ethernet) RX packets 0 bytes 0 (0.0 B) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 0 bytes 0 (0.0 B) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 ens33是本机网卡，inet addr：当前网络ip地址 last功能：列出目前与过去登入系统的用户信息 如果想知道用户的最后登录用户可以用lastlog traceroute描述：显示数据包到主机间的路径 用法：traceroute 服务器地址 12345678910111213141516171819[root@ecs-s2-medium-2-linux-20190722215607 ~]# traceroute www.baidu.comtraceroute to www.baidu.com (180.101.49.12), 30 hops max, 60 byte packets 1 * * * 2 * * * 3 100.80.0.1 (100.80.0.1) 7.387 ms * 7.234 ms 4 * 10.241.6.21 (10.241.6.21) 8.529 ms 8.700 ms 5 10.241.8.141 (10.241.8.141) 10.065 ms * 9.837 ms 6 * 10.230.2.146 (10.230.2.146) 1.128 ms 1.128 ms 7 10.230.2.108 (10.230.2.108) 9.665 ms 9.843 ms 9.932 ms 8 10.230.2.42 (10.230.2.42) 2.296 ms 3.847 ms 3.644 ms 9 * 10.1.128.65 (10.1.128.65) 2.442 ms 2.725 ms10 10.1.128.82 (10.1.128.82) 2.841 ms * 10.1.128.74 (10.1.128.74) 2.760 ms11 * * *12 183.60.190.97 (183.60.190.97) 7.199 ms 183.60.190.101 (183.60.190.101) 8.062 ms 8.015 ms13 113.96.4.65 (113.96.4.65) 4.938 ms * 4.298 ms14 * 202.97.54.238 (202.97.54.238) 26.562 ms *15 58.213.94.118 (58.213.94.118) 32.441 ms 32.433 ms *16 58.213.94.90 (58.213.94.90) 29.217 ms * *17 58.213.96.118 (58.213.96.118) 32.847 ms 58.213.96.94 (58.213.96.94) 32.748 ms 58.213.96.62 (58.213.96.62) 28.098 该命令会返回每个节点的延时，可以用此查看是哪个网络节点出现了问题。 netstat命令描述：显示网络相关信息 权限：所有用户 选项： -t TCP协议 -u UDP协议 -l 监听 -r 路由 -m 显示ip地址和端口号 例如： # netstat -tlun 查看本机监听的端口 # netstat -an 查看本机所有的网络连接 # netstat -rn 查看本机路由表 例如： 123456[root@localhost ~]# netstat -tunActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 192.168.146.128:22 192.168.146.1:53249 ESTABLISHEDtcp 0 36 192.168.146.128:22 192.168.146.1:54298 ESTABLISHEDtcp 0 0 192.168.146.128:22 192.168.146.1:54280 ESTABLISHED 通常这个命令用来与查看某个端口是否被占用，然后关闭 12netstat -anp |grep 端口号kill -9 进程pid setup描述：配置网络 执行权限：root 这个命令是红帽自带的配置命令。可以进入系统配置界面]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令-压缩解压命令]]></title>
    <url>%2F2019%2F08%2F17%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[打包命令在总结解压前，需要先了解打包命令，Linux的有些压缩格式是无法直接压缩目录的，需要用到tar命令进行打包成文件。 使用方法：tar -cf[v] 打包后的文件名 需要打包的目录名 选项: -c打包 -f指定文件名 -v输出详细信息 -x解包 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cf testDir.tar testDir[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar 几种压缩格式及命令.gz格式这种格式在Linux中用的最多，也最常见 压缩文件命令.gz文件可以用gzip 命令进行压缩 注意点 gz命令只能压缩文件，该命令无法压缩目录。 gz压缩完成后不保存源文件 压缩目录压缩目录有两种方法，因为gz命令是无法直接压缩目录的，所以要先对目录进行打包，打包成tar文件 方法一：先打包，在压缩 先使用tar -cf 打包后的文件名 需要打包的文件名先把目录打成tar包 再用gzip将tar包压缩。 方法二：利用tar打包并压缩如果需要压缩目录，则需要用到tar命令，该命令将目录打包成文件同时进行压缩，压缩后的格式为tar.gz 再复习下常用选项 -c打包 -v显示详细信息 -f指定文件名 -z打包同时压缩成.gz压缩包 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cvf testDir.tar testDir/ #打包某个目录testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar 然后可用gz命令对该目录打包后的文件进行压缩 123[root@ecs-s2-medium-2-linux-20190722215607 home]# gzip testDir.tar [root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz 如果觉得先打包再压缩有点麻烦，可以加入-z参数，在打包的同时进行压缩 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -zcf testDir.tar.gz testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz[root@ecs-s2-medium-2-linux-20190722215607 home]# 解压缩文件使用gunzip或者gzip -d命令可以进行解压缩 解压目录因为压缩目录有两种方法，同样解压也有两种方法： 方法一：先解压，在进行解包 先用gunzip 压缩文件名进行解压 再用tar -xf t包名进行解包 方法二：利用tar解包并解压常见选项如下： -x解包 （与-c对应） -v显示详细信息 -f指定压缩文件 -z解压缩 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -xzvf testDir.tar.gz testDir/[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.gz 使用tar命令的注意点-f选项后面一定要加文件名，也就是如果你要把选项写在一起，请把-f放在最后面，像这样-xzvf或者-czvf .bz2格式该格式是.gz的升级版，他的好处是压缩比非常惊人，常用来压缩大文件。 压缩文件使用bzip2进行压缩 用法：bzip 选项[-k] [文件] 选项：-k产生压缩文件后保留原文件 压缩后的格式：.bz2 压缩目录方法一：先打包，在压缩 先使用tar -cf 打包后的文件名 需要打包的文件名先把目录打成tar包 再用bzip将tar包压缩。 方法二：利用tar打包并压缩如果你想在用tar命令打包的同时进行压缩，并且压缩后的格式为.bz2，那么需要加入选项-j （注意与tar压缩成.gz格式的-z选项进行区分） 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# tar -cjf testDir.tar.bz2 testDir[root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir testDir.tar.bz2 解压缩文件使用命令bunzip2就可以对.bz2文件进行解压缩 使用方法：bunzip2 选项[-k] [压缩文件名] 选项：-k解压缩后保留原文件 例如： 1234[root@ecs-s2-medium-2-linux-20190722215607 home]# bunzip2 testDir.tar.bz2 [root@ecs-s2-medium-2-linux-20190722215607 home]# lstestDir[root@ecs-s2-medium-2-linux-20190722215607 home]# 解压缩目录方法一：先解压，再解包你可以先用gunzip进行解压文件，解压出来是个tar包，然后用用tar -xf进行解包即可 方法二：利用tar解包并解压tar -xjf进行解包并进行解压缩 注意区分：解压.gz格式的tar包时用的是-z，解压.bz2格式tar包时用的是-j .gz 与 .bz2用法比较 命令\格式 .gz .bz2 压缩文件 gzip bzip2 压缩目录 方法一：先用tar -cf进行打包，在用gzip进行压缩；方法二：直接用tar -czf进行压缩 方法一：先用tar -cf进行打包，在用bzip2进行压缩；方法二：直接用tar -cjf进行压缩 解压缩文件 gunzip bunzip2 解压缩目录 方法一：先用gunzip进行解压，解压得到的文件是.tar包，在用 tar -xf进行解包；方法二：直接用tar -xzf进行解包并解压缩 方法一：先用bunzip2进行解压，再用tar -xf进行解包；方法二：直接用tar -xjf进行解包并解压缩。 再次强调注意点： 如果你使用tar -czf或tar -cjf进行压缩目录，f后面要跟两个东西，一个是压缩后的文件名，一个是需要压缩的目录。类似这样tar -cjf testDir.tar.gz testDir 如果你使用tar -xzf或tar -xjf进行解压缩目录，f之后只用跟需要解压的文件即可。类似这样tar -xjf testDir.tar.bz2 .zip格式.zip是windows和linux都支持的压缩格式 压缩后的格式为.zip zip压缩命令使用格式：zip 选项[-r] [压缩后的文件名] [文件或目录] 选项：-r 压缩目录 与gz命令不同的是：可压缩目录，保留源文件 例如： 12[root@ecs-s2-medium-2-linux-20190722215607 home]# zip -r testDir.zip testDir adding: testDir/ (stored 0%) 该命令还会很人性化的提醒你压缩比。因为我这个是空目录，所以是0。 zip解压缩命令使用unzip就可以解压缩.zip的压缩文件 例如： 123[root@ecs-s2-medium-2-linux-20190722215607 home]# unzip testDir.zip Archive: testDir.zip creating: testDir/]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令-用户管理命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[useradd功能描述：添加新用户 执行权限：root 命令所在路径：/usr/sbin/useradd 1useradd xxx #用户名 passwd如果需要给用户密码好让该用户访问系统，则需要用到该命令 功能描述：设置用户密码 执行权限：所有用户 命令所在路径：/usr/bin/passwd 1passwd xxx #用户名 如果不加参数，则更改当前用户的密码 1passwd who功能描述：查看登录用户信息 执行权限：所有用户 命令所在路径：/usr/bin/who 123[root@ecs-s2-medium-2-linux-20190722215607 /]# whoroot tty1 2019-08-07 11:17root pts/4 2019-08-16 22:08 (183.39.158.131) 第一个部分是登录的用户名，第二个是登录终端（tty1是本地登录，pts表示远程登录），第三个是登录的时间，最后的是登录的主机ip（缺省为本地登录） w功能描述：查看登录用户详细信息 执行权限：所有用户 命令所在路径： /usr/bin/w 12345[root@ecs-s2-medium-2-linux-20190722215607 /]# w 23:17:56 up 25 days, 2 min, 2 users, load average: 0.00, 0.01, 0.05USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATroot tty1 07Aug19 9days 0.01s 0.01s -bashroot pts/4 183.39.158.131 22:08 4.00s 0.02s 0.00s w load average: 0.00, 0.01, 0.05表示1分钟，5分钟，10分钟内负载百分比 IDLE表示该用户空闲了多久，PCPU表示CPU时间 ，JCPU表示总共占用的CPU实际 WHAT表示用户当前执行的命令]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令-帮助命令]]></title>
    <url>%2F2019%2F08%2F16%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4-%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[man命令man可以查看命令的帮组和配置文件的帮助 man查看命令信息例如想要查看ls的帮助信息 1man ls 查看ls命令的帮助信息 按空格翻页 按q离开 NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息，输入/xxx即可 man查看配置文件信息例如查看 locale.conf配置，注意不需要加绝对路径，直接名字即可 1man locale.conf NAME代表描述，说明这个命令的作用 SYNOPSIS表示用法，说明这个命令的使用方法 DESCRIPTION是各种选项参数的解释，如果你要快速的定位到某个选项参数信息 往后翻，可以查看到使用的方法 1234567OPTIONS The following locale settings may be set using /etc/locale.conf: LANG=, LANGUAGE=, LC_CTYPE=, LC_NUMERIC=, LC_TIME=, LC_COLLATE=, LC_MONETARY=, LC_MESSAGES=, LC_PAPER=, LC_NAME=, LC_ADDRESS=, LC_TELEPHONE=, LC_MEASUREMENT=, LC_IDENTIFICATION=. Note that LC_ALL may not be configured in this file. For details about the meaning and semantics of these settings, refer to locale(7).EXAMPLE Example 1. German locale with English messages 特殊情况如果碰到一个即是命令又是配置文件的该怎么办？ 例如passwd命令 用whereis查看passwd 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whereis passwdpasswd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.5.gz 可以看到查出来既有命令又有配置文件，第一个是命令的位置，第二个是配置文件的位置，第三个是命令帮助文件的位置，第四个是配置文件帮助命令的位置 1是命令的帮助 5是配置文件的帮助。优先显示命令的帮组 1man 5 passwd 即可查看该配置文件的信息 whatis命令如果只是想简单的看下该命令是做什么的可以用此命令 1what is 该命令会直接显示NAME的信息，这样就不用看一大片的英文了。 12[root@ecs-s2-medium-2-linux-20190722215607 /]# whatis lsls (1) - list directory contents apropos 命令如果想简单的查看配置文件的信息，用该命令即可 例如 12[root@ecs-s2-medium-2-linux-20190722215607 /]# apropos locale.conflocale.conf (5) - Configuration file for locale settings –help 选项利用--help会把常见的选项信息列出 123456789101112131415161718192021222324[root@ecs-s2-medium-2-linux-20190722215607 /]# ls --helpUsage: ls [OPTION]... [FILE]...List information about the FILEs (the current directory by default).Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.Mandatory arguments to long options are mandatory for short options too. -a, --all do not ignore entries starting with . -A, --almost-all do not list implied . and .. --author with -l, print the author of each file -b, --escape print C-style escapes for nongraphic characters --block-size=SIZE scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below -B, --ignore-backups do not list implied entries ending with ~ -c with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first -C list entries by columns --color[=WHEN] colorize the output; WHEN can be 'never', 'auto', or 'always' (the default); more info below -d, --directory list directories themselves, not their contents -D, --dired generate output designed for Emacs' dired mode -f do not sort, enable -aU, disable -ls --color help 命令该命令可以查看Shell内置命令的帮助信息 什么是内置命令？在shell中默认设置的命令就是内置命令。shell的作用就是向内核解释代码。 例如cd命令 12[root@ecs-s2-medium-2-linux-20190722215607 /]# type cdcd is a shell builtin 使用help命令查看cd命令 12345678910111213141516171819202122232425262728[root@ecs-s2-medium-2-linux-20190722215607 /]# help cdcd: cd [-L|[-P [-e]]] [dir] Change the shell working directory. Change the current directory to DIR. The default DIR is the value of the HOME shell variable. The variable CDPATH defines the search path for the directory containing DIR. Alternative directory names in CDPATH are separated by a colon (:). A null directory name is the same as the current directory. If DIR begins with a slash (/), then CDPATH is not used. If the directory is not found, and the shell option `cdable_vars' is set, the word is assumed to be a variable name. If that variable has a value, its value is used for DIR. Options: -L force symbolic links to be followed -P use the physical directory structure without following symbolic links -e if the -P option is supplied, and the current working directory cannot be determined successfully, exit with a non-zero status The default is to follow symbolic links, as if `-L' were specified. Exit Status: Returns 0 if the directory is changed, and if $PWD is set successfully when -P is used; non-zero otherwise. 总结 man 查看命令或配置文件帮助 whatis 获得命令简短的信息 apropos 获得配置文件的简短信息 help 查看shell查看shell内置命令信息]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署云服务器的全过程]]></title>
    <url>%2F2019%2F08%2F16%2Fhexo%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言由于不想部署在github上，因为Github的访问速度在国内比较慢，所以有了此文。 部署之前先了解一下hexo利于git更新的流程，部署在Github上和部署在云服务器上没有特别大的本质区别。 整个流程就是本地将 *.md 渲染成静态文件，然后Git推送到服务器的repository,服务器再通过 git-hooks 同步网站根目录。再利于nginx托管这些静态资源，就可以实现快速的访问。 环境本地环境 Windows10(64bit) 已经装好了git,nodejs,hexo 已经在本地调试好了hexo静态网站 服务器环境 华为云ECS（1M1核2G，centos7） 已经装好了git，nodejs，以及编译好了Nginx 本地机器配置配置密钥在本地机器（Windows环境）中进入 使用git bash生成ssh公钥12# 本地 windows gitBashssh-keygen -t rsa 一路回车，直至如下图，即可。 在本地服务器中配置好了公钥，接下来我们需要把这个公钥交给服务器，相当于本地机器有了一把能访问服务器的“钥匙”，所以接下来需要配置服务器。 服务器配置安装Git,nodejs,Nginx等linux下安装这些非常简单，直接百度即可。 创建git新用户及配置创建git新用户1234adduser git #加入git用户passwd git #配置你的密码chmod 740 /etc/sudoers #修改权限 r=4 w=2 x=1 rwx=7 r__=4 ___=0,也就是说git的sudo使用权为只读vim /etc/sudoers 打开suduers，找到以下内容 12## Allow root to run any commands anywhereroot ALL=(ALL) ALL 在他的下面加入以下内容 1git ALL=(ALL) ALL wq保存后，需要将权限修改回来 1chmod 400 /etc/sudoers 将公钥配置到服务器上首先你得在你的本地机器上找到你的公钥，一般在用户的家目录下，windows是Administrator目录，linux是~/.ssh下 我的本地机器是windows，所以在Administrator目录下。 将该文件的内容复制。 在服务器端，切换至刚刚创建好的git用户下，创建.ssh文件和authorized_keys文件 123su gitmkdir ~/.sshvim ~/.ssh/authorized_keys 修改权限 123cd ~chmod 600 .ssh/authorzied_keys # 将文件设置为可读可写chmod 700 .ssh #将该文件夹设置为可读可写可执行，注意文件夹的可执行是指能访问 测试git连接切换到本地机器上，在本地机器上测试是否能连接到你的远程git用户 1ssh -v git@SERVER_IP 测试成功 如果你的测试不成功，请查看具体的输出信息，通常是公钥没配置好，可以把原来生成的公钥删了，重新配置一遍。 创建网站的根目录创建网站的根目录的目的是为了让nginx托管这些静态文件。 创建一个目录用于作为网站的根目录。切换成root用户 12su rootmkdir /home/hexo # 此目录为网站的根目录 变更该目录的所有者 1chown git:git -R /home/hexo 安装以及配置Nginx安装过程略，具体可百度。编译好nginx后，进入其配置文件 1vim conf/nginx.conf 在http端下配置你的虚拟主机 12345678910111213141516171819server&#123; listen 8081; #监听8081端口 server_name 139.159.245.212; #你的服务器名，通常是域名，如果是域名，你就需要监听80端口 root /home/hexo; #网站的根目录 location / &#123; &#125;#access_log logs/access.log mylog;error_page 404 /404.html; #配置40x页面 location = /40x.html &#123;&#125;error_page 500 502 503 504 /50x.html; #配置50x页面 location = /50x.html &#123;&#125;&#125; 注意使用 nginx -t 命令检查配置文件的语法是否出错。然后使用 systemctl restart nginx.service 或者 在编译好的nginx目录下使用sbin/nginx -s reload命令重启服务即可。 实现自动化部署建立git裸库该裸库什么版本信息和数据都不保存，单纯是为了共享而存在。 在root 用户下 123su rootcd /home/git # 在 git 用户目录下创建git init --bare hexo.git 这时，git 用户的 ~ 目录下就存在一个 hexo.git 文件夹，可使用 ls 命令查看。再修改 hexo.git 的所有者。 1chown git:git -R hexo.git 使用 git-hooks 同步网站根目录在这使用的是 post-receive 这个钩子，当 git 有收发的时候就会调用这个钩子。 在 blog.git 裸库的 hooks 文件夹中，新建 post-receive 文件。 1vim hexo.git/hooks/post-receive 填入以下内容，其中 /home/hexo 为网站目录，根据自己的填入,保存退出。 12#!/bin/shgit --work-tree=/home/hexo --git-dir=/home/git/hexo.git checkout -f 该钩子的意思是当本地有提交到服务器时，会将文件放在/home/hexo下 -f这个参数如果在多人协作的博客中可能会引发不好的结果，因为他是强制更新的意思，会将本地版本覆盖掉远程服务器的版本，但是是个人的博客系统就无所谓了 保存后，要赋予这个文件可执行权限。 1chmod +x /home/git/hexo.git/hooks/post-receive 这样就完成了git自动部署的配置 本地机器中部署至服务器在本地中，和部署到 github 服务一样，需要先 hexo g 命令生成静态文件，通过 hexo s 命令能够正常进行本地访问，并且确保已经安装了 hexo-deployer-git。 配置hexohexo 根目录下的 _config.yml 文件，找到 deploy。 1234deploy: type: git repo: git@SERVER:/home/git/hexo.git # 填写你的服务器地址 将SERVER替换掉 branch: master # 分支 之后按照正常的流程部署 1hexo c &amp;&amp; hexo g &amp;&amp; hexo d 测试自动化部署 部署成功，访问测试]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy爬取CSDN博客列表]]></title>
    <url>%2F2019%2F08%2F16%2FScrapy%E7%88%AC%E5%8F%96CSDN%E5%8D%9A%E5%AE%A2%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。 其可以应用在数据挖掘，信息处理或存储历史数据等一系列的程序中。其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的， 也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。 具体可查看文档 scrapy中文文档 新建Scrapy爬虫项目如果你还没有安装Scrapy，可以通过下面这个命令安装 1pip install scrapy 新建一个项目安装好之后就可以创建项目了 1scrapy startproject 你的项目名 创建好之后的目录如上图所示 每个文件的具体作用可以参照Scrapy的官方文档，这里就不再赘述。 新建一个爬虫通过命令 1scrapy genspider 你的爬虫名 设置配置文件如果你不需要存入数据库或者做进一步的反爬处理，则可以跳过这一步，打开setting.py进行以下修改 设置浏览器名把BOT_NAME设置为你的浏览器名，如果使用默认，别人一看就知道是爬虫 1BOT_NAME = 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11' 设置日志级别这样就不需要打印太多日志信息，干扰视线 1LOG_LEVEL='WARN' 设置模式将机器人模式设为FALSE 1ROBOTSTXT_OBEY = False 设置你要抓取的博客页数12#博客页数CsdnPage = 2; 设置你的数据库为了方便将数据自动导入数据库，需要设置数据库配置信息，我使用的是mysql 1234567#数据库设置MYSQL_HOST = '你的主机名'MYSQL_PORT = 3306 #端口MYSQL_DBNAME = 'DBNAME' # 数据库名MYSQL_TABLE = 'TABLE_NAME' #表名MYSQL_USER = '你的用户名' MYSQL_PASSWD='你的密码' 新建数据项数据项的作用是方便scrapy以结构化的数据插入到数据库中。 打开 items.py，复制一下代码即可，或者你如果要爬新的数据，请记得加入新的字段 12345678import scrapyclass CsdnItem(scrapy.Item): # define the fields for your item here like: title = scrapy.Field() url = scrapy.Field() #date = scrapy.Field() tag = scrapy.Field() pass 编写爬虫文件123456789101112131415161718192021222324252627282930313233import scrapyfrom ..items import CsdnItemfrom ..settings import CsdnPageclass CsdnSpiderSpider(scrapy.Spider): name = &apos;csdn_spider&apos; allowed_domains = [&apos;blog.csdn.net&apos;] start_urls = [&apos;https://blog.csdn.net/weixin_41154636/article/list/1&apos;] def parse(self, response): try: for div in response.xpath(&apos;//div[contains(@class,&quot;article-item-box&quot;)]&apos;): item = CsdnItem() item[&apos;title&apos;] = div.xpath(&apos;./h4/a/text()&apos;)[1].extract().strip() item[&apos;url&apos;] = div.xpath(&apos;./h4/a/@href&apos;)[0].extract().strip() item[&apos;tag&apos;] = item[&apos;url&apos;].split(&apos;/&apos;)[-1] # 爬取时间戳，方便按时间排序 # item[&apos;date&apos;] = div.xpath(&apos;//span[@class=&quot;date&quot;]/text()&apos;)[1].extract().strip() # 我也不知道为什么抓出来会有这个- -，所以特殊处理一下 if item[&apos;title&apos;] == &apos;帝都的凛冬&apos;: continue # 控制台输出 print(item[&apos;title&apos;] + &quot; &quot; + item[&apos;url&apos;] + &quot; &quot; + item[&apos;tag&apos;]) # 封装成bean，装入数据库 yield item # 实现翻页的功能 for page in range(2, CsdnPage + 1): url = &quot;https://blog.csdn.net/weixin_41154636/article/list/%s&quot; % page yield scrapy.Request(url, callback=self.parse) except BaseException: print(BaseException.__cause__) pass 具体代码的说明注释已经写得很清楚了。 另外，需要注意的是，因为CSDN的翻页是通过ajax请求实现的，所以需要自己构造请求。 如果发现跑不起来，很可能是因为CSDN的HTML结构发生了改变，你可以了解一下XPATH的写法，然后修改即可。 先看下运行结果吧： 进入到spiders目录中运行 1scrapy crawl csdn_spider #你的爬虫名，在上面的代码最开始定义的 DONE！信息已经爬下来了，接下来就是把数据保存至数据库中。 保存数据至数据库在setting.py中，把pipeline注释去掉 123ITEM_PIPELINES = &#123; 'csdn.pipelines.CsdnPipeline': 300,&#125; 在piplines.py中编写一下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import pymysqlfrom scrapy.utils.project import get_project_settingsfrom twisted.enterprise import adbapifrom .items import CsdnItemclass DBHelper: def __init__(self): self.settings = get_project_settings() # 获取settings配置数据 dbparams = dict( host=self.settings['MYSQL_HOST'], # 读取settings中的配置 db=self.settings['MYSQL_DBNAME'], user=self.settings['MYSQL_USER'], passwd=self.settings['MYSQL_PASSWD'], charset='utf8', # 编码要加上，否则可能出现中文乱码问题 cursorclass=pymysql.cursors.DictCursor, use_unicode=False, ) # **表示将字典扩展为关键字参数,相当于host=xxx,db=yyy.... dbpool = adbapi.ConnectionPool('pymysql', **dbparams) self.dbpool = dbpool def connect(self): return self.dbpool # 插入数据 def insert(self, item): self.settings = get_project_settings() # 获取settings配置数据 if isinstance(item, CsdnItem): tb_name = self.settings['MYSQL_TABLE'] sql = """insert into """ + tb_name + """(id,title,link) values (%s,%s,%s) """ # print(sql) # 调用插入的方法 query = self.dbpool.runInteraction(self._conditional_insert, sql, item) # 调用异常处理方法 query.addErrback(self._handle_error) return item # 写入数据库中 def _conditional_insert(self, canshu, sql, item): # 取出要存入的数据，这里item就是爬虫代码爬下来存入items内的数据 if isinstance(item, CsdnItem): import datetime # 字符串转为DateTime类型 # dateTime_p = datetime.datetime.strptime(item['date'], '%Y-%m-%d %H:%M:%S') params = ( item['tag'], item['title'], item['url']) canshu.execute(sql, params) # 错误处理方法 def _handle_error(self, failue): pass print('--------------database operation exception!!-----------------') # self.connect.rollback() print(failue)# 这里执行scrapy处理脚本class CsdnPipeline(object): def __init__(self): self.db = DBHelper() def process_item(self, item, spider): # 插入数据库 self.db.insert(item) return item 具体说明注释已经写的很清楚了。 这样就完成了导入至数据库的工作 再次运行爬虫。 1scrapy crawl csdn_spider 可以看到，数据就全部自动导入到数据库了！]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机组成原理：系统总线总结]]></title>
    <url>%2F2019%2F08%2F14%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%9A%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总线的基本概念历史：早期计算机采用分散连接的方式，这种连接方式以运算器为中心，I/O与存储器交换信息时，都要通过运算器，致使运算器停止运算。为了提高CPU工作效率，改进为存储器为中心的分散连接。随着IO设备的增多，这种连接方式逐渐淘汰，所以出现了总线连接的方式。计算机使用总线结构便于增减外设，同时减少了信息传输线。 知识点： 总线：总线是连接多个部件的信息传输线，是各部件共享的传输介质。以CPU为中心的双总线结构：包括存储总线（M总线）和I/O总线，前者连接CPU和主存，后者连接CPU和I/O。缺点：这种结构在I/O与主存进行交换信息依然要占用CPU单总线结构:单独拉出一条系统总线，CPU，主存，和各IO设备连接到该系统总线。当I/O与主存进行交换信息时，CPU可以继续处理不访问主存或I/O设备的操作。缺点：因为只有一组总线。容器发生冲突，就必须设置判优逻辑，这会影响整机的工作速度以存储器为中心的双总线结构：在单总线的基础上又开辟了一条CPU与主存之间的总线（存储总线）。存储总线只提供主存与CPU直接的信息传输。有点像上面两种结构的折中。 总线的分类分类标准： 按数据传送方式可分为：并行传输总线和串行传输总线 按总线的使用范围可分为 计算机总线，测控总线，网络通信总线 （==重点==）按连接部件分 片内总线，系统总线，通信总线。片内总线：芯片内部的总线，如：CPU内部，寄存器和寄存器之间，寄存器和ALU之间都是由片内总线连接，速度极快。系统总线：系统总线是指：在CPU，主存，I/O设备各大部件之间的信息传输线。系统总线下面按照传输信息的不同又可分为数据总线，地址总线，控制总线1. 数据总线用来传输各部件之间的数据信息，双向数据线。2.地址总线用来指出数据总线上的源数据或目的数据所在主存单元或I/O设备的地址。单向传输：由CPU输出。用来指明CPU要访问的存储单元或I/O地址3.控制总线用来发出各种控制信号的传输线（控制信号，响应信号，时序信号）。对于某个特定的控制线来说他是单向的，但是从总体上看控制总线是双向的。 （举个例子，假如有A,B两条控制线，其中A的方向为CPU到I/O，B的方向为I/O到CPU，对于A,B来说，他们的控制信号传输方向是不能改变的，但从总体上看，控制总线既有从CPU-&gt;I/O的，也有I/O到CPU的，所以总体上是双向的） 通信总线按传输方式分为两种：串行通信和并行通信 1.串行通信串行通信是指单条1位宽的数据线，一位一位分时地进行传输。 2.并行通信多条并行的1位宽的数据，同时进行传输。 3.对比 - 串行通信 并行通信 优点 稳定，信号不易受到干扰 传输速率快 缺点 传输速率慢 易受干扰 适用场景 远距离传输 近距离传输 # 总线的特性及性能指标 ## 总线特性 1. 机械特性 指连接方式上的一些特性 2. 电气特性 指每个传输线的信号的传递方向和电平范围（什么范围为高？什么范围为低） 3. 功能特性 每个传输线的功能 4. 时间特性 任一根线在什么时间内有效 总线指标 总线宽度：数据总线的根数，用位（bit）表示 总线带宽：单位时间内总线上传输数据的位数 通常用MBps（兆字节每秒） （注意与bps进行区别，bps指的是波特率，是单位时间内传输的位数） 总线复用：一条信号线上分时传送两种信号。采用多路复用技术实现 时钟同步/异步 信号线数 总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等 其他指标：负载能力、电源电压、总线宽度是否可以扩展等 负载能力：指驱动能力，当总线接上负载后，总线输入输出的逻辑电平是否保持在额定范围内。 总线标准1. ISA总线 具有独立于CPU的总线时钟 总线宽度为16位，地址线为24位 CPU需花大量时间来控制和外部设备交换数据2.EISA总线 在ISA总线的基础得来，从CPU分离出了总线控制权 总线宽度为32位，地址宽度为32位3.VESA(VL-BUS)总线 总线宽度为32位，可扩展至64位4.PCI总线 高性能，不依赖某个具体的处理器，数据线为32位可扩展至64位 兼容性良好 支持即插即用（Plug and Play）（PCI和USB都支持） 采用多路复用技术 ………………. 5.AGP总线AGP（Accelerated Graphics Port 加速图形端口）处理三维数据和图形的总线，一般用于显卡。 6.RS-232C总线一种串行通信总线，可用于实现载波通信 7.USB总线通用串行总线（USB）具有以下特征 即插即用 很强的连接能力，可以连接多个外设到一个系统 数据传输率 1.0可达1.5Mbps 2.0可达480Mbps 标准统一 体积小巧 生命力强 总线结构一般分为单总线结构和多总线结构 单总线结构有个系统总线，CPU，主存，I/O设备都挂在上面，容易造成计算机性能的瓶颈。 多总线结构双总线结构：包括主存总线和I/O总线三总线结构：包括主存总线（CPU和主存之间）、I/O总线（CPU和IO之间）和DMA总线（主存和IO之间） 总线控制总线控制包括了判优控制和通信控制：主模块：主模块对总线有控制权从模块：从模块只能响应主模块发来的总线命令，没有总线控制权 判优控制判优控制可分为集中式和分布式两种 集中式 链式查询其控制总线由BS（总线忙）,BR（总线请求）,BG（总线同意）三条线构成。BG是串行地由一个I/O接口送到下一个I/O接口。如果到达的接口有请求，BG信号就不再往下传，意味着该接口获得了总线的使用权，然后建立BS（总线忙）信号。优先级逐级递减，对电路故障敏感 计数器定时查询相比链式查询，少了一根总线同意线（BG），多了一组设备地址线。工作方式： 总线控制器接到BR线送来的总线请求信号后，在总线未被使用的情况下（BS=0）由计数器开始计数，并通过设备地址线发出一组地址信号，然后某个与该信号一致的设备获得总线使用权。此时终止计数查询，查询可以从0开始（此时优先级逐级递减），也可以从上一次终止计数的地方开始（此时各部件优先级相同，这种也叫循环计数） 独立请求方式独立请求方式，每一设备都有单独的一组BR（总线请求）和BG（总线同意）。而总线控制部件中有一排队电路，可按优先次序确定响应哪个设备的请求。特点是响应时间短，速度快，但控制复杂 对比 - 优点 缺点 控制线数 链式查询 控制简单，仅用三根线即可控制并且很容易扩充设备 对电路故障敏感，低优先级的设备很难获得控制权 3根 计数器定时查询 优先次序可以被改变，对电路故障没那么敏感 增加了控制线，控制也比较复杂 ${log_2{n}}$ 独立请求方式 响应速度快，优先次序控制灵活 控制线线路较多，控制复杂 2n 分布式考纲和书上没有，不总结 通信控制目的：解决通信双方如何获知信息传输开始和传输结束，以及通信双方如何协调与配合可分为：同步，异步，半同步，分离式 总线周期（通信周期） 申请分配阶段由主模块提出申请，经过总线仲裁机构决定下一周期总线使用权给哪个申请者 寻址阶段获得了使用权的主模块通过总线发出本次要访问的从模块的地址和有关命令 传数阶段主模块和从模块进行数据交换。 结束阶段主模块让出总线控制权 通信方式同步通信通信双方由统一时钟信号控制下进行通信，时钟信号通常由CPU的总线控制部件发出，每个周期内完成特定的任务。 异步通信不采用统一的时钟信号控制通信，而采用应答的方式进行通信可分为：不互锁，半互锁，全互锁 1. 不互锁 对于主模块来说：主模块发出信息后，不需要等待街道从模块的回答信号，而是经过一段时间，便撤销请求信号 对于从模块来说：从模块接收到请求后，在条件就发出回答信号，并经过一段时间，便撤销回答信号。 应用场景：CPU向主存写信息 2.半互锁 对于主模块来说：主模块发出请求信号，必须接到从模块的回答信号才撤销其请求信号，有互锁关系 对于从模块来说：从模块接到请求信号后发出回答信号，而不必等待获知主模块的撤销请求信号，而是隔一段时间后就撤回回答信号，无互锁关系。 应用场景多机系统中，CPU访问共享存储器，CPU发出访存命令后，必须接收到存储器未被占用的回答信号，才能进行真正的访存操作 3.全互锁 对于主模块来说：主模块发出请求信号，必须接收到从模块的回答信号，然后发出撤销请求信号，存在互锁关系 对于从模块来说：从模块发出回答信号之后，必须等待获知主模块的撤销请求信号，存在互锁关系 应用场景：网络通信，例如著名的三次握手半同步通信半同步通信既保留了同步通信的特点（发送方所有的地址，命令、数据信号的发出时间在系统时钟的某个上升沿开始，接收方都采用系统时钟后沿时刻进行识别判断），同时又通过插入N个“等待”（WAIT）信号解决与协调通信速度不一致的问题，双方像异步通信那也，允许不同速度的模块进行工作分离式通信进一步分析总线传输周期得知，除了申请总线这一阶段，其余时间主要花在下面3个地方 主模块通过传输总线向从模块发出地址与命令 从模块准备数据 从模块经过数据总线向主模块发送数据 可以看见，在2中从模块准备数据的过程中，总线并没有完全利用，处于等待状态，为了发掘系统每一瞬间的潜力，因此采用了分离式通信。分离式通信将传输周期（or总线周期）分为两个子周期。 第一个子周期模块A在获得总线使用权后，将命令，地址等信息发到系统总线上，然后立刻放弃总线使用权，给别的模块使用 第二个子周期B模块接收到命令后，经过一段时间（译码，读取）准备好数据之后，申请总线控制权，一旦获批，B模块便把数据放到系统总线上，传输给A，然后立刻放弃总线控制权。显然：上面两个传输子周期都只有单方向的信息流，每个模块都变成了主模块。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习总结]]></title>
    <url>%2F2019%2F07%2F30%2FReact%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言前端可以做到读写数据、切换视图、用户交互，这意味着，网页其实是一个应用程序，而不是信息的纯展示。这种单张网页的应用程序称为 SPA（single-page-application）。2010年后，前端工程师从开发页面（切模板），逐渐变成了开发“前端应用”（跑在浏览器里面的应用程序）。目前，最流行的前端框架 Vue、Angular、React 等等，都属于 SPA 开发框架。 react脚手架建立工程1、安装1npm install create-react-app -g 2、创建1create-react-app react-demo (react-demo项目名) 3、初始化1cd react-demo 1npm install or cnpm install or yarn install 4、运行1yarn start 创建一个helloWorld Demo引入模块 12345//第一步 导入reactimport React,&#123;Component&#125; from 'react';import '../assets/css/index.css'import logo from '../assets/images/logo.svg';import '../assets/css/App.css'; 1234567891011121314151617181920212223242526272829303132/** * 绑定原生属性注意： * class 要换成className * for 要换成htmlFor * style 要用&#123;&#125;包裹成对象 *///第二步，编写组件类并继承React.Componentclass Home extends Component&#123; constructor()&#123; super(); //定义数据 this.state=&#123; msg:'你好，世界！' &#125; &#125;//第三步，重写render()方法，用于渲染页面 render()&#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.msg&#125;&lt;/h1&gt; &lt;img src=&#123;logo&#125; width='500px'&gt;&lt;/img&gt; &lt;/div&gt; ); &#125;&#125;//第四步，导出该类export default Home; 然后启动工程即可完成一个简单的demo 1yarn start react是面向组件的，通过JSX语法来操作虚拟dom节点，如果state的数据发生了变化则会触发对应的dom的刷新。JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 注意在本地引用img等资源时，需要通过{xx}对象形式引用。如果是网络图片，直接用url引用即可。 JSX语法就是，可以在js文件中插入html片段，是React自创的一种语法。JSX语法会被Babel等转码工具进行转码，得到正常的js代码再执行。所有标签必须闭合 react 通过state来定义和绑定数据，但这种绑定并不是MVVM那种双向数据绑定，在JSX中要使用时通过 123456789101112131415161718192021## 知识点：### 1. 目录结构分析![20190816155754](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155754.png!blog)用脚手架创建的工程的目录是有些不完整的，需要补全（为了方便归档）component文件主要放组件，model放数据模型，App.js是默认的根组件，index.js是入口文件，相当于main，yarn.lock是项目生成的临时文件，package.json是依赖管理文件（类似maven的pom文件），nodel_modules是存放依赖包的文件夹### 2. 创建组件第一步 导入react第二步，编写组件类并继承React.Component第三步，重写render()方法，用于渲染页面第四步，导出该类### 3. JSX注意事项如果要在模板中嵌套多个HTML标签，需要使用一个父元素对其进行包裹 &lt;div&gt; &lt;h1&gt;{this.state.msg}&lt;/h1&gt; &lt;img src={logo} width=&apos;500px&apos;&gt;&lt;/img&gt; &lt;/div&gt;12345### 4.绑定数据或对象js中定义对象用&#123;&#125;,其实就是restful风格的东东。类似于 { title:”xxx”, content:”xxxx”} 123数据的定义用[ ]，一对方括号即可。在react中绑定对象只需要在state中定义即可 this.state={ msg:’你好，世界！’ } 12# 事件及数据绑定Demo import React from ‘react’ class Demo1 extends React.Component{ constructor(props){ super(props); this.state={ msg:”demo1组件”, text:””, keydown:””, } } run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; } inputChange=(e)=&gt;{ //获取表单的值 //console.log(e.target.value); this.setState({ text: e.target.value }) } inputChange1=()=&gt;{ let value = this.refs.input.value; this.setState({ text: value }) } getInputValue=()=&gt;{ alert(this.state.text) } inputOnKeydown = (e)=&gt;{ console.log(e.keyCode); this.setState({ keydown:e.keyCode }) } inputChange2 = (e)=&gt;{ this.setState({ text:e.target.value }) } changeTextMode = (e)=&gt;{ this.setState({ text:&quot;改变后的model值,可以看到下面这个输入框的数据已经改变，而上面两个输入框未发生变化&quot; }) } render(){ return ( &lt;div&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;事件对象演示&lt;/h2&gt; {this.state.msg} {/* 事件对象 */} &lt;button id=&apos;buttonId&apos; onClick={this.run}&gt;事件对象&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;表单事件演示&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input type=&quot;text&quot; onChange={this.inputChange}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;ref获取dom节点,获得表单值&lt;/h2&gt; &lt;p&gt;{this.state.text}&lt;/p&gt; &lt;input ref=&apos;input&apos; type=&quot;text&quot; onChange={this.inputChange1}/&gt; &lt;button onClick={this.getInputValue}&gt;获取表单值&lt;/button&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;键盘事件&lt;/h2&gt; &lt;p&gt;{this.state.keydown}&lt;/p&gt; &lt;input type=&quot;text&quot; onKeyDown={this.inputOnKeydown}/&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h2&gt;react实现双向数据绑定&lt;/h2&gt; &lt;p&gt;model改变影响view(通过value属性),view改变影响model&lt;/p&gt; &lt;p&gt;model值：{this.state.text}&lt;/p&gt; &lt;input type=&apos;text&apos; value={this.state.text} onChange={this.inputChange2}&gt;&lt;/input&gt; &lt;button onClick={this.changeTextMode}&gt;改变model的值&lt;/button&gt; &lt;/div&gt; ) }} export default Demo1 ; 123456789![20190816155821](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155821.png!blog)## 知识点：### 事件绑定：1. 绑定事件需要在对应的事件响应中获得正确的this对象 例如：为Button 绑定了一个事件 事件对象 12如果你用箭头函数写响应方法，则this指向的就是react的当前组件 run=(e)=&gt;{ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12如果你用的是普通写法写的函数响应 funtion run(e){ alert(e.target.getAttribute(&apos;id&apos;)) //获取当前执行事件的dom节点 e.target.style.background=&apos;red&apos;; }12需要使用下面这种写法传递对象指向 事件对象 12### 数据绑定（View-&gt;Model） {this.state.text} 12 inputChange=(e)=&gt;{ //获取表单的值，设置model的数据 //console.log(e.target.value); this.setState({ text: e.target.value }) }12### 数据绑定（Model-&gt;View） 获取表单值 12 getInputValue=()=&gt;{ alert(this.state.text) //获取model中的数据 } 12### 双向数据绑定（M-&gt;V&amp;V-&gt;M 俗称MVVM） react实现双向数据绑定 model改变影响view(通过value属性),view改变影响model model值：{this.state.text} 改变model的值 12345678value 通过属性绑定model 完成 m-&gt;v的绑定通过监听onChange完成v-&gt;m的绑定 ，和上面那个View-&gt;Model的绑定是一样的。# TodoList小练习该练习的旨在熟悉双向数据绑定和react的基础用法，另外扩展了localStorage缓冲处理方案，实现刷新不会丢失数据状态。![20190816155842](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155842.png!blog) import React, {Component}from ‘react’;import Storage from ‘../model/storage’ class Demo3 extends Component { constructor(props) { super(props); this.state = { todo:’’, todolist:[], }; } //生命周期函数，页面加载触发 componentDidMount=()=&gt;{ let list = Storage.get(&apos;todolist&apos;); if(list){ console.log(&quot;get:&quot;+list) this.setState({ todolist:list }) } } addTodoText=(e)=&gt;{ this.setState({ todo: e.target.value }) } onAddBtnClick=()=&gt;{ let todolist = this.state.todolist; todolist.push({ todo:this.state.todo, checked:false }) this.setState({ todolist:todolist, todo:&quot;&quot; }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } onPressEnter=(e)=&gt;{ if(e.keyCode==13){ this.onAddBtnClick(); } } ondelBtnClick=(index)=&gt;{ let todolist = this.state.todolist; todolist.splice(index,1); this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } checkChange = (index)=&gt;{ let todolist = this.state.todolist; todolist[index].checked=!todolist[index].checked; this.setState({ todolist:todolist }) //缓存数据 Storage.set(&quot;todolist&quot;,todolist); } render() { return ( &lt;div&gt; &lt;h2&gt;todoList 演示&lt;/h2&gt; &lt;header&gt;&lt;input type=&quot;text&quot; value={this.state.todo} onChange={this.addTodoText} onKeyDown={this.onPressEnter}/&gt; &lt;button onClick={this.onAddBtnClick}&gt;增加&lt;/button&gt;&lt;/header&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;未完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(!value.checked){ return ( &lt;div key={index}&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;hr&gt;&lt;/hr&gt; &lt;h4&gt;已完成事项&lt;/h4&gt; &lt;ul&gt; { this.state.todolist.map((value,index)=&gt;{ if(value.checked){ return ( &lt;div key={index} className=&apos;complete&apos;&gt; &lt;input type=&apos;checkbox&apos; checked={value.checked} onChange={this.checkChange.bind(this,index) }/&gt;-----{value.todo} &lt;button onClick={this.ondelBtnClick.bind(this,index)}&gt;删除&lt;/button&gt; &lt;/div&gt; ) } }) } &lt;/ul&gt; &lt;/div&gt; ); }} export default Demo3; 12345678&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;# 远程请求数据Demo通过axios向服务端请求数据，我这里没有通过配置代理解决跨域问题，而是在后端配置了取消CROS请求来解决跨域问题 import React from ‘react’import axios from ‘axios’import request from ‘../model/server’import jsonp from ‘fetch-jsonp’ class Demo4 extends React.Component { constructor(props) { super(props); this.state = { list:[], }; } getData = ()=&gt;{ let api = ‘http://localhost:18080/house/resources/findAll&#39; axios.get(api) .then((response)=&gt;{ console.log(response) this.setState({ list:response.data }) }) .catch((error)=&gt;{ console.log(error) }) // let data =await request.get(api) // console.log(data) } render() { return ( &lt;div&gt; &lt;h2&gt;axios获取服务器数据,未处理跨域，取消cros&lt;/h2&gt; &lt;button onClick={this.getData}&gt;获取服务器数据&lt;/button&gt; &lt;p&gt;url:&lt;a href=&apos;http://localhost:18080/house/resources/findAll&apos;&gt;http://localhost:18080/house/resources/findAll&lt;/a&gt;&lt;/p&gt; &lt;ul&gt; { this.state.list.map((value,index)=&gt;{ return ( &lt;li key={index}&gt;{value.created}&lt;/li&gt; ) }) } &lt;/ul&gt; &lt;h2&gt;jsonp获取服务器数据,跨域请求&lt;/h2&gt; &lt;p&gt;怎么看，看你的地址加入callback=xxx之后是否能访问就知道是否支持jsonp了&lt;/p&gt; &lt;/div&gt; ); }} export default Demo4; 12345678910111213![1565942347213](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\1565942347213.png)## 知识点：### 1. 跨域问题所谓跨域问题就是 协议，域名，端口三者有其一不一致则出现跨域，一般情况下跨域是不被浏览器支持的。### 2. axiosAxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。使用 npm install –save axios 1234# React-router 4.x基本配置及动态路由使用### 安装 cnpm install react-router-dom –save 12### 引入 import {BrowserRouter as Router,Route,Link} from ‘react-router-dom’ 12### 基本使用： 首页 新闻 12345678910111213141516![20190816155928](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155928.png!blog)![20190816155957](https://zhong-blog.oss-cn-shenzhen.aliyuncs.com/blog/20190816155957.png!blog)### 动态路由的使用#### 定义路由 12#### 使用路由 { this.state.list1.map((value,key)=&gt;{ return ( //ES6模板字符串写法 &lt;Link to={/content/${value.aid}?content=${value.content}} key={key}&gt; {value.title} ) })} 12#### 在子组件中获得动态路由的传参 aid:this.props.match.params.aid, 123456789在prps.match.params中获取传参即可### 利用get实现动态路由无需定义路由格式，直接使用，在路由后面像get方法一样传参类似"?name=zhong"这种#### 使用路由 {value.title} 12345其中**?content=$&#123;value.content&#125;** 就是使用了get传参#### 在子组件中获得动态路由的传参 componentDidMount(){ //通过npm带的url模块解析get参数 cnpm install url --save 安装即可 console.log(url.parse(this.props.location.search,true)) let news = { aid:this.props.match.params.aid, //通过动态路由传值 content:url.parse(this.props.location.search,true).query.content, //通过get传值 } this.setState({ news:news }) }```]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot下采用Dubbo进行服务治理]]></title>
    <url>%2F2019%2F07%2F19%2FSpringBoot%E4%B8%8B%E9%87%87%E7%94%A8Dubbo%E8%BF%9B%E8%A1%8C%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%2F</url>
    <content type="text"><![CDATA[Dubbo 是什么Apache Dubbo™ (incubating)是一款高性能Java RPC框架官网：http://dubbo.apache.org/zh-cn/index.html使用感受：Dubbo将传统的服务调用关系分为了消费者和提供者。符合现在前后端分离的这种模式。 Dubbo架构如图节点角色说明： 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 使用记录主要记录dubbo的工作流程，加深理解，如果需要详细的配置及代码请移步度娘 1、服务注册中心使用zookeeper作为服务注册中心，将其部署在docker上。Zookeeper 是 Apacahe Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用。 部署+启动12345678#启动dockerservice docker start#拉取镜像docker pull zookeeper:3.5#创建容器docker create --name zk -p 2181:2181 zookeeper:3.5#启动容器docker start zk 启动成功后，可查看容器运行情况 1docker ps 默认端口是2181。 2、SpringBoot下引入Dubbo进行服务治理最明显的感受就是dubbo是非侵入性的，原先的service可以不发生改变，由dubbo调用该service并暴露一个dubbo服务接口给controller，简单的代码就可以实现服务治理。 2.1dubbo配置在springboot的配置文件application.properties中 1234567891011121314151617#Dubbo配置# Service versiondubbo.service.version = 1.0.0# 服务的扫描包dubbo.scan.basePackages = zhong.dubbo.server.api# 应用名称dubbo.application.name = dubbo-provider-house-resources# 协议以及端口dubbo.protocol.name = dubbodubbo.protocol.port = 20881# zk注册中心dubbo.registry.address = zookeeper://192.168.146.128:2181dubbo.registry.client = zkclient 2.2dubbo使用2.2.1定义dubbo服务接口dubbo的服务要实现此接口，同时，该接口也是暴露给外层应用调用的，需要注意的是，要把接口和实现分开。 2.2.2实现dubbo服务接口新增一个api包，在这里使用dubbo并暴露出dubbo服务的接口给表现层（我随便说的，感觉像类似） 1234567891011121314151617/** * 这个是dubbo服务，不要和spring的服务搞混了 */@Service(version = "1.0.0")public class HouseResourcesService implements ApiHouseResourcesService &#123; /** * 注入的是spring的服务 */ @Autowired private zhong.dubbo.server.service.HouseResourcesService houseResourcesService; @Override public int saveHouseResources(HouseResources houseResources) &#123; return this.houseResourcesService.saveHouseResources(houseResources); &#125;&#125; 2.3查看dubbo服务利用dubbo-admin即可查看注册的服务如果没配置过dubbo-admin，可以看这篇https://blog.csdn.net/weixin_41154636/article/details/96478016 2.3调用dubbo在Controller中，因为在上一步中已经完成dubbo服务接口的定义及实现，并且把dubbo 服务的接口注入到spring容器中了。所以只需要在controller中调用duddo服务即可。使用起来非常简单呢。 1234567891011121314151617181920212223242526272829303132@RequestMapping("house/resources")@Controllerpublic class HouseResourcesController &#123; @Autowired private HouseResourcesService houseResourcesService; /** * * @param houseResources 接收json数据 * @return */ @PostMapping @ResponseBody public ResponseEntity&lt;Void&gt; save(@RequestBody HouseResources houseResources)&#123; try &#123; boolean success = this.houseResourcesService.save(houseResources); if(success)&#123; return ResponseEntity.status(HttpStatus.CREATED).build(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build(); &#125; @GetMapping @ResponseBody public ResponseEntity&lt;String&gt; get()&#123; return ResponseEntity.ok("ok"); &#125;&#125; 可以从dubbo-admin中看到消费者列表这个时候这里的消费者就是指某个controller，这里只是完成了服务的订阅，当某个请求过来的时候，才是真正的服务调用，dubbo会根据负载均衡的不同策略对已注册的服务选择调用。 Dubbo的工作流程总结 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo-Admin的配置以及遇到的坑]]></title>
    <url>%2F2019%2F07%2F19%2FDubbo-Admin%E7%9A%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Dubbo-Admin下载配置环境： linux centos7在github上clone到本地即可 1git clone https://github.com/apache/dubbo-admin.git 前端配置dubbo采用前后端分离部署，所以他的部署相对有点麻烦，如果按照官方的文档，像个铁憨憨一样c+v，则会出现npm install fail 等错误。因为前端工程是用vue开发的，所以得先配个node.js即可，node.js中自带了npm。首先进入前端工程目录下 1cd dubbo-admin/dubbo-admin-ui 修改前端工程端口及配置信息如果需要修改前端工程端口或其他配置信息，进入到 1vim config/index.js 配置文件下修改即可需要注意的是，如果修改了后端的端口，记得修改ProxyTable的配置 构建dubbo-admin前端工程运行 1npm install 启动dubbo-admin前端工程在当前目录下，运行 1npm run dev 运行前端项目，然后就应该可以访问页面了。 配置后端项目进入后端工程，后端是用springboot和Maven构建的。所以如果你没配置maven的话，可以在先配个maven在linux中配置maven非常简单，具体操作咨询度娘。 修改后端配置修改注册中心端口1vim dubbo-admin-server/src/main/resources/application.properties 在这里主要配置注册中心的端口因为我的zookeeper（服务注册中心）是部署在本机的，所以用本机地址即可。 修改dubbo-admin后台服务端口默认端口为8080，如果需要更改，加入配置 1server.port=&lt;端口号&gt; 构建进入到dubbo-admin-server目录下，进行构建，如果直接在项目根目录构建会出错。 1cd dubbo-admin-server 运行 1mvn clean package 将项目打包，正常情况下的能构建成功的，如果是npm fail失败的原因，请仔细检查前端工程的配置或是否将前端工程build和install 启动运行 1mvn --projects dubbo-admin-server spring-boot:run 然后你再次访问前端页面，就可以监视到通过dubbo注册在zookeeper的服务了。]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加法器的实现及优化]]></title>
    <url>%2F2019%2F07%2F07%2F%E5%8A%A0%E6%B3%95%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1、半加器半加器有一个异或门和与门组成，异或门赋值记录数值，与门记录是否产生了进位。但是半加器是无法完成加法运算的。 需要完成加法运算，需要用到全加器 2、全加器 全加器由两个半加器组成，绿色的为一个半加器，橙色的为另一个半加器。三个输入，两个输出。 两个输出表示了他能表示的范围为0,1,2,3 对应的二进制则为表上的Cout 与 S 例如进行1+1的运算时 先来看看S的输出： A端输入1，B端输入1，C端输入0（最低位加法运算默认为0），1（A）异或1（B） 结果为0（记为D）0（D）+0（Cin）结果是0，所以绿色的异或门输出（S）为0，说明该位的运算结果为0。 再来看看Cout（进位）的输出： 1（A）与1（B） 结果为1，说明产生了进位，橙色的与门输出1。由S的输出过程可得绿色的与门的输入为0,0，绿色的与门输出为0，这个时候需要一个或门即可判断两次加法（A+B和B+Cin）是否产生了进位，只要其中一个产生的进位，Cout置1。 运算结果： 将Cout与S连起来，就是10，也就是2。 减法的实现：减法实际上就是加法 A-B 可以表示为 A+ （-B） 这个-B可以用补码来表示。 如上图所示，sub-mode负责加减法的选择，同时他连接到最低位的Cin端。 如果为加法，则sub-mode为0，那么直接进行加法运算 如果为减法，则sub-mode为1，最低位数字Cin（C0端）被置为1，同时控制电路对B的每一位是输入数字作取反处理，这样就完成的（-B）补码的“按位取反，末位加一”的操作。然后按加法运算即可 3、行波进位加法器行波进位加法器就是由n个全加器构成的，可以运算n位的加法。 例如计算：1101+0110。将每个低位的Cout（进位输出）作为对应高位的Cin（进位输入）。 这里Cout最高位为1，而假设我们当前的寄存器的位数为4位，则产生了溢出。 溢出和进位的区别：溢出：表示数据超过了正常的表示范围，如果采用浮点表示还分成上溢出和下溢出。 进位：N进制进位这个就是逢N进一 需要注意，溢出和进位并没有直接关系。溢出的发生只在有符号位时发生，也就是说你的机器数是带符号的就有可能产生溢出。 判断溢出的方法：1、最高位数值和符号位都发生了进位或者都不产生进位，则没有溢出。最高位数值和符号位有一个产生进位，另一个没有进位，则为溢出。计算机实现用异或电路 例如 1,111+0,100 -&gt;10011(舍去最高位) ，最终结果为 0,011 未发生进位 2、如果采用两位符号位表示，原理和方法1一样，采用了两位符号位来记录原来的1位符号位和最高数值位的进位情况，这样就不需要用异或电路。符号位为00或11则未溢出，如果为01为正溢出（此时真正的符号位正），10为负溢出（此时真正的符号为负） 行波进位加法器的运算过程：在进行加法运算时，首先准备好的是（从右往左为1,2,3,4号）1号全加器的3个input。而2、3、4号全加器的Cin全部来自前一个全加器的Cout，只有等到1号全加器运算完毕，2、3、4号全加器才能依次进行进位运算，最终得到结果。 这样进位输出，像波浪一样，依次从低位到高位传递， 最终产生结果的加法器，也因此得名为行波进位加法器（Ripple-Carry Adder，RCA）。 RCA的优点是电路布局简单，设计方便， 我们只要设计好了全加器，连接起来就构成了多位的加法器。 但是缺点也很明显，也就是高位的运算必须等待低位的运算完成， 这样造成了整个加法器的延迟时间很长。那么，RCA的效率到底如何呢？让我们来算一算： 将4bit的RCA内部结构全部打开，就得到了如图2所示的4-bit RCA的门电路图。要对一个电路的性能进行分析，我们就要找出其中的最长路径。 也就是找出所有的从输入到输出的电路连接中，经过的门数最多的那一条，也称为关键路径（如下图所示）。 判断延迟的两个指标：（1）门延迟经过每个门所花费的实际，称为门延迟 （2）线延迟输入信号进入到这块电路之后，在连接线上传递需要花时间。 称为线延迟 行波进位加法器的延迟分析：以只考虑门延迟为例 从第一个全加器的A-S这条通路来看，产生第一个S输出，需要通过两个门的延迟。 所以它显然不是最长的路径，当然，从A出发或着从B出发都是一样的， 所以对于第一个全加器，它的最长路径，是红色线标记的那条，后面的全加器关键路径同理可得。 那么，假设经过一个门电路的延迟时间为T，那么经过4个全加器所需要的总延迟时间就是：2T x 4 + T(第一个全加器产生3个T) = 9T。所以推出，经过n个全加器所产生的总延迟时间为2T x n + T = (2n+1)T。 对于一个32bit的RCA，有总延迟时间：(2n+1)T =(2×32+1)×T =65T，这是什么概念呢？举个例子，iPhone 5s的A7 SoC处理器采用28nm制造工艺，主频1.3GHz（0.66ns CPU时钟周期中每两个上沿所隔的时间）。按照这个工艺水平，门延迟T设为0.02ns，那么32-bit RCA的延迟时间为1.3ns ，时钟频率为769MHz，远超A7处理器的主频延迟时间，更别说这个32bit的RCA只是一个加法运算器，更更别说，我们在计算过程中只考虑了门延迟，还有线延迟等各种延迟没有加入计算…… 4、超前进位加法器从上面可以看到，影响行波进位加法器（RCA）运算效率的主要因素是高位的运算必须等待低位的“进位输出信号”，那我们的优化思路就是‘能否提前计算出“进位输出信号’ ？” 答案是有的，如图所示。 全加器有三个输入，当其中的两个为1时，必定产生进位。这样就有了如下的公式： Ai Bi Ci 分别是全加器的三个输入，Ci+1为进位输出 Ci为进位输入。 如果是最低位，则Ci=C0，C0根据加法或是减法置为0或者1。 简化公式得： 如果表示4个全加器的进位输入输出： 可以得到由每个低位全加器的进位输出得到每个高位全加器的进位输入。 最终我们需要得到的是C4，经过换算，C4=G3+P3·G2+P3·P2·G1+P3·P2·P1·G0+P3·P2·P1·P0·C0，而这些参数，全部已知！并不需要前一个全加器运算输出，由此我们得到了提前计算进位输出的方法， 用这样的方法实现了加法器就被称为超前进位加法器（Carry-Lookahead Adder，CLA）。 这样就实现了提前获得进位输入的能力，这样就大大提高了加法运算的效率。但有得必有失，这样的代价是电路比较复杂。 超前进位加法器的实现 C4的结果由或门实现，把每个多项式进行求和，乘用与门实现。 延迟分析 使用CLA来进行加法运算的效率如何呢？还是按照Apple A7处理器的工艺水平，单个CLA的延迟为0.08ns，4级CLA的延迟为0.26ns，时钟频率3.84GHz，都远远小于主频的延迟，完全符合标准。然而，由图可见，计算4bit的二进制数，就要平行排列4个全加器，那么要是计算8bit，16bit，32bit……的呢？可能就需要更复杂的布线方式，这就是CLA的缺点。 比较一下RCA和CLA的优缺点： 行波进位加法器（RCA） 超前进位加法器（LCA） 结构特点 低位全加器的Cout连接到高一位全加器Cin 每个全加器的进位输入并不来自于前一级的全加器，而是来自超前进位的逻辑电路 优点 电路布局简单，设计方便 计算Ci+1的延迟时间固定为三级门延迟，与加法器的位数无关 缺点 高位的运算必须等待低位的运算完成，延迟时间长 如果进一步拓宽加法器的位数，则电路变得非常复杂 32位的加法器如果采用行波进位的方式，我们已经分析过需要65级的门延迟， 那如果采用超前进位的方式，理想情况下也只需要四级的门延迟，但可惜的是， 这也只是一个理想。因为要实现32位的完全的超前进位，电路就会变得非常的复杂。 因此通常的实现方法， 是采用多个小规模的超前进位加法器拼接而成一个较大的加法器，例如，用4个8-bit的超前进位加法器连接成32-bit加法器。]]></content>
      <categories>
        <category>计算机理论</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（十）矢量压缩算法-光栏法]]></title>
    <url>%2F2019%2F06%2F01%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%E7%9F%A2%E9%87%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95-%E5%85%89%E6%A0%8F%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言：远程仓库地址：https://github.com/XiaoZhong233/GIS_ALG 光栏法是一种矢量数据的压缩算法。光栏法的基本思路是对每一条曲线上的所有点, 逐点定义一个扇形区域。若曲线的下一节点在扇形外, 则保留当前节点; 若曲线的下一节点在扇形内, 则舍去当前节点。 说明：光栏法与道格拉斯算法都是矢量压缩算法，但是光栏法能很好的保存线的形状，而道格拉斯普克算法是概化算法，他的作用主要是把凹凸不平的折线变得平直，因此算“概化”算法 算法步骤： 1、输入光栏的口径d 这个口径也就是每次扫描的扇形区域，若曲线的下一节点在扇形外, 则保留当前节点; 若曲线的下一节点在扇形内, 则舍去当前节点。 2、读取坐标 1、2两点坐标，记入p1，p2 3、建立光栏 连接p1和p2点，过 p2点作一条垂直于p1p2 的直线，在该垂线上取 两点a1和a2，使a1p2＝ a2p2＝d／2，此时a1和 a2为“光栏”边界点， p1与a1、p1与a2的连线 为以p1为顶点的扇形的 两条边，这就定义了一 个扇形(这个扇形的口朝 向曲线的前进方向，边 长是任意的)。通过p1并在扇形内的所有直线都具有这种性质， 即p1p2上各点到这些直线的垂距都不大于d/2。 若p3点在扇形内，则舍去p2点。然后连接p1和p3，过p3作 p1p1的垂线，该垂线与前面定义的扇形边交于c1和c2。在垂线 上找到b1和b2点，使p3b1＝p3b2＝d／2，若b1或b2点落在原扇 形外面，则用c1或c2取代。此时用p1b1和p1c2定义一个新的扇 形，这当然是口径(b1c2)缩小了的“光栏”。 4、检查下一节点 若该点在新扇形内，则重复第(2)步；直 到发现有一个节点在最新定义的扇形外为止。 当发现在扇形外的节点，如p4，此时保留p3点，以p3作为 新起点，重复1°～3°。如此继续下去，直到整个点列检测完 为止。所有被保留的节点(含首、末点)，顺序地构成了简化后 的新点列。 实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798 /** * 光栏法压缩折线 * @param caliber 口径 * @return */ public Polyline simplify_LightBar(double caliber) &#123; if(caliber&lt;=0) return null; if(this.points.size()&lt;2) &#123; return this; &#125; //求光栏下边界 List&lt;Point&gt; points = this.getPoints(); Point p1 = points.get(0); Point p2 = points.get(1); Line line = new Line(p1,p2); double len = line.getLength(); double angle1 = Math.toDegrees(Math.atan2(.5*caliber,len)); double angle2 = line.getVector2D().getAngle(); //求光栏下边界 Line down = new Line(angle2-angle1, p1); //求光栏上边界 Line up = new Line(angle1+angle2,p1); // //计算光栏a1,a2坐标// //p1p2直线的法线矢量// Vector2D n = line.getN();// //光栏垂直平分线的垂线// Line l = new Line(n,p2);// Point a1 = l.intercourse(down);// Point a2 = l.intercourse(up); for(int i=2;i&lt;points.size();i++) &#123; Point p = points.get(i); //如果下一个点在光栏内，则删除上一个点，当前点为新p2 //如果不在，则保留上一个点，以上一个点为新p1 if(isInLightBar(up, down, p)) &#123; points.get(i-1).setEnable(false); p2=p; //求当前点与p1的垂线 Line line2 = new Line(p1,p2); Vector2D nn = line.getN(); Line line3 = new Line(nn,p); //建立新的光栏 double length = line2.getLength(); double angle11 = Math.toDegrees(Math.atan(.5*caliber/length)); double angle22 = line2.getVector2D().getAngle(); Line newDown = new Line(angle22-angle11, p1); Line newUp = new Line(angle11+angle22,p1); //求当前点与p1的连线的垂线与新光栏的交点 Point b1 = line3.intercourse(newDown); Point b2 = line3.intercourse(newUp); //检查新光栏的交点是否在原光栏内 //如果在就使用新光栏，不在就构建另一个光栏 if(isInLightBar(up, down, b1) &amp;&amp; isInLightBar(up, down, b2)) &#123; down = newDown; up = newUp; &#125;else &#123; //只有b1在光栏内 if(isInLightBar(up, down, b1)) &#123; down = new Line(p1,b1); &#125; if(isInLightBar(up, down, b2)) &#123; up = new Line(p1,b2); &#125; &#125; &#125;else &#123; points.get(i-1).setEnable(true); p1=points.get(i-1); p2=points.get(i); line = new Line(p1,p2); len = line.getLength(); angle1 = Math.toDegrees(Math.atan(.5*caliber/len)); angle2 = line.getVector2D().getAngle(); //求光栏上下边界 down = new Line(angle2-angle1, p1); up = new Line(angle1+angle2,p1); &#125; &#125; List&lt;Point&gt; selectedPoints = new ArrayList&lt;&gt;(); Collections.addAll(selectedPoints, new Point[this.points.size()]); Collections.copy(selectedPoints, this.points); Iterator&lt;Point&gt; iterator = selectedPoints.iterator(); while (iterator.hasNext()) &#123; Point point = (Point) iterator.next(); if(!point.isEnable()) &#123; iterator.remove(); &#125; &#125; return new Polyline(selectedPoints); &#125; 12345678910111213141516171819/** * 判断点是否光栏内 * @param up * @param down * @param point * @return */private static boolean isInLightBar(Line up,Line down,Point point) &#123; Point start = up.getStart(); Line line = new Line(start,point); Vector2D upVector = up.getVector2D(); Vector2D downVector = down.getVector2D(); Vector2D target = line.getVector2D(); //利用矢量的叉积判断即可 if(target.crossProduct(upVector)&gt;=0 &amp;&amp; target.crossProduct(downVector) &lt;=0) &#123; return true; &#125; return false;&#125; 运行结果：原始数据： 光栏法压缩后（阈值5） 因为有两条折线，所以概化了两次 再次使用光栏法压缩（阈值调为10） 再次使用光栏法压缩（阈值调为20） 再次使用光栏法压缩（阈值调为50） 总结与道格拉斯算法的对比： 道格拉斯普克算法采用递归实现，它需要对整条曲线进行扫描，才能进行压缩，而且采用递归，计算量较大。 光栏法能给定阈值保留曲线特征点、并且他和道克拉斯普克算法最大的不同是，他能实时计算的，且计算量较小，占用的内存也小了。 因此光栏法是一种优秀高效的矢量压缩算法]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（九）矢量压缩算法-道格拉斯普克算法]]></title>
    <url>%2F2019%2F06%2F01%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%E7%9F%A2%E9%87%8F%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95-%E9%81%93%E6%A0%BC%E6%8B%89%E6%96%AF%E6%99%AE%E5%85%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言道格拉斯-普克算法 (Douglas–Peucker algorithm，亦称为拉默-道格拉斯-普克算法、迭代适应点算法、分裂与合并算法)是将曲线近似表示为一系列点，并减少点的数量的一种算法。它的优点是具有平移和旋转不变性，给定曲线与阈值后，抽样结果一定。因为网上关于道格拉斯普克算法的讲解很多，主要是使用递归实现的，这里就不赘述了。 远程仓库地址： https://github.com/XiaoZhong233/GIS_ALG 直接上代码和演示 123456789101112131415161718192021222324252627282930313233343536//概化折线 道格拉斯普克算法/** * 根据中间点到首尾点的连线的距离与阈值的关系判断是否保留某点 * @param threshold 阈值越小，保留的点越多，抽稀程度低；阈值越大，删除的点越多，抽稀程度高 * @return */public Polyline simplify_Douglas_Peucker(double threshold) &#123; //初始化 for(Point point:this.getPoints()) &#123; point.setEnable(true); &#125; List&lt;Point&gt; selectedPoints = new ArrayList&lt;&gt;(); Collections.addAll(selectedPoints, new Point[this.points.size()]); Collections.copy(selectedPoints, this.points); simplify(selectedPoints, threshold); //标记了删除的点，全部删掉 Iterator&lt;Point&gt; iterator = selectedPoints.iterator(); while (iterator.hasNext()) &#123; Point point = (Point) iterator.next(); if(!point.isEnable()) &#123; iterator.remove(); &#125; &#125; if(debug) &#123; System.out.println("最后保留的点："); for(Point p:selectedPoints) &#123; System.out.println(p.toString()); &#125; &#125; //恢复 for(Point point:this.getPoints()) &#123; point.setEnable(true); &#125; return new Polyline(selectedPoints);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * * @param polyline 折线 * @param threshold 阈值越小，保留的点越多，抽稀程度低；阈值越大，删除的点越多，抽稀程度高 * @return */public static Polyline simplify_Douglas_Peucker(Polyline polyline,double threshold) &#123; return polyline.simplify_Douglas_Peucker(threshold);&#125;//抽稀点private static void simplify(List&lt;Point&gt; points,double threshold) &#123; //threshold = Math.abs(threshold); if(points.size()&lt;3) &#123; return; &#125; Line line = new Line(points.get(0),points.get(points.size()-1)); Point maxPoint = null; double maxDis = 0; //System.out.println(points.size()); for(Point point:points) &#123; double dis = line.getDistancefromPoint(point); if(debug) &#123; System.out.println(point.toString()); &#125; //System.out.println(dis); if(Double.doubleToLongBits(dis)&gt;Double.doubleToLongBits(maxDis) &amp;&amp; line.getStart()!=point &amp;&amp; line.getEnd()!=point) &#123; maxDis = dis; maxPoint = point; &#125; &#125; if(debug) &#123; System.out.println("max:"+maxDis); System.out.println("阈值:"+threshold); System.out.println("保留最大点与首尾点"); &#125; //保留最大点与首尾点 if(maxDis&gt;threshold &amp;&amp; maxPoint!=null) &#123; if(debug) &#123; System.out.println("最大点:"+maxPoint.toString()); &#125; //涉及到删除元素不可以用for或while循环，因为会改变元素的位置 Iterator&lt;Point&gt; iterator = points.iterator(); while (iterator.hasNext()) &#123; Point p = (Point) iterator.next(); if(!(p==line.getStart()||p==line.getEnd()||p==maxPoint)) &#123; //标记不可用，这里指删除 //因为还需要留着左右部分的点做进一步的简化，不可以在这里进行删除操作 防止被gc掉 p.setEnable(false); if(debug) &#123; System.out.println("删除的点："+p.toString()); &#125; &#125;else &#123; p.setEnable(true); if(debug) &#123; System.out.println("保留的点："+p.toString()); &#125; &#125; &#125; //以maxPoint把折线分为两部分接着简化 List&lt;Point&gt; leftPart = points.subList(0, points.indexOf(maxPoint)+1); List&lt;Point&gt; rightPart = points.subList(points.indexOf(maxPoint), points.size()); if(debug) &#123; System.out.println(String.format("left [1]-[%d]", points.indexOf(maxPoint)+1)); System.out.println(String.format("right [%d]-[%d]", points.indexOf(maxPoint)+1, points.size())); &#125; simplify(leftPart, threshold); simplify(rightPart, threshold); //只保留首尾点 &#125;else &#123; Iterator&lt;Point&gt; iterator = points.iterator(); while (iterator.hasNext()) &#123; Point p = (Point) iterator.next(); if(!(p.equals(line.getStart())||p.equals(line.getEnd()))) &#123; p.setEnable(false); if(debug) &#123; System.out.println("删除的非首尾点："+p.toString()); &#125; &#125;else &#123; if(debug) &#123; System.out.println("保留的首尾点："+p.toString()); &#125; p.setEnable(true); &#125; &#125; &#125;&#125; 结果：原始图像： 道格拉斯普克算法概化 阈值 130： 道格拉斯普克算法概化 阈值 180： 道格拉斯普克算法概化 阈值 250： 控制台打印：]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSM的后台管理系统]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%9F%BA%E4%BA%8ESSM%E7%9A%84%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言：使用SpringMVC+Spring+Mybatis以及maven的一个简单的后台管理系统，程序的结构分为表现层（Controller）、业务层(Service)、数据层(Dao)，包括权限授权、分页查询、日志记录，订单及产品查询，授权管理等功能。 远程仓库地址： https://github.com/XiaoZhong233/SSM_Maneger_DEMO 技术点：1、Spring IOC &amp; DI（控制反转和依赖注入） 2、Spring AOC (切面编程) 3、Spring Security 进行用户登录与注销等安全授权 4、Mybatis dao层半ORM数据库技术（单表查询、多表查询等） 5、Mybatis插件PageHelper，进行分页查询 6、方法级权限关联与控制（运用Sercurity标签等技术） 7、前端使用AdminLTE静态页面模板以及jquery等技术 说明：1、SSM的配置还是比较繁琐的，不过作为入门级的DEMO，还是有必要自己亲自配的 2、Mybatis使用XML配置，DAO层由于想要提高SQL部分的解耦程度，所以使用XML配置统一管理 3、Service和Controller中由于不需要过多的配置、因此使用注解的方式进行依赖注入 运行结果：先放两张图 数据库设计数据表数据包括订单，产品，游客，会员以及日志。 产品表 订单表 会员表 旅客表 数据库ER图 表之间的关系旅客表（traverller）、订单表（orders）、会员表(member)、产品表（product）的id都是uuid（）下随机生成的 订单表（orders）-&gt;产品表（product）一对一的关系 订单表（orders）-&gt;会员表(member) 一对一的关系 订单表（orders）-&gt;旅客表（traverller）多对多的关系（在Mybatis时中和一对多的处理很像，只不过多对多需要一张中间表） 项目结构图：项目为多模块结构: 流程：引入依赖文件（pom.xml）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;scau.zhong&lt;/groupId&gt; &lt;artifactId&gt;ssm_pratice&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;!--版本锁定--&gt; &lt;mybatis.version&gt;3.5.1&lt;/mybatis.version&gt; &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;spring.version&gt;5.1.7.RELEASE&lt;/spring.version&gt; &lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--spring全家桶--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring安全组件--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--权限控制_页面控制--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.security.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mysql坐标--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet API--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;!--数据库连接池C3P0--&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.4&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--权限控制JSR250注解标签--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--多模块项目--&gt; &lt;modules&gt; &lt;module&gt;ssm_dao&lt;/module&gt; &lt;module&gt;ssm_service&lt;/module&gt; &lt;module&gt;ssm_domain&lt;/module&gt; &lt;module&gt;ssm_utils&lt;/module&gt; &lt;module&gt;ssm_web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 实体类建立Product实体类12345678910111213141516171819202122232425package domain; import org.springframework.format.annotation.DateTimeFormat;import util.DateUtils; import java.io.Serializable;import java.util.Date; public class Product implements Serializable &#123; private String id; // 主键 private String productNum; // 编号 唯一 private String productName; // 名称 private String cityName; // 出发城市 //这个注解的目的是用spring来帮助处理这个属性从表单提交时的数据转换 @DateTimeFormat(pattern="yyyy-MM-dd HH:mm") private Date departureTime; // 出发时间 private String departureTimeStr;//出发时间格式化数据 private double productPrice; // 产品价格 private String productDesc; // 产品描述 private Integer productStatus; // 状态 0 关闭 1 开启 private String productStatusStr;//状态格式化 //省略getter 和 setter &#125; Member实体类12345678910111213package domain; import java.io.Serializable; public class Member implements Serializable &#123; private String id; private String name; private String nickname; private String phoneNum; private String email; //省略getter 和 setter &#125; Traveller实体类123456789101112131415161718package domain; import java.io.Serializable; public class Traveller implements Serializable &#123; private String id; private String name; private String sex; private String phoneNum; private Integer credentialsType; private String credentialsTypeStr; private String credentialsNum; private Integer travellerType; private String travellerTypeStr; //省略getter 和 setter &#125; Orders实体类1234567891011121314151617181920212223242526272829package domain; import org.springframework.format.annotation.DateTimeFormat;import util.DateUtils; import java.io.Serializable;import java.util.Date;import java.util.List; public class Orders implements Serializable &#123; private String id; private String orderNum; @DateTimeFormat(pattern="yyyy-MM-dd HH:mm") private Date orderTime; private String orderTimeStr; //订单时间格式化 private int orderStatus; private String orderStatusStr; //订单状态格式化 private int peopleCount; private Product product; private List&lt;Traveller&gt; travellers; private Member member; private Integer payType; private String payTypeStr; //支付状态格式化 private String orderDesc; //省略getter 和 setter &#125; 配置与整合SSM整合的关键是用Spirng去整合SpirngMVC以及Mybatis，所以整合的基本流程是这样的： 1、配置Spring 2、配置Mybatis 3、配置Spring mvc 4、整合Spring和Mybatis 5、整合Spring和SpringMVC 因为这里用到Spring security认证，所以还需要配置一个Spring security，但不属于SSM范围内。 配置文件统一放在Resources目录下，方便管理 配置Spring 新建一个xml文件命令为applicationContext.xml ，引入约束 1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd"&gt; 开启注解扫描，dao层不扫描，只扫描service和controller层 123 &lt;!--开启注解扫描，只需要扫描Service层的注解即可，DAO层由xml配置--&gt;&lt;!-- &lt;context:component-scan base-package="dao"/&gt;--&gt; &lt;context:component-scan base-package="service"/&gt; 注意这里的base-package应该是全路径包名，我这里在java目录下只有一个包所以只写了一层 配置Mybatis建立实体类与dao接口 具体的实体类代码和接口代码就不贴出来了。 mybatis使用半ORM映射技术，不需要你自己实现DAO接口，它会自动帮你实现一个代理dao接口，其内部原理大概就是动态代理技术（基于接口）和XML（注解）解析等 有了实体类，我们封装的对象就有了，有了接口，封装的dao方法就有了，现在要做的是就是对接口方法进行一个“增强”，也就是动态代理，这个mybatis会自动帮我们实现，所以只需要进行mapper的配置来说明如何增强即可。 配置mappermybatis中需要注意的一点是，mapper配置必须与dao接口处于同一个包下或者具有相同的包结构 这里我将xml配置文件全部放置在resources目录下，所以必须和dao接口的包结构一致。 当然，你在开始一个项目的时候，不肯一下子配置这么多mapper的，都是你需要的时候再配就可以了。 在mapper中的配置、以memberMapper为例： 123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IMemberDao"&gt; &lt;select id="findMemberById" resultType="domain.Member"&gt; select * from member where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; namespace属性指定dao接口所在的bao，id是方法名，mybatis需要找到你要增强的方法的路径，合起来也就是dao.IMemberDao.findMemberById 其他的mapper也大同小异，就不贴出来了。 配置mybatis全局配置文件新建一个xml文件，SqlMapConfig.xml 在这里主要配置数据源信息，mapper信息等全局配置 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--使用typeAlias配置别名--&gt; &lt;typeAliases&gt; &lt;!--type指定全限定类名,alias指定别名，别名不区分大小写--&gt; &lt;typeAlias type="domain.Product" alias="product"/&gt; &lt;typeAlias type="domain.Orders" alias="orders"/&gt; &lt;typeAlias type="domain.Member" alias="member"/&gt; &lt;typeAlias type="domain.Traveller" alias="traveller"/&gt; &lt;typeAlias type="domain.User" alias="user"/&gt; &lt;typeAlias type="domain.Role" alias="role"/&gt; &lt;typeAlias type="domain.Permission" alias="permission"/&gt; &lt;typeAlias type="domain.SysLog" alias="log"/&gt; &lt;/typeAliases&gt; &lt;!--这个mapper必须在最下面！！ 映射dao的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/ProductMapper"/&gt; &lt;mapper resource="dao/OrderMapper"/&gt; &lt;mapper resource="dao/MemberMapper"/&gt; &lt;mapper resource="dao/TravellerMapper"/&gt; &lt;mapper resource="dao/UserMapper"/&gt; &lt;mapper resource="dao/RoleMapper"/&gt; &lt;mapper resource="dao/PermissionMapper"/&gt; &lt;mapper resource="dao/User_RoleMapper"/&gt; &lt;mapper resource="dao/SysLogMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 会发现：我这里没有配置数据源信息，原因是没必要配（但你配了也无妨），因为之后在spring整合mybatis时，会在spring中配置。 至此、mybatis的配置就完成了。 配置SpringMVC新建一个xml spring-mvc.xml文件，用来配置springMVC 引入约束在spring-mvc.xml中加入以下内容 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt; 开启注解扫描12&lt;!--开启注解扫描,只扫描Controller包下的注解--&gt;&lt;context:component-scan base-package="controller"/&gt; 配置视图解析器视图解析器也就是告诉前端控制器到哪去找视图（在这里是jsp文件） 1234567&lt;!--视图解析器--&gt;&lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--prefix代表路径前缀--&gt; &lt;property name="prefix" value="/pages/"/&gt; &lt;!--suffix表示文件后缀--&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 需要注意的是这里的id是固定的，spring容器需要根据这个id找到这个视图解析器 配置静态资源不拦截123456&lt;!--告诉前端控制器哪些静态资源不拦截--&gt;&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**" /&gt;&lt;mvc:resources location="/img/" mapping="/img/**" /&gt;&lt;mvc:resources location="/js/" mapping="/js/**" /&gt;&lt;mvc:resources location="/plugins/" mapping="/plugins/**" /&gt; 其他配置123456789&lt;!--开启SpringMVC注解支持--&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 支持AOP的注解支持，AOP底层使用代理技术 JDK动态代理，要求必须有接口 cglib代理，生成子类对象，proxy-target-class="true" 默认使用cglib的方式 --&gt; &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt; Spring整合Mybatis回到刚才创建的Spring配置文件applicationContext.xml中，在这里整合Mybatis 因为之前在mybatis中未配置数据源信息，所以要先配置数据源 spring中配置数据源123456789&lt;!--Spring整合mybatis--&gt;&lt;!--配置连接池--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--注入数据库连接信息--&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ssm1?use Unicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt;&lt;/bean&gt; 配置sqlSession工厂对象12345678910111213141516171819202122&lt;!--配置sqlSession工厂对象--&gt; &lt;bean id="factory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 配置pagerHelper插件,注意其他配置 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;!--使用下面的方式配置参数，一行配置一个 --&gt; &lt;props&gt; &lt;prop key="helperDialect"&gt;mysql&lt;/prop&gt; &lt;prop key="reasonable"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--设置数据源--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--映射mybatis全局配置文件--&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml"/&gt; &lt;/bean&gt; 配置事务管理Spring是有事务管理的，这点非常棒，这样你就不用利用AOP自己写一个事务管理了 1234567&lt;!-- 配置Spring的声明式事务管理 --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 配置Mybatis的Mapper1234567891011121314151617181920212223242526272829&lt;!--映射mapper文件,获取生成代理Dao--&gt;&lt;bean id="productMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IProductDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="orderMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IOrdersDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IUserDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="roleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IRoleDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="permissionMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IPermissionDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="user_roleMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IUser_RoleDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt;&lt;bean id="SysLogMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.ISysLogDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt;&lt;/bean&gt; Spirng整合SpringMVC如果没配置，我们的Spring容器是没有被创建的，通过监听servletContext对象，在初始化的时候创建spring容器。 在web.xml中配置1234567891011121314&lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;&lt;!--加载spring的配置，整合spring mvc与spring，通过监听servletContext对象的生命周期实现，默认加载applicationContext.xml文件--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 针对Spring配置：读取配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml,classpath*:spring-security.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;!--监听请求--&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;&lt;/listener&gt; 配置前端控制器12345678910111213141516&lt;!--配置前端控制器--&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动加载该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置过滤器123456789101112131415161718&lt;!--解决中文乱码的过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 启动过滤器 --&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 配置Spring Security同在web.xml文件中，配置 12345678910&lt;!--配置Spring security--&gt;&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 指定你要拦截路径，这里是全部，Spring Security帮助我们完成用户的认证与授权操作 新建一个xml配置文件 spring-security.xml用来配置安全认证的一些选项。 在spring-security.xml中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt; &lt;!--开启权限控制标签--&gt; &lt;security:global-method-security jsr250-annotations="disabled" secured-annotations="disabled" pre-post-annotations="enabled"/&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern="/login.jsp" security="none"/&gt; &lt;security:http pattern="/failer.jsp" security="none"/&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式，不使用则无法使用security标签控制页面显示 --&gt; &lt;security:http auto-config="true" use-expressions="true"&gt; &lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt; &lt;security:intercept-url pattern="/**" access="hasAnyAuthority('ROLE_USER','ROLE_ADMIN','ROLE_SUPER')"/&gt; &lt;!-- 定义跳转的具体的页面 --&gt; &lt;security:form-login login-page="/login.jsp" login-processing-url="/login.do" default-target-url="/index.jsp" authentication-failure-url="/failer.jsp" authentication-success-forward-url="/pages/main.jsp" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 注销按钮 退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.do" logout-success-url="/login.jsp" /&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 userService是实现spring service的规范实现类--&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式 --&gt; &lt;security:password-encoder ref="passwordEncoder"/&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; Dao接口建立基于XML配置Mybatis配置全局配置文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--使用typeAlias配置别名--&gt; &lt;typeAliases&gt; &lt;!--type指定全限定类名,alias指定别名，别名不区分大小写--&gt; &lt;typeAlias type="domain.Product" alias="product"/&gt; &lt;typeAlias type="domain.Orders" alias="orders"/&gt; &lt;typeAlias type="domain.Member" alias="member"/&gt; &lt;typeAlias type="domain.Traveller" alias="traveller"/&gt; &lt;/typeAliases&gt; &lt;!--这个mapper必须在最下面！！ 映射dao的配置文件--&gt; &lt;mappers&gt; &lt;mapper resource="dao/ProductMapper"/&gt; &lt;mapper resource="dao/OrderMapper"/&gt; &lt;mapper resource="dao/MemberMapper"/&gt; &lt;mapper resource="dao/TravellerMapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 这里没有配置数据源信息的原因是已经在spring中配置了 创建mybatis工厂对象将mybatis工厂对象交给Spring IOC容器管理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解扫描，只需要扫描Service层的注解即可，DAO层由xml配置--&gt;&lt;!-- &lt;context:component-scan base-package="dao"/&gt;--&gt; &lt;context:component-scan base-package="service"/&gt; &lt;!--Spring整合mybatis--&gt; &lt;!--配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--注入数据库连接信息--&gt; &lt;property name="driverClass" value="com.mysql.cj.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/ssm1?use Unicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--配置sqlSession工厂对象--&gt; &lt;bean id="factory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!--设置数据源--&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;!--映射mybatis全局配置文件--&gt; &lt;property name="configLocation" value="classpath:SqlMapConfig.xml"/&gt; &lt;/bean&gt; &lt;!-- 配置Spring的声明式事务管理 --&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!--映射mapper文件,获取生成代理Dao--&gt; &lt;bean id="productMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IProductDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt; &lt;/bean&gt; &lt;bean id="orderMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; &lt;property name="mapperInterface" value="dao.IOrdersDao"/&gt; &lt;property name="sqlSessionFactory" ref="factory"/&gt; &lt;/bean&gt;&lt;/beans&gt; 配置Mapper文件MemberMapper123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IMemberDao"&gt; &lt;select id="findMemberById" resultType="domain.Member"&gt; select * from member where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ProductMapper12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IProductDao"&gt; &lt;select id="findAll" resultType="product"&gt; select * from product &lt;/select&gt; &lt;insert id="insert" parameterType="product"&gt; &lt;selectKey keyProperty="id" keyColumn="id" resultType="java.lang.String" order="BEFORE"&gt; select replace(uuid(),'-','') &lt;/selectKey&gt; insert into product(id,productNum,productName,departureTime,cityName,productPrice,productDesc,productStatus) values (#&#123;id&#125;,#&#123;productNum&#125;,#&#123;productName&#125;,#&#123;departureTime&#125;,#&#123;cityName&#125;,#&#123;productPrice&#125;,#&#123;productDesc&#125;,#&#123;productStatus&#125;) &lt;/insert&gt; &lt;select id="findById" resultType="product" parameterType="java.lang.String"&gt; select * from product where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; TraverllerMapper123456789&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.ITraveller"&gt; &lt;select id="findTravellerByOrderId" resultType="traveller" parameterType="java.lang.String"&gt; select * from traveller where id in (select travellerId from order_traveller where #&#123;oid&#125; = orderId) &lt;/select&gt;&lt;/mapper&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;dao.IOrdersDao&quot;&gt; &lt;!--嵌套结果查询--&gt; &lt;resultMap id=&quot;orderMap&quot; type=&quot;domain.Orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;oid&quot;/&gt; &lt;result property=&quot;orderNum&quot; column=&quot;orderNum&quot;/&gt; &lt;result property=&quot;orderTime&quot; column=&quot;orderTime&quot;/&gt; &lt;result property=&quot;orderStatus&quot; column=&quot;orderStatus&quot;/&gt; &lt;result property=&quot;peopleCount&quot; column=&quot;peopleCount&quot;/&gt; &lt;result property=&quot;payType&quot; column=&quot;payType&quot;/&gt; &lt;result property=&quot;orderDesc&quot; column=&quot;orderDesc&quot;/&gt; &lt;!--association:用于映射关联查询单个对象的信息 property:要将关联查询的用户信息映射到Orders中那个属性--&gt; &lt;association property=&quot;product&quot; javaType=&quot;domain.Product&quot;&gt; &lt;!-- id:关联查询的唯一标识 column:指定唯一标识信息的列 property:映射到product的哪个属性 --&gt; &lt;id column=&quot;pid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;productNum&quot; property=&quot;productNum&quot;/&gt; &lt;result column=&quot;productName&quot; property=&quot;productName&quot;/&gt; &lt;result column=&quot;cityName&quot; property=&quot;cityName&quot;/&gt; &lt;result column=&quot;departureTime&quot; property=&quot;departureTime&quot;/&gt; &lt;result column=&quot;productPrice&quot; property=&quot;productPrice&quot;/&gt; &lt;result column=&quot;productDesc&quot; property=&quot;productDesc&quot;/&gt; &lt;result column=&quot;productStatus&quot; property=&quot;productStatus&quot;/&gt; &lt;/association&gt; &lt;!--查询映射会员信息--&gt; &lt;association property=&quot;member&quot; javaType=&quot;domain.Member&quot;&gt; &lt;id column=&quot;mid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;nickname&quot; property=&quot;nickname&quot;/&gt; &lt;result column=&quot;phoneNum&quot; property=&quot;phoneNum&quot;/&gt; &lt;result column=&quot;email&quot; property=&quot;email&quot;/&gt; &lt;/association&gt; &lt;!--根据中间表查询旅客信息--&gt; &lt;!-- 关联旅客明细信息 一个订单关联查询出了多条旅客,要使用collection映射 collection:对关联查询到的多条记录映射到集合中 property:将关联查询到的多条记录映射到orders类的那个属性 ofType:指定映射的集合属性中pojo的类型 --&gt; &lt;collection property=&quot;travellers&quot; ofType=&quot;domain.Traveller&quot;&gt; &lt;id column=&quot;tid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt; &lt;result column=&quot;phoneNum&quot; property=&quot;phoneNum&quot;/&gt; &lt;result column=&quot;credentialsType&quot; property=&quot;credentialsType&quot;/&gt; &lt;result column=&quot;credentialsNum&quot; property=&quot;credentialsNum&quot;/&gt; &lt;result column=&quot;travellerType&quot; property=&quot;travellerType&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--定义Order的ResultMap懒加载模式映射,嵌套查询--&gt; &lt;resultMap id=&quot;OrderMapLazy&quot; type=&quot;domain.Orders&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;orderNum&quot; column=&quot;orderNum&quot;/&gt; &lt;result property=&quot;orderTime&quot; column=&quot;orderTime&quot;/&gt; &lt;result property=&quot;orderStatus&quot; column=&quot;orderStatus&quot;/&gt; &lt;result property=&quot;peopleCount&quot; column=&quot;peopleCount&quot;/&gt; &lt;result property=&quot;payType&quot; column=&quot;payType&quot;/&gt; &lt;result property=&quot;orderDesc&quot; column=&quot;orderDesc&quot;/&gt; &lt;!--配置Order对象中product映射 ofType是类型，用全限定名或别名--&gt; &lt;!--一对一查询--&gt; &lt;association property=&quot;product&quot; javaType=&quot;domain.Product&quot; select=&quot;dao.IProductDao.findById&quot; column=&quot;productId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;association property=&quot;member&quot; javaType=&quot;domain.Member&quot; select=&quot;dao.IMemberDao.findMemberById&quot; column=&quot;memberId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;!--多对多查询,需要根据中间表来查询--&gt; &lt;collection property=&quot;travellers&quot; ofType=&quot;domain.Traveller&quot; column=&quot;id&quot; select=&quot;dao.ITraveller.findTravellerByOrderId&quot; fetchType=&quot;lazy&quot;/&gt; &lt;!--如果是一对多查询，还是用colleaction标签，只不过不需要通过中间表查询--&gt; &lt;/resultMap&gt; &lt;select id=&quot;findAll&quot; resultMap=&quot;orderMap&quot;&gt; select o.id as oid,o.memberid,o.orderDesc,o.orderNum,o.orderStatus,o.orderTime,o.payType,o.peopleCount,o.productId, p.id as pid,p.cityName,p.departureTime,p.productDesc,p.productName,p.productNum,p.productPrice,p.productStatus, t.id as tid,t.credentialsNum,t.credentialsType,t.`name`,t.phoneNum,t.sex,t.travellerType, m.id as mid,m.email,m.`name`,m.nickName,m.phoneNum from orders o LEFT OUTER JOIN order_traveller ot on o.id=ot.orderId , product p,traveller t,member m WHERE o.productId = p.id and t.id = ot.travellerId and m.id = o.memberid &lt;/select&gt; &lt;select id=&quot;findAll1&quot; resultMap=&quot;OrderMapLazy&quot;&gt; select * from orders &lt;/select&gt; &lt;select id=&quot;getAll&quot; resultType=&quot;domain.Orders&quot;&gt; select * from orders &lt;/select&gt; &lt;select id=&quot;findById&quot; resultMap=&quot;OrderMapLazy&quot; parameterType=&quot;java.lang.String&quot;&gt; select * from orders where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; Service实现略，具体的看源代码即可 Controller实现略，具体的看源代码即可 模块功能实现这里看下Controller的情况，就可以知道大概的功能了。 其中：UserController包括用户的一些常规操作以及授权操作，比如那个角色的用户可以访问哪些模块，哪个角色的用户看不见哪些模块的页面 产品管理产品、订单、游客、会员的表关系可以看这篇 https://blog.csdn.net/weixin_41154636/article/details/90680658 订单管理 用户管理 角色管理 资源权限管理 日志管理原理：利用AOP记录用户访问信息 权限控制如果以超级管理员（所有模块可访问） 是可以查看日志的 如果你只是普通的用户，是无法看见访问日志选项的 另外普通用户在访问某些模块时会提示权限不足 感想SSM配置好鸡儿多好鸡儿复杂，我选择Springboot :)]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（八）基于距离变换的栅格骨架提取算法]]></title>
    <url>%2F2018%2F12%2F16%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%E5%9F%BA%E4%BA%8E%E8%B7%9D%E7%A6%BB%E5%8F%98%E6%8D%A2%E7%9A%84%E6%A0%85%E6%A0%BC%E9%AA%A8%E6%9E%B6%E6%8F%90%E5%8F%96%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、为什么需要骨架提取简单来说就是用于细化栅格，便于栅格数据转换为矢量数据栅格格式向矢量格式转换是提取相同编号的栅格集合表示的边界，栅格点转换成矢量点，很简单，在坐标系确定的情况下通过解析式可以直接转换。而线与面在转换成矢量的时候，本质上都是在提取边界或中轴线，因此在栅格中提取中轴线就与栅格的细化的关系密不可分，这是因为线状栅格数据一般具有粗度且线条本身往往呈现粗细。栅格数据需要细化，以提取中轴线。这是因为： ①中轴线是栅格数据曲线的标准化存储形式 ②实现细化是将栅格曲线矢量化的前提 ③在有些算法中可以提高计算精度 二、距离变换法提取骨架距离变换图距离变换图也是一种栅格图像，其中，每个像元值存储了它到栅格图上相邻物体的最近距离。这个距离的量度：可以是曼哈顿距离，棋盘距离，或者欧式距离。这三个距离关系在GIS中很常用。算法实现如下： 12345678910111213141516171819202122232425/** * * @param disType 距离类型 * @param s1 像元1 * @param s2 像元2 * @return */private double calculateDis(DisType disType,Pixel s1,Pixel s2) &#123; double dis = 0; switch (disType) &#123; case Euclidean: dis = Math.sqrt(Math.pow(s1.getRow()-s2.getRow(), 2)+Math.pow(s1.getColumn()-s2.getColumn(), 2))*size; break; case CityBlock: dis = Math.abs(s1.getRow()-s2.getRow())+Math.abs(s1.getColumn()-s2.getColumn())*size; break; case ChessBoard: dis = Math.max(Math.abs(s1.getRow()-s2.getRow()), Math.abs(s1.getColumn()-s2.getColumn()))*size; break; default: dis = Math.sqrt(Math.pow(s1.getRow()-s2.getRow(), 2)+Math.pow(s1.getColumn()-s2.getColumn(), 2))*size; break; &#125; return dis;&#125; 基于距离变换法提取骨架算法思想：对内部点集i到非内部点集e（孤立点与边界点）求最小距离，实际上就是求目标点到最近背景点的距离（背景点-值为0的像元 目标点-值为1的像元），求出距离后 对距离进行分类即可得骨架图 基于距离变换法提取骨架算法步骤：①将栅格图像进行初始二值化（背景点设为0，目标点设为1） ②将栅格图像进行分类，把栅格分为内部点，边界点，孤立点。 ③求每一个内部点到非内部点的距离，距离值赋给栅格值 ④对栅格图像进行二值化（距离大于1的栅格值设为1，小于等于1的设为0） ③重复②③④，终止条件为“若下一次栅格图像二值化结果全部为0” 如何分类：在步骤②中，如何把栅格分为内部点，边界点，孤立点？ 以中心像素的四邻域为例， 1、如果中心像素为目标像素(值为1)且四邻域都为目标像素(值为1)，则该点为内部点。 2、如果该中心像素为目标像素，四邻域为背景像素(值为0)，则该中心点为孤立点。 3、其他情况则为边界点 分类代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//判断是边界点，内部点，孤立点//前提：栅格已经二值化public void setNeighbourhood() &#123; internalPoints = new ArrayList&lt;&gt;(); borderPoints = new ArrayList&lt;&gt;(); for(int i=0;i&lt;ROW;i++) &#123; for(int j=0;j&lt;COLUMN;j++) &#123; //假-0 真-1 boolean up=true,down=true,right=true,left=true; //判断点的上部是否为0 try &#123; if(data[i-1][j].getValue()==0) &#123; up=false; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception up=false; &#125; //判断点的下部是否为0 try &#123; if(data[i+1][j].getValue()==0) &#123; down=false; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception down=false; &#125; //判断点的左边是否为0 try &#123; if(data[i][j-1].getValue()==0) &#123; left=false; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception left=false; &#125; //判断点的右边是否为0 try &#123; if(data[i][j+1].getValue()==0) &#123; right=false; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception right=false; &#125; if(!up &amp;&amp; !down &amp;&amp; !left &amp;&amp; !right) &#123; data[i][j].setType(type.isolated); &#125;else if(up &amp;&amp; down &amp;&amp; left &amp;&amp; right) &#123; data[i][j].setType(type.internal); internalPoints.add(data[i][j]); &#125;else &#123; data[i][j].setType(type.boundary); borderPoints.add(data[i][j]); &#125; &#125; &#125; &#125; 测试结果： B代表边界点，I代表内部点，孤立点未进行渲染 基于距离变换法提取骨架算法实现我使用了3*3模板的快速距离变换。 按照从上到下，从左到右的顺序，遍历3x3的栅格图像 但是有个问题是：如果在遍历过程中，碰到了栅格的边界怎么办，所以我写了对应的解决办法，即先确定快速距离变换遍历的范围，在开始遍历快速距离变换。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** * 骨架图算法（距离变换法搜索中轴线） * 对内部点集i到边界点集e求最小距离 * 实际上就是求目标点到最近背景点的距离 * 背景点-值为0的像元 目标点-值为1的像元 * 求出距离后 对距离进行分类即可得骨架图 */public void getMinDis(DisType disType) &#123; //快速距离模板计算 //从左至右，从上到下，顺时针寻找周围是否有边界点 //如果有，则加入计算 //如果没有，则扩大搜寻范围,最大范围到数组越界 //最后得出最小距离 //当前圈层数 if(borderPoints==null &amp;&amp; internalPoints==null) &#123; setNeighbourhood(); &#125; for(Pixel i:internalPoints) &#123; List&lt;Double&gt; disList = new ArrayList&lt;&gt;(); //搜索范围 int cicleNum = 1; //上下左右搜寻边界 int up,down,left,right; int upLimit,downLimt,leftLimit,rightLimit; upLimit = 1; downLimt = ROW; leftLimit = 1; rightLimit = COLUMN; //确定遍历范围，防止边界溢出 for(int curCir=0;curCir&lt;cicleNum;curCir++) &#123; try &#123; up = i.getRow()-cicleNum; if(up&lt;upLimit) &#123; up=upLimit; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception up = i.getRow(); &#125; try &#123; down = i.getRow()+cicleNum; if(down&gt;downLimt) &#123; down = downLimt; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception down = i.getRow(); &#125; try &#123; left = i.getColumn()-cicleNum; if(left&lt;leftLimit) &#123; left = leftLimit; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception left = i.getColumn(); &#125; try &#123; right = i.getColumn()+cicleNum; if(right&gt;rightLimit) &#123; right=rightLimit; &#125; &#125; catch (Exception e) &#123; // TODO: handle exception right = i.getColumn(); &#125; //记录栅格周边是否有非内部点，没有的话则圈数+1 boolean flag = false; //从最左最上开始遍历,遍历顺序从左至右，从上到下 for(int row=up;row&lt;down;row++) &#123; for(int col=left;col&lt;right;col++) &#123; //判断是否为中心点,即i点,是就跳过 if(row==i.getRow() &amp;&amp; col==i.getColumn()) &#123; continue; &#125; //判断是否是内部点，如果是内部点就直接跳过 if(data[row][col].getType()!=type.internal) &#123; flag = true; //计算最小距离 double dis = calculateDis(disType, i, data[row][col]); disList.add(dis); &#125; &#125; &#125; //当前圈数内未发现非内部点 if(!flag) &#123; cicleNum++; &#125;else &#123; //已经发现了非内部点，循环结束 break; &#125; &#125; //当前栅格搜索完毕,获取到最近非内部点的距离 if(!disList.isEmpty()) &#123; double min = Collections.min(disList); i.setNearDis(min); &#125; &#125;&#125; 测试结果：原始数据： 距离变换细化一次： 距离变换细化2次 。。。 n次]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（七）矢量数据向栅格数据的转换（面转换的边界代数算法实现）]]></title>
    <url>%2F2018%2F12%2F08%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%91%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9D%A2%E8%BD%AC%E6%8D%A2%E7%9A%84%E8%BE%B9%E7%95%8C%E4%BB%A3%E6%95%B0%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[代码已经po上远程仓库，需要的同学可以自取：https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/Raster.java目录一、边界代数法算法思想二、算法步骤三、算法实现四、测试结果五、总结一、边界代数法算法思想边界代数多边形填充算法是一种基于积分思想的矢量转栅格的转换算法。 这个和格林公式很像，就是根据边界关系求积分，边界代数的思想应该是从这里来的 不过我的算法实现过程和高数没什么关系。先来一波高数劝退哈哈。 沿着多边形的边界进行顺时针环绕。当当前环绕方向向上时，则位于该边界左侧（前进方向看为左侧）的具有相同行坐标的所有栅格的值减去a；当当前环绕方向向下时，则位于该边界左侧（前进方向看为右侧）的具有相同行坐标的所有栅格个的值加上a。 当环绕方向为水平方向则不用管。 但在实际操作过程中，如果多边形内部有孔洞，则有可能造成填充值不唯一的情况，不过这没关系，一样可以把多边形的内部和外部区分开，因为外部的值怎么样都为0。内部的值虽然不一定都为a,但是一定不为0。 二、算法步骤①遍历多边形的每一条边 ②判断该边是否为上行方向，若为上行则把前进方向左侧全部-1，若不是则进入步骤③ ③判断该边是否为下行方向，若为下行则把前进方向的右侧全部+1。 ④重复步骤②，③直至多边形的边遍历完成。 三、算法实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//矢量化多边形(边际代数法)public void RasterPolygon2(Polygon polygon) &#123; List&lt;Line&gt; lines = polygon.getLines(); //RasterLine(polygon, 1); for(Line line : lines) &#123; Point start = line.getStart(); Point end = line.getEnd(); int[] startPoint = transformRasterPoint(start, 0, 0); int[] endPoint = transformRasterPoint(end, 0, 0); int startRow = Math.max(startPoint[0], endPoint[0]); int endRow = Math.min(startPoint[0], endPoint[0]); if(line.isUp()) &#123; while(startRow&gt;=endRow) &#123; int column = 0; while(column&lt;=Math.max(startPoint[1], endPoint[1])) &#123; Point p = transformVetorPoint(endRow, column, 0, 0); //保证p在线段的左边 if(Double.doubleToLongBits(p.getX()) &lt; Double.doubleToLongBits(line.getXByY(p.getY())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&gt;=Double.doubleToLongBits(Math.min(line.getStart().getX(),line.getEnd().getX())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&lt;=Double.doubleToLongBits(Math.max(line.getStart().getX(), line.getEnd().getX()))) &#123; addValue(endRow, column, -1); &#125; column++; &#125; endRow++; &#125; &#125;else if(line.isDown()) &#123; while(startRow&gt;=endRow) &#123; int column = 0; while(column&lt;=Math.max(startPoint[1], endPoint[1])) &#123; Point p = transformVetorPoint(endRow, column, 0, 0); //保证p在线段的左边 if(Double.doubleToLongBits(p.getX()) &lt; Double.doubleToLongBits(line.getXByY(p.getY())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&gt;=Double.doubleToLongBits(Math.min(line.getStart().getX(),line.getEnd().getX())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&lt;=Double.doubleToLongBits(Math.max(line.getStart().getX(), line.getEnd().getX()))) &#123; addValue(endRow, column, 1); &#125; column++; &#125; endRow++; &#125; &#125; &#125;&#125; 四、测试结果输入数据： 123456789Point d,e,r,t,y,o,q;o=new Point(10, 22);d=new Point(12, 25);e=new Point(20, 25);r=new Point(22, 18);t=new Point(13, 18);y=new Point(16, 10);Point[] points = new Point[] &#123;o,d,e,r,t,y&#125;;Polygon polygon = new Polygon(points,true); 绘制结果（矢量绘制）： 输出结果（控制台输出绘制）： 当多边形内部存在孔洞的情况下： 可以发现孔洞处（GIS上的概念对应的应该是岛与洞）的值比外部更大（或者更小，取决于你是顺时针环绕还是逆时针环绕，是上行方向+1还是下行方向+1抑或是别的条件的差异，不过都没关系，不会影响是否在多边形内部关系的判断），这是因为在孔洞的边界多环绕了一次。由这一点我们也可以发现，边界代数法可以很好的保存多边形的拓扑关系，无论这个孔洞是在内部，亦或者是多个多边形邻接，我们可以通过其属性值判断多边形之间的关系。 五、总结边界代数法与前述面状转换算法（《GIS算法基础（五）》）的不同之处，在于它不是逐个逐个的点判断与边界的关系，而是根据边界的拓扑信息，通过简单的加减代数运算将边界位置信息动态地赋予各栅格点。这就是边界代数法巧妙而优美的地方。实现了矢量格式到栅格格式的高速转换（因为计算简单，量也不大），并且不需要考虑搜索轨迹之间的关系，因此算法简单、可靠性好、各边界弧段只被遍历一次，不需重复计算。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（六）矢量数据向栅格数据的转换（面转换的射线算法实现）]]></title>
    <url>%2F2018%2F12%2F08%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%91%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%9D%A2%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%B0%84%E7%BA%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面状换的射线算法已经放在github上：https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/Raster.java目录一、常见的面转换算法1）内部点扩散算法2）射线算法二、射线算法的实现算法步骤：三、测试结果：一、常见的面转换算法 ​ 面状矢量数据是由闭合的线段组成的，在向栅格数据转换的过程中，可以先把边界做线状栅格化（线状栅格化的方法在算法基础）（五）中已经实现），剩下的工作其实就是填充面状要素。所以面状要素的栅格化又称为多边形填充，即在矢量表达的多边形边界内部的所有栅格点上赋以相应的多边形编码。 1）内部点扩散算法该算法由每个多边形的一个内部点（也叫种子点）开始，向其八个方向的领点扩散，判断各个新加入的点是否在多边形的边界上，如果是在多边形的边界上，则该新加入的点不作为种子点，否则把非边界的领点作为新的种子点与原有种子点一起进行新的扩散运算。一般来说，由于扩散算法比较复杂，并且在一定的栅格精度上，如果复杂图形的同一多边形的两条边界落在同一个或相邻的两个栅格内，会造成多边形不连通，这样一个种子点就不能完成填充 2）射线算法射线算法就是通过判断数据栅格点是否在多边形内部，如果在内，则填充，在外则不填充。至于怎么判断，在之前的《GIS算法基础（二）计算几何基础（中）》已经对判断点是否在多边形内的两种算法进行了实现。 二、射线算法的实现算法的基本思想就是通过计算每个栅格点是否在多边形内部，然后决定是否填充。 算法步骤：①对多边形边界进行栅格化（线状要素的栅格化—GIS算法基础（五）中已经实现） ②遍历栅格像元，判断是否在多边形内部（判断点在多边形内部算法–GIS算法基础（二）计算几何基础（中）中已经实现） ③渲染处理 其实在②中也可以进行一个最小包围盒的获取，然后只需要遍历这个包围盒范围的栅格即可，不过为了简单起见，我的实现就遍历整个栅格像元（30x30其实也不大哈哈） 123456789101112131415161718192021//矢量化多边形(用射线法或转角法填充面,用八方向栅格化或全路径栅格化填充边界)/** * * @param polygon * @param RasterType 0-八方向栅格化 1-全路径栅格化 * @param type 0-射线法 1-转角法 */public void RasterPolygon1(Polygon polygon,int RasterType,int type) &#123; RasterLine(polygon, RasterType); for(int i=0;i&lt;=ROW;i++) &#123; for(int j=0;j&lt;=COLUMN;j++) &#123; //count++; //System.out.println(String.format("%d %d", i,j)); if(CalculateBasic.isPointAtPolygon(polygon, transformVetorPoint(i, j, 0, 0), type)) &#123; setValue(i, j); &#125; &#125; &#125; //System.out.println("counter "+count);&#125; 这里的transformVetorPoint是栅格点转矢量点。 在由栅格点判断是否在多边形内部中的时候，由于栅格点是栅格像元，而多边形是矢量要素，不能进行直接的关系判断，因此需要进行转换，把栅格点转为矢量点。 之前矢量点转栅格点的公式： 那么栅格点转矢量点就是逆着来： x0,y0代表栅格的坐标原点在直角坐标系中的坐标，dx,dy分别代表矩形栅格的长和宽 transformVetorPoint代码实现： 1234567891011121314151617181920 /** * 求出的坐标是栅格的中心点 * @param row 行 * @param colum 列 * @param xOffset 起始栅格点的x位移量 * @param yOffset 起始栅格点的y位移量 * @return */ public Point transformVetorPoint(int row,int colum,double xOffset,double yOffset) &#123; double x0=size+xOffset+this.xOffset;//栅格起始点坐标 double y0=ROW+yOffset+this.yOffset; double x = x0+(colum-0.5)*size; double y = y0-(row-0.5)*size; Point newPoint=new Point(x, y);// newPoint = BasicTransform.transform(newPoint, ROW/2, COLUMN/2); return newPoint; &#125; 三、测试结果：输入数据： 123456789o=new Point(3,9);d=new Point(9,3);e=new Point(18,18);r=new Point(12,18);t=new Point(21,3);y=new Point(27,9);q=new Point(15, 30);Point[] points = new Point[] &#123;o,d,e,r,t,y,q&#125;;Polygon polygon = new Polygon(points,true); GUI绘制（矢量要素绘制，绘制实现在github上）： 输出结果（控制台输出）：]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（五）矢量数据向栅格数据的转换（点，线算法实现）]]></title>
    <url>%2F2018%2F12%2F07%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E7%9F%A2%E9%87%8F%E6%95%B0%E6%8D%AE%E5%90%91%E6%A0%85%E6%A0%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E7%82%B9%EF%BC%8C%E7%BA%BF%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[矢量结构数据与栅格结构数据的相互转换，是地理信息系统的基本功能之一，已发展形成了许多高效的转换算法。源码已经放在github上了，需要朋友自取。https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/Raster.java 目录 一、矢量点的栅格化 二、矢量线的栅格化 ①八方向栅格化 算法思想： 算法实现： 测试： ②全路径栅格化 算法思想 算法实现： 测试结果： 一、矢量点的栅格化矢量点的栅格化: 实质是将点的坐标x、y换算为栅格行、列号。 注意：栅格的坐标原点是从左上角开始的，行数I向下递增，列数J向左递增 (X0,Y0)代表栅格的原点，dx,dy代表分别代表栅格的长和宽，也就是大小 实际代码中，这个x0,yo因为已知了栅格大小，所以可以求的出来。 在矢量数据向栅格数据转换的过程中，栅格数据可以用二维数组来表达。 1234567891011121314151617/** * * @param point 带转化的矢量点 * @param xOffset 起始栅格点的x位移量 * @param yOffset 起始栅格点的y位移量 * @return 0-行 1-列 */public int[] transformRasterPoint(Point point,double xOffset,double yOffset) &#123; double x0=size+xOffset+this.xOffset;//栅格起始点坐标 double y0=ROW+yOffset+this.yOffset; int[] rowAndColumn = new int[2]; //像元大小默认为1 rowAndColumn[0] = (int) (1+ (Math.floor(Math.abs((y0-point.getY())/size)))); rowAndColumn[1] = (int)(1+(Math.floor(Math.abs((point.getX()-x0))/size))); return rowAndColumn;&#125; 测试结果： 输入： 12345Raster raster = new Raster(30,30); //创建一个30x30的栅格Point p = new Point(.5, .5); System.out.println(p);int[] a = raster.transformRasterPoint(p, 0, 0);System.out.println(String.format("I=%d,J=%d", a[0],a[1])); 输出： 12(0.500000,0.500000)I=30,J=1 二、矢量线的栅格化①八方向栅格化八方向栅格法很容易理解，就是已知直线的倾角情况，在每行或每列只有一个像元被涂黑。 算法思想： 一条线段有两个端点：P1(x1,y1)、P2(x2,y2)，先分别确定其行列号(I1,J1)及(I2,J2),然后求出这两个端点位置的行数差和列数差。 若行数差大于列数差，则逐行求出本行中心线与过这两个端点的直线的交点（X，Y），得到交点行、列号，将交点“涂黑”：Y=yi行中心线，X=(yi-y1)k+x1；式中k=(x2-x1)/(y2-y1)，这个公式不看也罢，其实就是两直线求交点的方程 若行数差小于或等于列数差，则逐列求出本列中心线与过这两个端点的直线的交点（X，Y），得到交点行、列号，将交点“涂黑” ：X=xi行中心线，Y=(xj-x1)k’+y1；式中k’=(y2-y1) /(x2-x1) 算法实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public void RasterLine(Point start,Point end,int type,double xOffset,double yOffset) &#123; //开始点与结束点的起始坐标 int[] startPoint = transformRasterPoint(start, 0, 0); int[] endPoint = transformRasterPoint(end, 0, 0); // System.out.println(String.format("开始点：(%d,%d)", startPoint[0],startPoint[1])); System.out.println(String.format("结束点：(%d,%d)", endPoint[0],endPoint[1])); //涂黑,开始点与终止点（值设为1） setValue(startPoint[0], startPoint[1]); setValue(endPoint[0], endPoint[1]); Line line = new Line(start, end); //如果是垂直或者水平者直接涂黑 if(line.isHorizontal() || Double.doubleToLongBits(start.getX())==Double.doubleToLongBits(end.getX())) &#123; if(line.isHorizontal()) &#123; int i = startPoint[0]; int j0 = Math.min(startPoint[1], endPoint[1]); int j1 = Math.max(startPoint[1], endPoint[1]); while(j0!=j1) &#123; setValue(i, j0); j0++; &#125; &#125;else &#123; int i = startPoint[1]; int j0 = Math.min(startPoint[0], endPoint[0]); int j1 = Math.max(startPoint[0], endPoint[0]); while(j0!=j1) &#123; setValue(j0, i); j0++; &#125; &#125; return; &#125; //行差与列差 int difOfRow = Math.abs(startPoint[0]-endPoint[0]); int difOfColumn = Math.abs(startPoint[1]-endPoint[1]); //若行差大于列差，则逐行求出本行中心线与过两个端点的直线的交点 //反之则反之 if(difOfRow&gt;difOfColumn) &#123; //求每行中心线 int num = Math.min(startPoint[0], endPoint[0]); //用于记录当前行 while(num&lt;=Math.max(startPoint[0], endPoint[0])) &#123; //因为只需要求出行，所以设列为1即可 Point temPoint=transformVetorPoint(num, 1, 0, 0); //中心线 double y = temPoint.getY(); //求交点 double x=line.getXByY(y); Point result = new Point(x, y); //矢量点转栅格 int[] resultRasterPoint=transformRasterPoint(result, 0, 0); //"涂黑"栅格 setValue(resultRasterPoint[0], resultRasterPoint[1]); num++; &#125; &#125;else &#123; //求每列中心线 int num = Math.min(startPoint[1], endPoint[1]); while(num&lt;Math.max(startPoint[1], endPoint[1])) &#123; Point temPoint = transformVetorPoint(1, num, 0, 0); double x = temPoint.getX(); double y = line.getYByX(x); Point result = new Point(x, y); int[] resultRasterPoint = transformRasterPoint(result, 0, 0); setValue(resultRasterPoint[0], resultRasterPoint[1]); num++; &#125; &#125;&#125; 测试：输入： p（3,9），q（15,30）组成的线段，在30x30的栅格上显示 输出 这个渲染的代码就不放出来了，有兴趣可以到github上看。 ②全路径栅格化 算法思想 说白了就是固定行，求列，固定列，求行的过程。 但值得注意的是，书上并没有给出计算行号的过程： 实际上也不难推出，因为求起止行列的过程就是已知tan角求不同边的过程 固定行，求起止列就是求上图中a的过程 a = tana/b 固定列，求起止行就是求b的过程， b=tana * b 因此可以推出 起始行号: 终止行号: m是栅格的边长，j是当前处理的列，y0是栅格坐标原点在直角坐标系中的纵坐标值 算法实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144public void RasterLine(Point start,Point end,int type,double xOffset,double yOffset) &#123; //开始点与结束点的起始坐标 int[] startPoint = transformRasterPoint(start, 0, 0); int[] endPoint = transformRasterPoint(end, 0, 0); // System.out.println(String.format("开始点：(%d,%d)", startPoint[0],startPoint[1])); System.out.println(String.format("结束点：(%d,%d)", endPoint[0],endPoint[1])); //涂黑,开始点与终止点（值设为1） setValue(startPoint[0], startPoint[1]); setValue(endPoint[0], endPoint[1]); Line line = new Line(start, end); //如果是垂直或者水平者直接涂黑 if(line.isHorizontal() || Double.doubleToLongBits(start.getX())==Double.doubleToLongBits(end.getX())) &#123; if(line.isHorizontal()) &#123; int i = startPoint[0]; int j0 = Math.min(startPoint[1], endPoint[1]); int j1 = Math.max(startPoint[1], endPoint[1]); while(j0!=j1) &#123; setValue(i, j0); j0++; &#125; &#125;else &#123; int i = startPoint[1]; int j0 = Math.min(startPoint[0], endPoint[0]); int j1 = Math.max(startPoint[0], endPoint[0]); while(j0!=j1) &#123; setValue(j0, i); j0++; &#125; &#125; return; &#125; //计算栅格原点在直角坐标系中的坐标 double x0=1+xOffset+this.xOffset; double y0=ROW+yOffset+this.yOffset; //△x&gt;=△y，则计算列号，反之则计算行号 double difX = Math.abs(start.getX()-end.getX()); double difY = Math.abs(start.getY()-end.getY()); double k = line.getSlope(); if(difX&gt;=difY) &#123; //开始点与结束点的起始坐标 if(Double.doubleToLongBits(end.getY())&lt;Double.doubleToLongBits(start.getY())) &#123; startPoint = transformRasterPoint(start, 0, 0); endPoint = transformRasterPoint(end, 0, 0); line = new Line(start,end); &#125;else &#123; startPoint = transformRasterPoint(end, 0, 0); endPoint = transformRasterPoint(start, 0, 0); line = new Line(end,start); &#125; k = line.getSlope(); //System.out.println(k); //用于记录当前行 int i = startPoint[0]; //终止行 int j = endPoint[0]; //计算起始列号 int j0 = (int)Math.floor(((((y0-(i-1)*size-line.getStart().getY())/k)+line.getStart().getX()-x0)/size))+1; //计算终止列号 int j1 = (int)Math.floor((((y0-i*size-line.getStart().getY())/k)+line.getStart().getX()-x0)/size)+1; //System.out.println(String.format("s%d,%d", j0,j1)); while(i!=j) &#123; //i行从j0-j1涂黑 int ja,jb; ja=j0; jb=j1; System.out.println(String.format("%d,%d", j0,j1)); while(ja!=jb) &#123; if(ja&lt;jb) &#123; //System.out.println(String.format("i=%d ja=%d", i,ja)); setValue(i, ja); ja++; &#125; else &#123; //System.out.println(String.format("i=%d jb=%d", i,jb)); setValue(i, jb); jb++; &#125; &#125; i++; //本行终止列号等于下一行的起始列号 j0=j1; //计算下一行终止列号 j1 = (int)Math.floor((((y0-i*size-line.getStart().getY())/k)+line.getStart().getX()-x0)/size)+1; //System.out.println(String.format("%d,%d", j0,j1)); &#125; &#125;else &#123; //System.out.println("第二种"); //开始点与结束点的起始坐标 if(Double.doubleToLongBits(end.getX())&gt;Double.doubleToLongBits(start.getX())) &#123; startPoint = transformRasterPoint(start, 0, 0); endPoint = transformRasterPoint(end, 0, 0); line = new Line(start,end); &#125;else &#123; startPoint = transformRasterPoint(end, 0, 0); endPoint = transformRasterPoint(start, 0, 0); line = new Line(end,start); &#125; k = line.getSlope(); //System.out.println(k); //记录当前列 int js = startPoint[1]; //记录终止列 int je = endPoint[1]; //计算起始行号 int is = (int)Math.floor(((line.getStart().getX()-x0-(js-1)*size)*k+y0-line.getStart().getY())/size)+1; //计算终止行号 int ie = (int)Math.floor(((line.getStart().getX()-x0-js*size)*k+y0-line.getStart().getY())/size)+1; //System.out.println(String.format("first %d,%d", is,ie)); while(js!=je) &#123; int ia,ib; //从is-ie行涂黑 ia=is; ib=ie; while(ia!=ib) &#123; if(ia&lt;ib) &#123; //System.out.println(ia); setValue(ia, js); ia++; &#125; else &#123; //System.out.println(ib); setValue(ib, js); ib++; &#125; &#125; js++; is=ie; ie = (int)Math.floor(((line.getStart().getX()-x0-js*size)*k+y0-line.getStart().getY())/size)+1; //System.out.println(String.format("%d,%d", is,ie)); &#125; &#125; 测试结果：输入： p（3,9），q（15,30）组成的线段，在30x30的栅格上显示 输出： 同时，由于输入的线段是相同的，也可以比对一下八方向栅格化和全路径栅格化的栅格化效果。 八方向的特点是每行或每列只有一个栅格被涂黑，所以看起来比较细长。而全路径栅格化，由于计算过程是把所有经过的栅格都”涂黑“了，因此当要以任何方向探测栅格影响的存在或者想要知道矢量可能出现在哪些栅格所覆盖的范围时，就可以用全路径栅格化。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（四）平面坐标变换（变换矩阵算法实现）]]></title>
    <url>%2F2018%2F12%2F02%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E5%B9%B3%E9%9D%A2%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2%EF%BC%88%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[po一个B站线性代数学习资料，这个作者很好地解释线性代数操作空间的本质。 【官方双语/合集】线性代数的本质 - 系列合集 github地址 https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/BasicTransform.java 目录 一、平面直角坐标系的建立 二、平面坐标变换矩阵 三、平移变换 四、比例变换 五、对称变换 六、旋转变换 七、错切变换 八、复合变换 (1)、复合平移 （2）复合比例变换 （3）复合旋转 （4）相对某点的比例变换 （5）相对某点的选址变换 一、平面直角坐标系的建立 在平面上选一点作为直角坐标的原点，过该原点作相互垂直的两轴，就建立起了平面直角坐标系，如上图所示。 在代码中，我们可以用一个类表示一个点实体，他由一串坐标组成，但是，如果这些点如果位于不同的坐标系中，该怎么转换呢？通过对X,Y的操作，比如平移就在相应的X,Y分量上加偏移量，我们就可以实现。那如果，我们既要平移，又要旋转，或者一系列的对点实体的操作，该怎么实现？这个时候就可以用到平面坐标变换矩阵。 二、平面坐标变换矩阵 “变换矩阵是数学线性代数中的一个概念。在线性代数中，线性变换能够用矩阵表示。如果T是一个把Rn映射到Rm的线性变换，且x是一个具有n个元素的列向量 ，那么我们把m×n的矩阵A，称为T的变换矩阵。” ​ ——-百度百科-变换矩阵 其实没有这么复杂，就是我们通过对一个坐标串构成的矩阵与某个矩阵相乘，得到的新矩阵包含了我们所要的坐标的信息。这个”某个矩阵”在这里就是屏幕坐标变换矩阵。 怎么构建 矩阵吧，矩阵的构建可以用二维数组实现。这个不是算法的重点，所以我就不po代码了，想看代码可以到我的github上看 https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/BasicTransform.java 平面坐标变换矩阵可由下式表示： ​ /*​ \ |a d g|​ * T= |b e h| |a d| |g|​ * |c f i| |b e| 负责对图形的缩放,旋转,对称,错切 。[c f] 负责对图形进行平移变换 |h| 负责投影变换​ */ 构建代码： 12345678910111213141516171819public class SurfaceTransformationMatrix &#123; private double a,b,c,d,e,f,g,h,i; private double[][] data= &#123;&#123;a,d,g&#125;,&#123;b,e,h&#125;,&#123;c,f,i&#125;&#125;; private Matrix matrix; public SurfaceTransformationMatrix() &#123; this.matrix = new Matrix(data); &#125; public SurfaceTransformationMatrix(double[][] data) &#123; this.matrix = new Matrix(data); &#125; public Matrix getMatrix() &#123; return matrix; &#125; &#125; 三、平移变换公式如下： (m,n)是变换后的坐标，(x,y)是变换前的坐标，tx,ty分别对应x轴，y轴的偏移量 构建代码： 123456789101112131415public class TransformMatrix extends SurfaceTransformationMatrix&#123; private Matrix matrix; public TransformMatrix(double Tx,double Ty) &#123; super(new double[][]&#123;&#123;1,0,0&#125;,&#123;0,1,0&#125;,&#123;Tx,Ty,1&#125;&#125;); this.matrix = super.getMatrix(); &#125; public Matrix getTransformMatrix() &#123; return matrix; &#125; &#125; 平移算法： 12345678910111213141516171819202122232425262728293031323334/** * 平移算法 * @param point * @param x x正方向偏移量 * @param y y正方向偏移量 * @return */public static Point transform(Point point,double x,double y) &#123; Matrix matrix = new TransformMatrix(x, y).getTransformMatrix(); double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); //System.out.println("平移后的点 ："+new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]).toString()); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125;public static Line transform(Line line,double x,double y) &#123; Point start = line.getStart(); Point end = line.getEnd(); Point newStart = transform(start, x, y); Point newEnd = transform(end, x, y); return new Line(newStart,newEnd);&#125;public static Polygon transform(Polygon polygon,double x,double y) &#123; Point[] points = polygon.getPoints(); Point[] result = new Point[points.length]; for(int i=0;i&lt;points.length;i++) &#123; result[i]=transform(points[i], x, y); //System.out.println("result ："+result[i].toString()); &#125; return new Polygon(result, polygon.isClose());&#125; 接下来的变换基本都和这个变换的例子差不多，无非是参数的变化四、比例变换变换公式：[x* y* 1] = [x y 1] x [{Sx,0,0},{0,Sy,0},{0,0,1}] = [Sxx Syy 1]因为公式没找到图，就用二维数组来表示 x,y是x,y变换后的坐标 变换关系如下（1）当Sx = Sy = 1 时，为恒等比例变换，就是图形不变 （2）当Sx = Sy &gt; 1 时，图形沿两个坐标轴方向等比例放大。 （3）当Sx = Sy &lt; 1 时，图形沿两个坐标轴方向等比例缩小。 （4）当Sx != Sy 时，图形沿两个坐标轴方向做非均匀的比例变换。 构建代码： 123456789101112public class ScaleMtrix extends SurfaceTransformationMatrix&#123; private Matrix matrix; public ScaleMtrix(double Sx,double Sy) &#123; // TODO Auto-generated constructor stub super(new double[][]&#123;&#123;Sx,0,0&#125;,&#123;0,Sy,0&#125;,&#123;0,0,1&#125;&#125;); this.matrix = super.getMatrix(); &#125; public Matrix getScaleMatrix() &#123; return matrix; &#125;&#125; 算法： 1234567891011121314151617181920212223242526272829303132333435/** * 比例变换算法 * x=y时，恒比例放大或缩小 * x!=y时，图形沿两个坐标轴方向做非均匀比例变换 * @param point * @param x * @param y * @return */public static Point scale(Point point,double x,double y) &#123; Matrix matrix = new ScaleMtrix(x, y).getScaleMatrix(); double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125;public static Line scale(Line line,double x,double y) &#123; Point start = line.getStart(); Point end = line.getEnd(); Point newStart = scale(start, x, y); Point newEnd = scale(end, x, y); return new Line(newStart,newEnd);&#125;public static Polygon scale(Polygon polygon,double x,double y) &#123; Point[] points = polygon.getPoints(); Point[] result = new Point[points.length]; for(int i=0;i&lt;points.length;i++) &#123; result[i]=scale(points[i], x, y); //System.out.println("result ："+result[i].toString()); &#125; return new Polygon(result, polygon.isClose());&#125; 五、对称变换公式如下： [x,y,1] = [x,y,1] x [{a,d,0},{b,e,0},{0,0,1}] = [ax+by dx+ey 1] 变换关系： （1）当b=d=0,a=-1,e=1时，产生与y轴对称的反射图形 （2）当b=d=0,a=1,e=-1时，产生与x轴对称的反射图形 （3）当b=d=0,a=e=-1时，产生与原点对称的反射图形 （4）当b=d=1,a=e=0时，产生与直线y=x对称的反射图形 （5）当b=d=-1,a=e=0时，产生与直线y=-x对称的反射图形 构建代码： 123456789101112131415161718/** * 对称变换矩阵 * @author Administrator * */public class SymmetryMatrix extends SurfaceTransformationMatrix&#123; private Matrix matrix; public SymmetryMatrix(double a,double b,double d,double e) &#123; // TODO Auto-generated constructor stub super(new double[][] &#123;&#123;a,d,0&#125;,&#123;b,e,0&#125;,&#123;0,0,1&#125;&#125;); this.matrix = super.getMatrix(); &#125; public Matrix getSymmetryMatrix() &#123; return matrix; &#125;&#125; 算法： 1234567891011121314151617181920212223242526272829303132/** * 对称变换 * @param point * @param symmetryType 枚举类型 * @return */public static Point symmetry(Point point,SymmetryType symmetryType) &#123; Matrix matrix; switch (symmetryType) &#123; case xAxis: matrix = new SymmetryMatrix(1, 0, 0, -1).getSymmetryMatrix(); break; case yAxis: matrix = new SymmetryMatrix(-1, 0, 0, 1).getSymmetryMatrix(); break; case yx: matrix = new SymmetryMatrix(0, 1, 1, 0).getSymmetryMatrix(); break; case anti_yx: matrix = new SymmetryMatrix(0, -1, -1, 0).getSymmetryMatrix(); break; case origin: matrix = new SymmetryMatrix(-1, 0, 0, -1).getSymmetryMatrix(); default: matrix = new SymmetryMatrix(-1, 0, 0, -1).getSymmetryMatrix(); break; &#125; double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; 六、旋转变换公式如下： [x,y,1] =[x,y,1] x [{cosa,sina,0},{-sina,cosa,0},{0,0,1}] = [xcosa-ysina xsina+ycosa 1]a是二维图形绕原点顺时针旋转a角。 构建代码： 12345678910111213141516public class RotateMatrix extends SurfaceTransformationMatrix&#123; private Matrix matrix; public RotateMatrix(double angle) &#123; // TODO Auto-generated constructor stub super(new double[][] &#123;&#123;Math.cos(Math.toRadians(angle)),Math.sin(Math.toRadians(angle)),0&#125;, &#123;-Math.sin(Math.toRadians(angle)),Math.cos(Math.toRadians(angle)),0&#125;, &#123;0,0,1&#125;&#125;); this.matrix = super.getMatrix(); &#125; public Matrix getRotateMatrix() &#123; return matrix; &#125;&#125; 算法： 12345678910111213/** * 旋转变换 * @param point * @param angle 角度制单位 * @return */public static Point rotate(Point point,double angle) &#123; Matrix matrix = new RotateMatrix(angle).getRotateMatrix(); double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; 七、错切变换公式如下： [x,y,1] = [x,y,1] * [{1,d,0},{b,1,0},{0,0,1}] = [x+by,dx+y,1]x,y为变换后的坐标。 变换关系如下： （1）当d=0时，x=x+by,y=y,此时图形的y坐标不变，x坐标随初值(x,y)及变换系数b而作线性变换；若b&gt;0，则图形沿+x方向做错切位移；b&lt;0图形沿-x方向做错切位移。 （2）当b=0时，x=x,y=dx+y，此时图形的x坐标不变，y坐标随初值（x,y）及变换系数d做线性变换；如d&gt;0，则图形沿+y方向作错切变换；d&lt;0时，图形沿-y方向做错切位移。 （3）当b!=0时，且d!=0时，x=x+by，y=dx+y，图形沿x,y两个方向错切位移。 构建代码： 12345678910111213public class MiscutMatrix extends SurfaceTransformationMatrix&#123; private Matrix matrix; public MiscutMatrix(double d,double b) &#123; // TODO Auto-generated constructor stub super(new double[][] &#123;&#123;1,d,0&#125;,&#123;b,1,0&#125;,&#123;0,0,1&#125;&#125;); this.matrix = super.getMatrix(); &#125; public Matrix getMiscutMatrix()&#123; return matrix; &#125;&#125; 算法如下： 123456789101112131415/** * 错切变换 * @param point * @param b=0,y轴随变换系数d变换 b&gt;0,图形沿+y方向做错切变换,b&lt;0,图形沿-y方向做错切变换 * @param d=0,y轴随变换系数b变换 b&gt;0,图形沿+x方向做错切变换,b&lt;0,图形沿-x方向做错切变换 * b!=0 &amp;&amp; d!=0时,x*=x+by y*=dx+y 图形沿x,y两个方向做错切变换 * @return */public static Point miscut(Point point,double b,double d) &#123; Matrix matrix = new MiscutMatrix(b,d).getMiscutMatrix(); double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; 八、复合变换复合变换是指图形做一次以上的几何变换，变换结果是每次变换矩阵相乘。 (1)、复合平移直接上代码吧，就直接几个平移矩阵相乘 123456789101112131415161718/** * 复合平移 * @param point * @param matrixs * @return */public static Point complexTransform(Point point,TransformMatrix...matrixs) &#123; int len = matrixs.length; Matrix matrix = matrixs[0].getTransformMatrix(); for(int i=1;i&lt;len;i++) &#123; matrix = matrix.RightMultiMatrix(matrixs[i].getTransformMatrix()); &#125; double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; （2）复合比例变换1234567891011121314151617/** * 复合比例变换 * @param point * @param matrixs * @return */public static Point complexScale(Point point,ScaleMtrix...matrixs) &#123; int len = matrixs.length; Matrix matrix = matrixs[0].getScaleMatrix(); for(int i=1;i&lt;len;i++) &#123; matrix = matrix.RightMultiMatrix(matrixs[i].getScaleMatrix()); &#125; double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; （3）复合旋转1234567891011121314151617/** * 复合旋转变换 * @param point * @param matrixs * @return */public static Point complexRotate(Point point,RotateMatrix ...matrixs) &#123; int len = matrixs.length; Matrix matrix = matrixs[0].getRotateMatrix(); for(int i=1;i&lt;len;i++) &#123; matrix = matrix.RightMultiMatrix(matrixs[i].getRotateMatrix()); &#125; double [][] data= &#123;&#123;point.getX(),point.getY(),1&#125;&#125;; Matrix pointMatrix = new Matrix(data); Matrix result = pointMatrix.RightMultiMatrix(matrix); return new Point(result.getMatrix()[0][0], result.getMatrix()[0][1]);&#125; 比例，旋转变换是与参考的有关的，上面的都是相对于原点的比例变换，如果要参考某个(m,n)点做比例 ，旋转变换，其变换过程就是先把该坐标系的原点移到（m,n）上来，然后做了旋转或比例变换，然后再移回去。 （4）相对某点的比例变换1234567891011121314/** * 相对于某点的比例变换 * @param point 待变换的点 * @param center 相对点 * @param x * @param y * @return */public static Point scaleAround(Point point,Point center,double x,double y) &#123; TransformMatrix t1 = new TransformMatrix(-center.getX(), -center.getY()); ScaleMtrix scaleMtrix = new ScaleMtrix(x, y); TransformMatrix t2 = new TransformMatrix(center.getX(), center.getY()); return complexTransmit(point, t1,scaleMtrix,t2);&#125; （5）相对某点的选址变换12345678910111213/** * 围绕某点的旋转变换 * @param point 待变换的点 * @param center 相对点 * @param angle * @return */public static Point rotateAround(Point point,Point center,double angle) &#123; TransformMatrix t1 = new TransformMatrix(-center.getX(), -center.getY()); RotateMatrix rotateMatrix = new RotateMatrix(angle); TransformMatrix t2 = new TransformMatrix(center.getX(), center.getY()); return complexTransmit(point, t1,rotateMatrix,t2);&#125;]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（三）计算几何基础（下）]]></title>
    <url>%2F2018%2F11%2F30%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[代码已经po上远程仓库:https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/CalculateBasic.java目录判断线段在多边形内的算法：算法思路：算法步骤：算法实现(JAVA)：测试结果GUI绘制结果：判断线段在多边形内的算法： 算法思路：如果线段与多边形内交，则线段一定在多边形外；如果线段和多边形的每一条边都不内交，如果有交点，则线段和多边形的交点一定是线段的端点或者多边形的顶点，然后只需要判断交点是否在线段上就可以了 算法步骤： 判断线段的两个端点是否在多边形内部 开始遍历多边形的每条边 判断线段的端点是否在多边形上 判断多边形的端点是否在线段上 如果2、3条件都不满足，判断线段是否与多边形的边是否相交，如果相交则说明内交 如果5得出不相交，则判断各交点的中点是否在多边形内部 算法实现(JAVA)：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public static boolean isSegmentAtPolygon(Line line,Polygon polygon) &#123; //判断线段的两端点是否在多边形内部 if(!isPointAtPolygon(polygon, line.getStart(), 0) || !isPointAtPolygon(polygon, line.getEnd(), 0)) &#123; System.out.println("端点不在多边形内部"); return false; &#125; //交点集 List&lt;Point&gt; pointSet = new ArrayList&lt;&gt;(); //判断多边形的各条边与线段不内交 for(Line bian : polygon.getLines()) &#123; //判断线段的两端点是否在多边形上 if(isPointAtSegment(bian, line.getStart()) || isPointAtSegment(bian, line.getEnd())) &#123; if(isPointAtSegment(bian, line.getStart())) &#123; pointSet.add(line.getStart()); &#125; if(isPointAtSegment(bian, line.getEnd())) &#123; pointSet.add(line.getEnd()); &#125; //判断多边形的边的某个端点是否在线段上 &#125;else if (isPointAtSegment(line, bian.getStart())||isPointAtSegment(line, bian.getEnd())) &#123; if(isPointAtSegment(line, bian.getStart())) &#123; pointSet.add(bian.getStart()); &#125; if(isPointAtSegment(line, bian.getEnd())) &#123; pointSet.add(bian.getEnd()); &#125; //判断是否相交，如果程序进行此次判断，则说明上两个判断都不满足，则说明线段与边内交 &#125;else if (isTwoSegmentIntersect(bian, line)) &#123; System.out.println("线段与多边形内交"); return false; &#125; &#125; //对交点集进行按照x，y排序，为了更方便的比较各交点的中点是否在多边形内 Comparator&lt;Point&gt; XYcomparator = new Comparator&lt;Point&gt;() &#123; //优先对X进行排序，x相等则对y进行排序 @Override public int compare(Point arg0, Point arg1) &#123; // TODO Auto-generated method stub if(arg0.getX()-arg1.getX()==0) &#123; return (int) (arg0.getY()-arg1.getY()); &#125;else &#123; return (int) (arg0.getX()-arg1.getX()); &#125; &#125; &#125;; Collections.sort(pointSet, XYcomparator); //一次判断每两个相邻点的中点是否在多边形内 for(int i=0;i&lt;pointSet.size();i++) &#123; //如果是最后一个点，循环结束 if(i==pointSet.size()-1) &#123; break; &#125; Point a = pointSet.get(i); Point b = pointSet.get(i+1); Point center = new Point((a.getX()+b.getX())/2.0,(b.getY()+a.getY())/2.0); if(!isPointAtPolygon(polygon, center, 0)) &#123; System.out.println("中点不在多边形内部"); return false; &#125; &#125; return true;&#125; 说明：**isTwoSegmentIntersect**函数判断两线段是否相交，思路是对两线段进行快速排斥试验与跨越试验。 isPointAtPolygon**函数是上文已经实现了的判断点是否在多边形内，这里使用的是射线法法进行判断** isPointAtSegment**函数判断点是否在线段上，思路是判断点与线段一端点的叉积与点是否在线所围成的矩形中** 这些方法的实现我在计算几何基础（上），计算几何基础（中）中已经实现过了 https://blog.csdn.net/weixin_41154636/article/details/82968255 https://blog.csdn.net/weixin_41154636/article/details/82986381 下面附上**isTwoSegmentIntersect函数实现与isPointAtSegment**函数的实现 12345678910111213141516171819202122232425/** * 判断两线段是否相交 * @param a * @param b * @param c * @param d * @return */public static boolean isTwoSegmentIntersect(Point a,Point b,Point c,Point d) &#123; boolean flag1 = false; boolean flag2 = false; //快速排斥试验 if(Math.min(a.getY(), b.getY())&lt;=Math.max(c.getY(), d.getY()) &amp;&amp; Math.min(c.getX(), d.getX())&lt;=Math.max(a.getX(), b.getX()) &amp;&amp; Math.min(c.getY(), d.getY())&lt;= Math.max(a.getY(), b.getY()) &amp;&amp; Math.min(a.getX(), b.getX())&lt;= Math.max(c.getX(), d.getX())) &#123; flag1 = true; &#125; Vector2D ab = getVector(a, b); Vector2D ac = getVector(a, c); Vector2D bd = getVector(b, d); //跨立试验 if(ac.crossProduct(ab) * bd.crossProduct(ab) &lt;=0) &#123; flag2 = true; &#125; return flag1&amp;&amp;flag2;&#125; 123456789101112131415161718192021/** * 判断点是否在线段上 * @param p1 线段端点 * @param p2 线段端点 * @param q 需要判断的点 * @return */public static boolean isPointAtSegment(Point p1,Point p2,Point q) &#123; //判断是否在线段围成的区域内 if(q.getX()&lt;=Math.max(p1.getX(), p2.getX()) &amp;&amp; q.getX()&gt;=Math.min(p1.getX(), p2.getX()) &amp;&amp; q.getY()&lt;= Math.max(p1.getY(), p2.getY()) &amp;&amp; q.getY()&gt;=Math.min(p1.getY(), p2.getY())) &#123; Vector2D qp1 = getVector(q, p1); Vector2D p2p1 = getVector(p2, p1); return qp1.crossProduct(p2p1)==0?true:false; &#125;else &#123; return false; &#125; &#125; 测试结果12345678910111213测试数据1、多边形数据Point aPoint = new Point(0, 0);Point bPoint = new Point(20, -20);Point cPoint = new Point(50, 30);Point dPoint = new Point(30, 30);Point ePoint = new Point(60, -20);Point fPoint = new Point(80, 0);Point gPoint = new Point(40, 70);待测线段数据：Point p1 = new Point(0, 0);Point p2 = new Point(100, 100);Line line1 = new Line(p1,p2); 绘制结果： 计算几何还有一些别的算法，不过毕竟简单也挺好实现的，我就没有写出了]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（二）计算几何基础（中）]]></title>
    <url>%2F2018%2F11%2F12%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[代码已经放在github上，需要的同学自取：https://github.com/XiaoZhong233/GIS_ALG/blob/master/src/scau/gz/zhw/CalculateBasic.java目录一、线段的拐向的判断二、判断点是否在线段上三、判断两线段是否相交①快速排斥试验②跨立试验 快速排斥试验： 跨立试验 一、射线法的实现 转角法 二、转角法的实现 地理数据在计算机中表示大致分为两种，矢量数据和栅格数据。 要计算地理数据的空间关系，一般是矢量数据之间的比较。例如：点，线，面之间的比较。 如何判断线段之间是否相交，线段与面的包含关系。点与面的包含关系等等这些空间关系，都用到计算几何的算法。 空间关系的判定算法的内容有： 1、线段的拐向判断 2、判断两线段是否相交 3、判断矩形是否包含点 4、判断线段，折线，多边形是否在矩形中 5、判断矩形是否在矩形中 6、判断圆是否在矩形中 7、判断点是否在多边形内 8、判断线段是否在多边形内 9、判断折线是否在多边形内 。。。。。。等等 话不多说。一个个的来看。 一、线段的拐向的判断 是现有p,q两个线段，如何判断p和q的方位问题呢？ 可以利用矢量的叉积判断： 二维平面向量很的叉积很好计算 ：例如： p=（x1,y1）,q=(x2,y2)则 p×q=x1y2-x2y1; 有这么三个关系： 若PxQ&gt;0，则说明P在Q的顺时针方向 若PxQ&lt;0，则说明P在Q的逆时针方向 若PxQ=0，则说明PQ共线(共线有可能反向也可能正向) 12345//2个向量的向量积(叉积)public double crossProduct(Vector2D v)&#123; return x * v.y - y * v.x;&#125; Vector2D是我构造的工具类，用于矢量的表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package math;import scau.gz.zhw.Line;import scau.gz.zhw.Point;//平面向量(x,y)的基本运算规则,角度弧度的转换等实现public class Vector2D &#123; private double x; private double y; public Vector2D() &#123; x = 0; y = 0; &#125; public Vector2D(double _x, double _y) &#123; x = _x; y = _y; &#125; /** * * @param a 起点 * @param b 终点 */ public Vector2D(Point a,Point b) &#123; this.x=b.getX()-a.getX(); this.y=b.getY()-a.getY(); &#125; public Vector2D(Line line) &#123; this(line.getStart(), line.getEnd()); &#125; //获取弧度 public double getRadian() &#123; return Math.atan2(y, x); &#125; //获取角度 public double getAngle() &#123; return getRadian() / Math.PI * 180; &#125; public Vector2D clone() &#123; return new Vector2D(x,y); &#125; public double getLength() &#123; return Math.sqrt(getLengthSQ()); &#125; public double getLengthSQ() &#123; return x * x + y * y; &#125; //向量置零 public Vector2D Zero() &#123; x = 0; y = 0; return this; &#125; public boolean isZero() &#123; return x == 0 &amp;&amp; y == 0; &#125; //向量的长度设置为我们期待的value public void setLength(double value) &#123; double _angle = getAngle(); x = Math.cos(_angle) * value; y = Math.sin(_angle) * value; &#125; //向量的标准化（方向不变，长度为1） public Vector2D normalize() &#123; double length = getLength(); x = x / length; y = y / length; return this; &#125; //是否已经标准化 public boolean isNormalized() &#123; return getLength() == 1.0; &#125; //向量的方向翻转 public Vector2D reverse() &#123; x = -x; y = -y; return this; &#125; //2个向量的数量积(点积) public double dotProduct(Vector2D v) &#123; return x * v.x + y * v.y; &#125; //2个向量的向量积(叉积) public double crossProduct(Vector2D v) &#123; return x * v.y - y * v.x; &#125; //计算2个向量的夹角弧度 //参考点积公式:v1 * v2 = cos&lt;v1,v2&gt; * |v1| *|v2| public static double radianBetween(Vector2D v1, Vector2D v2) &#123; if(!v1.isNormalized()) v1 = v1.clone().normalize(); // |v1| = 1 if(!v2.isNormalized()) v2 = v2.clone().normalize(); // |v2| = 1 return Math.acos(v1.dotProduct(v2)); &#125; //弧度 = 角度乘以PI后再除以180、 推理可得弧度换算角度的公式 //弧度转角度 public static double radian2Angle(double radian) &#123; return radian / Math.PI * 180; &#125; //向量加 public Vector2D add(Vector2D v) &#123; return new Vector2D(x + v.x, y + v.y); &#125; //向量减 public Vector2D subtract(Vector2D v) &#123; return new Vector2D(x - v.x, y - v.y); &#125; //向量乘 public Vector2D multiply(double value) &#123; return new Vector2D(x * value, y * value); &#125; //向量除 public Vector2D divide(double value) &#123; return new Vector2D(x / value, y / value); &#125; public double getX() &#123; return x; &#125; public double getY() &#123; return y; &#125; public Line toLine() &#123; return new Line(new Point(0, 0),new Point(x, y)); &#125; public void showGUI() &#123; toLine().showGUI(); &#125; @Override public String toString() &#123; // TODO Auto-generated method stub return String.format("(%.2f,%.2f)", x,y); &#125;&#125; 判断叉积函数： 123456789public static void getDirection(Vector2D p,Vector2D q) &#123; if(p.crossProduct(q)&gt;0) &#123; System.out.println("顺时针"); &#125;else if (p.crossProduct(q)&lt;0) &#123; System.out.println("逆时针"); &#125;else &#123; System.out.println("共线"); &#125;&#125; 测试结果： 说明：为了方便测试，我用java Swing简单写了一个GUI界面 可以绘制矢量的点，线，面，用来验证拐向函数的结果是否正确 ②测试数据二：p=(100,100) q=(-100,-100) 控制台结果： 二、判断点是否在线段上设点为Q，线段为P1P2，判断点Q在该线段上的依据是（Q-P1）X(P2-1) = 0，这样就保证Q在P1P2这条直线上，但是还是不能保证在P1P2的线段上，所以我们得多加个条件：且Q在P1,P2为对角顶点的矩形内 算法： 123456789101112131415161718192021/** * 判断点是否在线段上 * @param p1 线段端点 * @param p2 线段端点 * @param q 需要判断的点 * @return */public static boolean isPointAtSegment(Point p1,Point p2,Point q) &#123; //判断点是否在线段围成的矩形区域内 if(q.getX()&lt;=Math.max(p1.getX(), p2.getX()) &amp;&amp; q.getX()&gt;=Math.min(p1.getX(), p2.getX()) &amp;&amp; q.getY()&lt;= Math.max(p1.getY(), p2.getY()) &amp;&amp; q.getY()&gt;=Math.min(p1.getY(), p2.getY())) &#123; Vector2D qp1 = getVector(q, p1); Vector2D p2p1 = getVector(p2, p1); return qp1.crossProduct(p2p1)==0?true:false; &#125;else &#123; return false; &#125; &#125; 三、判断两线段是否相交判断两线段是否相交，我的第一反应就是解方程，看两线段是否有交点，但是在GIS算法中，我们面对的是海量的数据，这样的算法因为计算量大并不高效。 因此，我们最好得有个筛选的过程，把那些明显不会相交的线段剔除掉，这样就减小了一部分的计算量。 其次，我们判断线段相交最好不要解方程，这样涉及的计算量大，可以用矢量的方法 所以，分为两步确定两天线段是否相交： ①快速排斥试验设以线段a,b为对角线的矩形为R，设以线段c,d为对角线的矩形为T，如果R和T不相交，显然两线段不会相交 ②跨立试验如果ab,cd相交，那么ab必跨过cd，那么（ac x ab ）x（bd xab）&lt;=0 因为ab两边一定分别有个线段（在ab顺时针方向的向量与ab的叉积小于0，在ab逆时针方向的向量与ab叉积大于0），所以乘积是小于0的。至于为什么等于0，是因为ac,和bd有可能在cd上，即ac与ab共线或bd与ab共线或ab和cd共线，那么这种情况就是等于0了，也算相交的一种情况 快速排斥试验：怎么判断两个矩形相不相交，可以这样判断： ①ab的较低点低于cd的较高点 （y值比较） ②cd的左端小于ab的右端(x值比较) ③cd较低点低于ab的较高点(y值比较) ④ab的左端小于cd的右端(x值比较) 算法实现： 1234567//快速排斥试验，判断ab,cd围成的两矩形是否相交if(Math.min(a.getY(), b.getY())&lt;=Math.max(c.getY(), d.getY()) &amp;&amp; Math.min(c.getX(), d.getX())&lt;=Math.max(a.getX(), b.getX())&amp;&amp; Math.min(c.getY(), d.getY())&lt;= Math.max(a.getY(), b.getY()) &amp;&amp; Math.min(a.getX(), b.getX())&lt;= Math.max(c.getX(), d.getX())) &#123; flag1 = true; &#125; 跨立试验1234//跨立试验 if(ac.crossProduct(ab) * bd.crossProduct(ab) &lt;=0) &#123; flag2 = true; &#125; 完整算法在这： 12345678910111213141516171819202122232425/** * 判断两线段是否相交 * @param a * @param b * @param c * @param d * @return */public static boolean isTwoSegmentIntersect(Point a,Point b,Point c,Point d) &#123; boolean flag1 = false; boolean flag2 = false; //快速排斥试验 if(Math.min(a.getY(), b.getY())&lt;=Math.max(c.getY(), d.getY()) &amp;&amp; Math.min(c.getX(), d.getX())&lt;=Math.max(a.getX(), b.getX()) &amp;&amp; Math.min(c.getY(), d.getY())&lt;= Math.max(a.getY(), b.getY()) &amp;&amp; Math.min(a.getX(), b.getX())&lt;= Math.max(c.getX(), d.getX())) &#123; flag1 = true; &#125; Vector2D ab = getVector(a, b); Vector2D ac = getVector(a, c); Vector2D bd = getVector(b, d); //跨立试验 if(ac.crossProduct(ab) * bd.crossProduct(ab) &lt;=0) &#123; flag2 = true; &#125; return flag1&amp;&amp;flag2;&#125; 三、判断点是否在多边形内 判断点是否在多边形内有两种方法，一种是射线法，另一种是转角法。 ①射线法：引一条从P开始，穿过多边形边界的次数为交点数目。当交点数目为偶数时，点P在多边形外部 为方便计算选取一条水平的、从被判断点的右边延伸的，平行于x轴的射线。 为了使在某些特殊情况下判断穿越是否有效，有效穿越要符合以下几个规则： 方向向上的边包括开始点，不包括终止点 方向向下的边包括终止点，不包括开始点 水平边不参与测试 射线和多边形的边的交点必须严格在点P的右边 如果点在多边形边上，则直接判断为在多边形内部（这一条可以根据不同需要设定为不同的结果） 射线法算法步骤： 说明:p射线是由点p延伸出的水平x轴正方向射线 开始遍历多边形的每条边 判断边是否水平，如果是就跳出本次循环 如果点在多边形上，直接返回true 判断p射线是否在边的左边，如果不在，就直接跳过该边的计算 判断p射线是否穿过边的端点，是则利用上面所述规则1,2进行穿越测试 遍历结束，根据穿越数得出结果 话不多说，看算法实现吧： 一、射线法的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public static boolean isPointAtPolygon(Point[] points,Point p) &#123; int crossNum = 0; boolean flag = false; if(Double.doubleToLongBits(points[points.length-1].getX())==Double.doubleToLongBits(points[0].getX()) &amp;&amp; Double.doubleToLongBits(points[points.length-1].getY()) == Double.doubleToLongBits((points[0].getY())))&#123; flag = true; &#125; //如果最后一个点不等于第一个点 //自动闭合 ArrayList&lt;Line&gt; lines = new ArrayList&lt;Line&gt;(); if(!flag) &#123; for(int i=0;i&lt;points.length;i++) &#123; Line line = new Line(points[i%points.length], points[(i+1)%points.length]); lines.add(line); &#125; &#125;else &#123; for(int i=0;i&lt;points.length-1;i++) &#123; Line line = new Line(points[i], points[i+1]); lines.add(line); &#125; &#125; //遍历每条边 if(type==0) &#123; for(Line line : lines) &#123; //rule#1:方向向上的边包括其开始点,不包括其终止点 //rule#2:方向向下的边包括其终止点,不包括其开始点 //rule#3:水平边不参与穿越测试 //rule#4:射线和多边形的边的交点必须严格在点p的右边 //如果点在线段上则直接判定为在多边形内部 if(isPointAtSegment(line.getStart(), line.getEnd(), p)) &#123; return true; &#125; //rule#3 if(!line.isHorizontal()) &#123; //rule#4,保证p在边的右边 if(Double.doubleToLongBits(p.getX()) &lt; Double.doubleToLongBits(line.getXByY(p.getY())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&gt;=Double.doubleToLongBits(Math.min(line.getStart().getX(),line.getEnd().getX())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&lt;=Double.doubleToLongBits(Math.max(line.getStart().getX(), line.getEnd().getX()))) &#123; //rule#1,2 //当点的射线穿过每条边的端点时，规则1,2起作用 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY()) ||Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getEnd().getY()) ) &#123; if(line.isUp()) &#123; //判断是穿过开始点还是终止点 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY())) &#123; //方向为上，穿过开始点，则有效穿越 crossNum++; &#125;else &#123; //方向为上，穿过终止点，则无效穿越 &#125; &#125;else &#123; //判断是穿过开始点还是终止点 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY())) &#123; //方向为下，穿过开始点，则无效穿越 &#125;else &#123; //方向为下，穿过终止点，则有效穿越 crossNum++; &#125; &#125; &#125;else &#123; //直接计算 ++crossNum; &#125; &#125; &#125; &#125; //奇数在内，偶数在外 //System.out.println("crossNum : " +crossNum); return crossNum%2==0?false:true;&#125; 注释说的很详细了，就不加赘述了。 转角法转角法可以很精确地判断一个点是否在非简单多边形内部（就是多边形内部还有一些复杂的构造，后面有对比说明）。它需要计算多边形绕点有多少次。如果环绕数为零，那么点在多边形外部，非零，则点在多边形内部。 转角法也和射线法类似，遵守这么些规则： 方向向上的边包括开始点，不包括终止点 方向向下的边包括终止点，不包括开始点 水平边不参与测试 射线和多边形的边的交点必须严格在点P的右边 如果点在多边形边上，则直接判断为在多边形内部（这一条可以根据不同需要设定为不同的结果） 看上面这个多边形，如果从多边形的a边开始遍历 （水平边不参与穿越测试），因此a跳过 规定点在边的左边（以边的前进方向为准）时环绕数+1，点在边的右边时（以边的前进方向为准）环绕数-1； 那么上边这个p点环绕数（从a边开始）的计算过程就为（-1,-1,-1,-1） 结果为-4，不等于零，说明在多边形内部 q点的环绕数计算过程（从a边开始）为（+1，-1，-1，+1），结果为0，说明在多边形外部。 关于如何判断点在边的右边还是左边，可以从点向右做一条水平射线(为了保证边与射线的交点在点的右边) 判断该射线与边的叉积即可 二、转角法的实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static boolean isPointAtPolygon(Point[] points,Point p)&#123;//转角法需要判断从p向右出发的水平射线与线段方向的关系，即p是否在边的左边 //int count = 0; for(Line line:lines) &#123; //如果点在线段上则直接判定为在多边形内部 if(isPointAtSegment(line.getStart(), line.getEnd(), p)) &#123; return true; &#125; if(!line.isHorizontal()) &#123; //构造从p出发的水平向右射线，rule#3 Vector2D pVector2d = new Vector2D(p.getX(),0); //保证p在边的左边，rule#4 if(Double.doubleToLongBits(p.getX()) &lt; Double.doubleToLongBits(line.getXByY(p.getY())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&gt;=Double.doubleToLongBits(Math.min(line.getStart().getX(),line.getEnd().getX())) &amp;&amp; Double.doubleToLongBits(line.getXByY(p.getY()))&lt;=Double.doubleToLongBits(Math.max(line.getStart().getX(), line.getEnd().getX()))) &#123; //System.out.println("id : "+count++ +" direction: "+line.getDirection()); //边向上,p在边左边-&gt;p的向右出发的水平射线在边的顺时针方向 if(line.isUp()) &#123; //rule#1,2 //这种情况只在点的射线穿过每条边的端点才有用 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY()) ||Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getEnd().getY()) ) &#123; //判断是穿过开始点还是终止点 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY())) &#123; //方向为上，穿过开始点，则有效穿越 if(pVector2d.crossProduct(line.getVector2D())&gt;0) &#123; crossNum++; &#125;else &#123; crossNum--; &#125; &#125;else &#123; //方向为上，穿过终止点，则无效穿越 &#125; &#125;else &#123; //不穿过端点的情况 if(pVector2d.crossProduct(line.getVector2D())&gt;0) &#123; crossNum++; &#125;else &#123; crossNum--; &#125; &#125; &#125; //边向下,p在边左边-&gt;p的向右出发的水平射线在边的顺时针方向 if (line.isDown()) &#123; //rule#1,2 //这种情况只在点的射线穿过每条边的端点才有用 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY()) ||Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getEnd().getY()) ) &#123; //判断是穿过开始点还是终止点 if(Double.doubleToLongBits(p.getY()) == Double.doubleToLongBits(line.getStart().getY())) &#123; //方向为下，穿过开始点，则无效穿越 &#125;else &#123; //方向为下，穿过终止点，则有效穿越 if(pVector2d.crossProduct(line.getVector2D())&gt;0) &#123; crossNum++; &#125;else &#123; crossNum--; &#125; &#125; &#125;else &#123; //不穿过端点的情况 if(pVector2d.crossProduct(line.getVector2D())&gt;0) &#123; crossNum++; &#125;else &#123; crossNum--; &#125; &#125; &#125; &#125; &#125;&#125; 上面也说到，转角法更为精确一些，为什么呢？ 因为在一些多边形中可能会有复杂的构造，这种情况下，射线法的计算结果会不准确 例如： 这种情况下 可以看到同样的多边形，同样的点，用不同的方法会得到不同的结果。这是因为转角法更精确，而射线法的缺点在于没有考虑到多边形内部的复杂构造可能使结果出现偏差。 转角法是在射线法的基础上进行的优化，他具有和射线法相同的效率，并且，它更为精确，因此，判断点是否在任意多边形时，转角法是首选 射线法的思路比较简单，只需要判断穿越次数的奇偶性即可。但需要注意的是，判断穿越为有效穿越需要严格遵守4个规则。但是射线法的缺陷也是很明显的，它的判断不够精确。在左图的情况下，射线法的结果是false，而转角法的结果是true。 射线法是没有考虑到多边形内部的构造的。而转角法是射线法的优化（因为他们使用了相同的穿越规则），它通过计算环绕次数来得出结果，会考虑多边形内部的构造问题。 在同样的效率下，转角算法比射线算法准确度更高。 同时，我认为这也是个仁者见仁智者见智的过程，因为不同的场景下，可能把多边形形成的内部构造的认为是属于该多边形的，也可能认为是不属于的。因此具体的使用要根据具体场景而选择不同的方法。]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIS算法基础（一） 计算几何基础（上）]]></title>
    <url>%2F2018%2F10%2F08%2FGIS%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在学习GIS算法，在学习过程中，想把一些经典的算法或者思想记录下来，分享给大家计算几何基础本来是计算机图形学的内容，但是GIS在图像处理中是离不开计算机处理的，所以GIS算法基础第一个应该是计算几何基础。如何把空间实体的点线面以及他们之间的关系（例如，相交，包含，邻接，叠置等等）用计算机语言表达出来，应该是这里解决的第一个问题。前人已经有过这样这样的解决模型—DE-9IM模型（Dimensionally Extended nine-Intersection Model） DE9IM模型是一种拓扑模型，他用于描述多边形之间的关系。现有两个多边形，如果他们相交，那他们的边界，内部，外部的交集情况是怎么样的？如果相离呢？情况又是怎样的？DE9IM实际上就是一个3X3的矩阵，他存储着两个多边形，边界，内部，外部，的交集情况。 假如交集的结果用维数dim ={-1,0,1,2} 表示，-1代表无交集，0代表交集为一个点，1代表线，2代表面。 上面这个图能很好的说明这个问题。 a,b代表两个面，他们边界，内部，外部，相交的结果就是 红色的部分 例如a的内部和b的内部 交集应该是一个面，所以是2；a的边界和b的边界，交集应该是两个点，所以是0； 总结一下：dim = -1 无交集; ​ dim = 0 交集中不包含线和面，但至少包含一个点 ​ dim = 1 交集中不包含面，但至少包含一个面 ​ dim = 2 交集至少包含一个面 现在多边形之间的问题的模型解决了，那么如何用计算机语言表达呢？ 上面也说了，这个交集的结果可以用一个3x3的矩阵表达。例如上边的a,b交集结果 表达为： 2 1 2 1 0 1 2 1 2 于是，空间关系的描述可以归纳为：两个几何体，以表示两个几何体的DE-9IM结果的矩阵输入，然后把这个矩阵转为字符串，例如上面这个就变为”212101212”了 如果我们说两个多边形相交，那就是他们的结果要有 0,1,2 也就是交集中游点或线或面 在计算机中就是 (0,1,2) -&gt;true ​ (-1) -&gt;false ​ (-1,0,1,2)-&gt;* 那么上面那个字符串就可以表示成”TTTTTTTTT” 经过前人的整理，空间关系的判断可以通过特定的一些模式进行判断 谓词 返回值 描述 相等（Equals) T*F**FFF* 边界上的点和内部的点全部重合。属于相交的一种 相离（Disjoint) FF*FF**** 不相交，与相交相反 相接（Touches) FT*******\F**T*****\F***T**** 只有边界上有共同点，内部没有。属于相交的一种 覆盖（Covers) T*****FF*\*T****FF*\***T**FF*\****T*FF* b上的每个点都在a上（边界和内部），且所有点都不在a外部。属于相交的一种 叠置（Overlaps) T*T***T**\1*T***T** a和b相交，且具有一部分共同点，但不是全部内部点。属于相交的一种 所以，只要我们得到了两个多边形的DE9IM矩阵结果，我们就可以判断他们之间的关系了。 那怎样获得两个多边形的交集结果呢？这关系到点，线，面-点，线，面 之间的判断，这些后面在更]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS算法</tag>
      </tags>
  </entry>
</search>
